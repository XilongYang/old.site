<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言中浮点数的二进制表示（IEEE754）</title>
      <link href="/blog/2019/08/18/0001-C:Floating_point_numbers_IEEE754/"/>
      <url>/blog/2019/08/18/0001-C:Floating_point_numbers_IEEE754/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：最近在C语言学习中遇到了浮点运算精度的问题， 在查找资料后发现是浮点数的储存方式引起的问题，在此做一个记录。</p></blockquote><span id="more"></span><h3 id="问题代码："><a href="#问题代码：" class="headerlink" title="问题代码："></a>问题代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        a += (<span class="keyword">float</span>)arr[i] / <span class="number">10.0</span>;  <span class="comment">//求arr中所有数的平均数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; a) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]); <span class="comment">//将arr中大于平均数的数打印出来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不难看出，以上程序理论上不应该输出任何数据，可是实际运行结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 3 3 3 3 3 3 3 3 3 3</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>经过一番尝试，最后发现是由于本代码中a的值并非3.0而是2.99999，由此判断应该是浮点数的运算精度问题。</p><p>浮点数在内存中是按照IEEE754标准进行储存的， 即一个float类型的数据占用8Byte内存，其中包括符号位1位，阶码8位和尾数23位。图示如下：</p><table><thead><tr><th align="center">S(符号位)</th><th align="center">E(阶码)</th><th align="center">M(尾数)</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0000 0000</td><td align="center">0000 0000 0000 0000 0000 000</td></tr></tbody></table><p>其中符号位决定该浮点数的正负，正值为0，负值为1。</p><p>阶码用以表示该浮点数的指数，其值为</p><p><code>E = e(指数值) + 127</code> </p><p>这样可以保证E不为负数，方便机器运算。其中127为float类型的偏移值，其它浮点类型的有其它偏移值。</p><p>按照浮点规格化表示，尾数的最高有效位应为1，这意味着M表示的值为1.M。</p><p>以遇到的问题中的值0.3为例， 其转化过程如下。</p><ol><li>将十进制数转换为二进制，小数点前除2取余，小数点后乘2取整<br>$$(0.3)_{10} &#x3D; (0.0100110011001100110011001)_2 $$</li></ol><p>此时可以发现0.3的二进制是无限循环的，故而只能截取到精度对应的位数。</p><ol start="2"><li><p>规格化表示<br>$$0.100110011001100110011001&#x3D;+1.00110011001100110011001\times2^{-2}$$</p></li><li><p>计算相应的值<br>S&#x3D;0, E &#x3D; 127 - 2 &#x3D; 125 &#x3D; 0111 1101, M &#x3D; 0011 0011 0011 0011 0011 001</p></li></ol><p>所以0.3在内存中应该为</p><table><thead><tr><th>S</th><th>E</th><th>M</th></tr></thead><tbody><tr><td>0</td><td>0111 1101</td><td>0011 0011 0011 0011 0011 001</td></tr></tbody></table><p>转化为16进制数为：3E999999</p><p>可以用以下程序验证</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">0.3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, *(<span class="keyword">int</span> *)&amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>得到结果：3E99999A， 与理论计算值3E999999相差1，应该是计算机处理过程中对末位进行了四舍五入。</p>]]></content>
      
      
      <categories>
          
          <category> 0x01 C++之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

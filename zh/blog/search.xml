<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CF-R765-B题解</title>
      <link href="/zh/blog/2022/01/13/0035-CF-R765-B/"/>
      <url>/zh/blog/2022/01/13/0035-CF-R765-B/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a class="link" href="https://codeforces.com/contest/1625">Codeforces Round #765<i class="fas fa-external-link-alt"></i></a>被橄榄了。但B与C两题都刚好处在有思路而没解出来的难度，是很好的学习机会。</p></blockquote><span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Elementary Particles</p><p>Martians(火星人) are actively engaged(吸引，卷入) in interplanetary trade. Olymp City, the Martian city known for its spaceport, has become a place where goods from all the corners of our Galaxy come. To deliver even more freight(货物；运费) from faraway planets, Martians need fast spaceships.</p><p>A group of scientists conducts experiments to build a fast engine for the new spaceship. In the current experiment, there are <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> elementary(基本的；元素的) particles, the <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>-th of them has type <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="1.937ex" height="1.355ex" role="img" focusable="false" viewBox="0 -441 856 598.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>.</p><p>Denote <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.02ex" role="img" focusable="false" viewBox="0 -441 529 451"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container> subsegment of the particle sequence <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="14.52ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6418 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1354.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1799.2,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2764.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(3209.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(4548.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(4992.8,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(6029,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> as a sequence <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="15.68ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6930.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g></g><g data-mml-node="mo" transform="translate(1211.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1656.4,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="TeXAtom" transform="translate(562,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(298,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1076,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="mo" transform="translate(3382.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(3827.5,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(5166.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(5610.8,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(6541.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> for some left bound <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="0.674ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 298 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g></g></g></svg></mjx-container> and right bound <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="16.015ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7078.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(451,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(840,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1617.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(2673.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(3249.3,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(4305.1,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(5033.9,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(6089.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(6689.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>. For instance, the sequence (1 4 2 8 5 7) for <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="4.823ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2131.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(575.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1631.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container> and <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="5.169ex" height="1.717ex" role="img" focusable="false" viewBox="0 -677 2284.6 759"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(728.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1784.6,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></svg></mjx-container> has the sequence (4 2 8) as a subsegment. <strong>Two subsegments are considered different if at least one bound of those subsegments differs</strong>.</p><p>Note that the <strong>subsegments can be equal as sequences but still considered different.</strong> For example, consider the sequence (1 1 1 1 1) and two of its subsegments: one with <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="4.823ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2131.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(575.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1631.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container> and <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="5.169ex" height="1.69ex" role="img" focusable="false" viewBox="0 -665 2284.6 747"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(728.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1784.6,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></svg></mjx-container> and another with <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="4.823ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2131.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(575.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1631.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container> and <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="5.169ex" height="1.717ex" role="img" focusable="false" viewBox="0 -677 2284.6 759"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(728.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1784.6,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></svg></mjx-container>. Both subsegments are equal to (1 1 1), but still considered different, as their left and right bounds differ.</p><p>The scientists want to conduct(指导；引导；指挥) a reaction(反应) to <strong>get two different subsegments of the same length.</strong> Denote this length <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container>. The resulting pair of subsegments must be <strong>harmonious</strong>, i. e. for some <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="11.665ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 5156.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(734,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1511.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(2567.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3190.3,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(4246.1,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(4767.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> it must be true that the types of particles on the <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>-th position are the same for these two subsegments. For example, the pair (1 7 3) and (4 7 8) is harmonious, as both subsegments have 7 on the second position. The pair (1 2 3) and (3 1 2) is not harmonious.</p><p>The longer are harmonious subsegments, the more chances for the scientists to design a fast engine. So, they asked you to <strong>calculate the maximal possible length of harmonious pair made of different subsegments.</strong></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains an integer <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="25.329ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 11195.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(361,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(750,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1527.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(2583.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(3222.3,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mn" transform="translate(4278.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(1500,0)"></path></g><g data-mml-node="mo" transform="translate(6555.9,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(7611.7,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(8250.4,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mn" transform="translate(9306.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"></path></g><g data-mml-node="mo" transform="translate(10806.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> — the number of test cases. The following are descriptions of the test cases.</p><p>The first line contains an integer <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="18.428ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 8145.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(989,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(1766.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(2822.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3700.3,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mn" transform="translate(4756.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(2000,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(2500,0)"></path></g><g data-mml-node="mo" transform="translate(7756.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> — the amount of elementary particles in the sequence.</p><p>The second line contains <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> integers <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="19.586ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 8657 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(856,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1245,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2022.7,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="msub" transform="translate(3078.5,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(4212.2,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mn" transform="translate(5268,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(2000,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(2500,0)"></path></g><g data-mml-node="mo" transform="translate(8268,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> — types of elementary particles.</p><p>It is guaranteed that the sum of <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> over all test cases does not exceed <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="6.016ex" height="2.005ex" role="img" focusable="false" viewBox="0 -864 2659 886"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="msup" transform="translate(1222.4,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mn" transform="translate(1033,393.1) scale(0.707)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g></g></g></g></svg></mjx-container>.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test, print a single integer, maximal possible length of harmonious pair made of different subsegments. If such pair does not exist, print <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="2.891ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 1278 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container> instead.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>input:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">7</span><br><span class="line">3 1 5 2 1 3 4</span><br><span class="line">6</span><br><span class="line">1 1 1 1 1 1</span><br><span class="line">6</span><br><span class="line">1 4 2 8 5 7</span><br><span class="line">2</span><br><span class="line">15 15</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">-1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>给定一个序列，找出两个连续子序列，满足：</p><ol><li>两个子序列的在原序列中的位置不同，可以重叠但不能相等。</li><li>两个子序列至少有一个相同位置的元素相同。相同位置可以理解为数组下标，即要求至少存在一个<code>i</code>，使得<code>a[i]=b[i]</code>成立。</li><li>两个子序列长度相等，且为所有符合要求的子序列组中最长的。</li></ol><p>若存在这个的子序列组，输出它的长度。否则输出<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="2.891ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 1278 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>遍历所有子序列，并比对它们是否符合条件。由于长度是相等的，对于每种可能的长度只要确定起点就确定了终点。因此遍历时间复杂度为：</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="27.654ex" height="2.451ex" role="img" focusable="false" viewBox="0 -833.2 12223 1083.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2363.2,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(3085.4,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(3848.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(4237.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4837.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5448.7,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(6170.9,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(6933.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(7322.9,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(7922.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(8589.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(9645.4,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(10408.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(10797.4,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><g data-mml-node="mo" transform="translate(11834,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>此外还得对每种遍历结果进行比对，时间复杂度<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。总时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.47ex" role="img" focusable="false" viewBox="0 -841.7 2577.6 1091.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。不用考虑了，没戏。</p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>稍作思考，可以发现本题中只有序列起点会影响是否符合条件。因此可以使用下面的方式，逐步位移来比对序列，一但出现相同位置相同元素，则两序列重叠部分即为最长的序列组。</p><p><img src="https://img.xilong.site/picgo/20220113231911.png"></p><p>此时时间复杂度就降低至：位移<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> ， 匹配<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> ，总时间复杂度<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。仍然不可接受，</p><p>这里发现实际上我们的要求就是通过最短的位移将一对相同的元素对上。那只要找到原序列中最短相同元素对就可以了。位移后的长度损失为两元素间距，侧最长序列组长度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex" xmlns="http://www.w3.org/2000/svg" width="29.236ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 12922.4 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">原</text></g><g data-mml-node="mi" transform="translate(900,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">序</text></g><g data-mml-node="mi" transform="translate(1800,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">列</text></g><g data-mml-node="mi" transform="translate(2700,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">长</text></g><g data-mml-node="mi" transform="translate(3600,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">度</text></g><g data-mml-node="mo" transform="translate(4722.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(5722.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">最</text></g><g data-mml-node="mi" transform="translate(6622.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">短</text></g><g data-mml-node="mi" transform="translate(7522.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">相</text></g><g data-mml-node="mi" transform="translate(8422.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">同</text></g><g data-mml-node="mi" transform="translate(9322.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">元</text></g><g data-mml-node="mi" transform="translate(10222.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">素</text></g><g data-mml-node="mi" transform="translate(11122.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">间</text></g><g data-mml-node="mi" transform="translate(12022.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">距</text></g></g></g></svg></mjx-container>。</p><p>找最短相同元素对需要为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>元素进行一次<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>复杂度的遍历，则时间复杂度仍然是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。此时可以使用一个<code>map</code>记录下每个元素的最小元素对，然后只要一次搜索即可。时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4001 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1752,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(2050,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(2535,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(3012,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3612,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。可以接受了。</p><p>本题由于空间够大，可以将<code>map</code>换成数组，将时间复杂度降低到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> MAX = <span class="number">150005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储上个元素的位置</span></span><br><span class="line"><span class="keyword">int</span> l[MAX];</span><br><span class="line"><span class="comment">// 存储当前元素的位置</span></span><br><span class="line"><span class="keyword">int</span> r[MAX];</span><br><span class="line"><span class="comment">// 存储元素最小间距</span></span><br><span class="line"><span class="keyword">int</span> d[MAX]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; ++i) {</span><br><span class="line">        l[i] = <span class="number">0</span>; </span><br><span class="line">        r[i] = <span class="number">0</span>; </span><br><span class="line">        d[i] = MAX;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是第一个元素，则加入l。</span></span><br><span class="line">        <span class="comment">// 如果第二个则加入r并计算间距。</span></span><br><span class="line">        <span class="comment">// 否则更新位置并计算间距。</span></span><br><span class="line">        <span class="keyword">if</span> (l[tmp] == <span class="number">0</span>) {</span><br><span class="line">            l[tmp] = i;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (r[tmp] == <span class="number">0</span>) {</span><br><span class="line">            r[tmp] = i;</span><br><span class="line">            d[tmp] = <span class="built_in">min</span>(d[tmp], r[tmp] - l[tmp]);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            l[tmp] = r[tmp];</span><br><span class="line">            r[tmp] = i;</span><br><span class="line">            d[tmp] = <span class="built_in">min</span>(d[tmp], r[tmp] - l[tmp]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 因为没有结果时，输出将是n - m，且要求为-1，故置m为n+1。</span></span><br><span class="line">    <span class="keyword">int</span> m = n + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 使用最小的间距值来代替m。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; ++i ) {</span><br><span class="line">        m = <span class="built_in">min</span>(d[i], m);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; n - m &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) {</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">input</span>();</span><br><span class="line">        <span class="built_in">output</span>(); </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0x00 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的Haskell（七）——折叠与幺半群</title>
      <link href="/zh/blog/2022/01/10/0034-Re0:Haskell_07/"/>
      <url>/zh/blog/2022/01/10/0034-Re0:Haskell_07/</url>
      
        <content type="html"><![CDATA[<blockquote><p>系列第七篇，介绍了更一般性的折叠以及幺半群。</p></blockquote><span id="more"></span><h2 id="折叠，又见折叠"><a href="#折叠，又见折叠" class="headerlink" title="折叠，又见折叠"></a>折叠，又见折叠</h2><p>我们已经知道怎么折叠一个列表了，但我们也可以将折叠思想更一般性地用于其它数据类型。比如对于下面这个二叉树，考虑一些函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Empty</span></span></span><br><span class="line">            | <span class="type">Node</span> (<span class="type">Tree</span> a) a (<span class="type">Tree</span> a)</span><br><span class="line">    <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br><span class="line">    </span><br><span class="line"><span class="title">leaf</span> :: a -&gt; <span class="type">Tree</span> a</span><br><span class="line"><span class="title">leaf</span> x = <span class="type">Node</span> <span class="type">Empty</span> x <span class="type">Empty</span></span><br></pre></td></tr></table></figure><p>写一个函数来计算树的节点数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">treeSize</span> :: <span class="type">Tree</span> a -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">treeSize</span> <span class="type">Empty</span> = <span class="number">0</span></span><br><span class="line"><span class="title">treeSize</span> (<span class="type">Node</span> l _ r) = <span class="number">1</span> + treeSize l + treeSize r</span><br></pre></td></tr></table></figure><p>计算一个<code>Tree Integer</code>的数据总和：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">treeSum</span> :: <span class="type">Tree</span> <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">treeSum</span> <span class="type">Empty</span> = <span class="number">0</span></span><br><span class="line"><span class="title">treeSum</span> (<span class="type">Node</span> l x r) = x + treeSum l + treeSum r</span><br></pre></td></tr></table></figure><p>计算树的高度：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">treeDepth</span> :: <span class="type">Tree</span> a -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">treeDepth</span> <span class="type">Empty</span> = <span class="number">0</span></span><br><span class="line"><span class="title">treeDepth</span> (<span class="type">Node</span> l _ r) = <span class="number">1</span> + max (treeDepth l) (treeDepth r)</span><br></pre></td></tr></table></figure><p>将树内元素展开成一个列表：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">flatten</span> :: <span class="type">Tree</span> a -&gt; [a]</span><br><span class="line"><span class="title">flatten</span> <span class="type">Empty</span> = []</span><br><span class="line"><span class="title">flatten</span> (<span class="type">Node</span> l x r) = flatten l ++ [x] ++ flatten r</span><br></pre></td></tr></table></figure><p>你是否从中看出一些相似的模式？对于上述每个函数，有：</p><ol><li>接受一个树作为输入</li><li>对输入的树进行模式匹配</li><li>对于<code>Empty</code>节点，返回一个简单的值</li><li>对于<code>Node</code>节点：<ol><li>递归的处理左右子树</li><li>以某种方式组合递归的结果，并生成最终结果</li></ol></li></ol><p>作为一名好的程序员，我们总是希望将抽象出重复的模式。首先需要将各例子中变化的部分作为参数，它们是：</p><ol><li>返回类型</li><li>空节点的值</li><li>组合递归调用的方式</li></ol><p>设树处理的类型为<code>a</code>，函数的返回类型为<code>b</code>，有：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">treeFold</span> :: b -&gt; (b -&gt; a -&gt; b -&gt; b) -&gt; <span class="type">Tree</span> a -&gt; b</span><br><span class="line"><span class="title">treeFold</span> e _ <span class="type">Empty</span> = e</span><br><span class="line"><span class="title">treeFold</span> e f (<span class="type">Node</span> l x r) = f (treeFold e f l) x (treeFold e f r)</span><br></pre></td></tr></table></figure><p>有了这个折叠函数，我们就可以更轻易地定义上面的几个例子了：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">treeSize&#x27;</span> :: <span class="type">Tree</span> a -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">treeSize&#x27;</span> = treeFold <span class="number">0</span> (\l _ r -&gt; l + <span class="number">1</span> + r)</span><br><span class="line"></span><br><span class="line"><span class="title">treeSum&#x27;</span> :: <span class="type">Tree</span> <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">treeSum&#x27;</span> = treeFold <span class="number">0</span> (\l x r -&gt; l + x + r)</span><br><span class="line"></span><br><span class="line"><span class="title">treeDepth&#x27;</span> :: <span class="type">Tree</span> a -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">treeDepth&#x27;</span> = treeFold <span class="number">0</span> (\l _ r -&gt; <span class="number">1</span> + max l r)</span><br><span class="line"></span><br><span class="line"><span class="title">flatten&#x27;</span> :: <span class="type">Tree</span> a -&gt; [a]</span><br><span class="line"><span class="title">flatten&#x27;</span> = treeFold [] (\l x r -&gt; l ++ [x] ++ r)</span><br></pre></td></tr></table></figure><p>我们也可以轻松实现其它的树折叠函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">treeMax</span> :: (<span class="type">Ord</span> a, <span class="type">Bounded</span> a) =&gt; <span class="type">Tree</span> a -&gt; a</span><br><span class="line"><span class="title">treeMax</span> = treeFold minBound (\l x r -&gt; max l $ max x r)</span><br></pre></td></tr></table></figure><p>这样感觉就好多了，去除了大量重复模式，非常优雅。</p><h3 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h3><p>回想下Homework5中的<code>ExprT</code>类型和相应的<code>eval</code>函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ExprT</span> = <span class="type">Lit</span> <span class="type">Integer</span></span></span><br><span class="line">           | <span class="type">Add</span> <span class="type">ExprT</span> <span class="type">ExprT</span></span><br><span class="line">           | <span class="type">Mul</span> <span class="type">ExprT</span> <span class="type">ExprT</span></span><br><span class="line"></span><br><span class="line"><span class="title">eval</span> :: <span class="type">ExprT</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">Lit</span> i) = i</span><br><span class="line"><span class="title">eval</span> (<span class="type">Add</span> a b) = eval a + eval b</span><br><span class="line"><span class="title">eval</span> (<span class="type">Mul</span> a b) = eval a * eval b</span><br></pre></td></tr></table></figure><p>看着就欠抽象！来试试这样写：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">exprTFold</span> :: (<span class="type">Integer</span> -&gt; b) -&gt; (b -&gt; b -&gt; b) -&gt; (b -&gt; b -&gt; b) -&gt; <span class="type">ExprT</span> -&gt; b</span><br><span class="line"><span class="title">exprTFold</span> f _ _ (<span class="type">Lit</span> i) = f i</span><br><span class="line"><span class="title">exprTFold</span> f g h (<span class="type">Add</span> a b) = g (exprTFold f g h a) (exprTFold f g h b)</span><br><span class="line"><span class="title">exprTFold</span> f g h (<span class="type">Mul</span> a b) = h (exprTFold f g h a) (exprTFold f g h b)</span><br><span class="line"></span><br><span class="line"><span class="title">eval&#x27;</span> :: <span class="type">ExprT</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">eval&#x27;</span> exprTFold id (+) (*)</span><br></pre></td></tr></table></figure><p>现在我们可以做一些别的事，比如计算表达式中数字的个数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">numLiterals</span> :: <span class="type">ExprT</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">numLiterals</span> = exprTFold (const <span class="number">1</span>) (+) (+)</span><br></pre></td></tr></table></figure><h3 id="普适的折叠"><a href="#普适的折叠" class="headerlink" title="普适的折叠"></a>普适的折叠</h3><p>这里透露的信息是我们可以为很多（并非全部）数据类型创建折叠操作。作用于<code>T</code>类型的折叠操作会为<code>T</code>的每个构造器取一个（高层面的）参数，考虑怎么把构造器中的数据类型转换成返回值的类型——直到所有递归过程被折叠成一个结果。</p><p>很多我们可能想为<code>T</code>实现的的函数在折叠操作下会很易于表达。</p><h2 id="幺半群（Monoids）"><a href="#幺半群（Monoids）" class="headerlink" title="幺半群（Monoids）"></a>幺半群（Monoids）</h2><p>离散数学里接触过幺半群的概念，定义如下：</p><ul><li>幺半群是一个带有二元运算<code>* : M * M -&gt; M</code>的集合<code>M</code>，其符合以下公理<ul><li>结合律：对任意<code>M</code>内的元素<code>a</code>、<code>b</code>、<code>c</code>，有<code>(a * b) * c = a * (b * c)</code></li><li>单位元：存在<code>M</code>内的元素<code>e</code>，使任一存于<code>M</code>内的元素<code>a</code>满足<code>a * e = e * a = a</code></li><li>封闭性（内含于二元运算中）：对任意在<code>M</code>内的元素<code>a</code>、<code>b</code>，<code>a*b</code>也在<code>M</code>中</li></ul></li></ul><p>Haskell中幺半群是一种基本类型类，定义在<code>Data.Monoid</code>模块里：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monoid</span> m <span class="keyword">where</span></span></span><br><span class="line">    mempty  :: m</span><br><span class="line">    mappend :: m -&gt; m -&gt; m</span><br><span class="line">    </span><br><span class="line">    mconcat :: [m] -&gt; m</span><br><span class="line">    mconcat = foldr mappend mempty</span><br><span class="line"></span><br><span class="line">(&lt;&gt;) <span class="type">Monoid</span> m =&gt; m -&gt; m -&gt; m</span><br><span class="line">(&lt;&gt;) = mappend</span><br></pre></td></tr></table></figure><p>其中<code>mempty</code>相当于单位元的定义，<code>mappend</code>与其符号简写<code>&lt;&gt;</code>为幺半群中的二元运算。<code>mconcat</code>用于将整个列表折叠成一个值，默认使用<code>foldr</code>来实现，但由于对某种特定的<code>Monoid</code>类型可能存在更高效的实现，模块中提供了它的定义供修改。</p><p>正如之前提到的幺半群的性质，对任何<code>Monoid</code>类型的值<code>x</code>、<code>y</code>、<code>z</code>有：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mempty</span> &lt;&gt; x = x</span><br><span class="line"><span class="title">x</span> &lt;&gt; mempty = x</span><br><span class="line">(x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z)</span><br></pre></td></tr></table></figure><h3 id="Monoid-实例"><a href="#Monoid-实例" class="headerlink" title="Monoid 实例"></a>Monoid 实例</h3><p>在知道这些概念后就会发现，<code>Monoid</code>无处不在。比如一个列表：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> [a] <span class="keyword">where</span></span></span><br><span class="line">    mempty  = []</span><br><span class="line">    mappend = (++)</span><br></pre></td></tr></table></figure><p>考虑下会发现这是完美符合<code>Monoid</code>性质的。同理可以发现数值类型的加法和乘法也完美符合<code>Monoid</code>的性质。但要怎样分别实现数值加法和乘法的<code>Monoid</code>呢？我们不能在一个类型类中创建同一个类型的两个不同实例，即以下方法：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Monoid</span> a <span class="keyword">where</span></span></span><br><span class="line">    mempty  = <span class="number">0</span></span><br><span class="line">    mappend = (+)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Monoid</span> a <span class="keyword">where</span></span></span><br><span class="line">    mempty  = <span class="number">0</span></span><br><span class="line">    mappend = (*)</span><br></pre></td></tr></table></figure><p>是非法的，因为有重复定义。为解决这个问题，我们可以创建两个新类型作为数值类型的不同封装：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Sum</span> a = <span class="type">Sum</span> a</span></span><br><span class="line">    <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Num</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">getSum</span> :: <span class="type">Sum</span> a -&gt; a</span><br><span class="line"><span class="title">getSum</span> (<span class="type">Sum</span> a) = a</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Monoid</span> (<span class="type">Sum</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty  = <span class="type">Sum</span> <span class="number">0</span></span><br><span class="line">    mappend = (+)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Product</span> a = <span class="type">Product</span> a</span></span><br><span class="line">    <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Num</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">getProduct</span> :: <span class="type">Product</span> a -&gt; a</span><br><span class="line"><span class="title">getProduct</span> (<span class="type">Product</span> a) = a</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Monoid</span> (<span class="type">Product</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty  = <span class="type">Product</span> <span class="number">0</span></span><br><span class="line">    mappend = (*)</span><br></pre></td></tr></table></figure><blockquote><p>类型的定义方式：</p><p>data: ADT</p><p>newtype: 单构造器的零代价ADT</p><p>type: 类型别名</p></blockquote><p>在上述定义后，我们可以使用以下方式计算一个数列中所有元素的乘积：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lst</span> :: [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">lst</span> = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">23</span>,<span class="number">423</span>,<span class="number">99</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">prod</span> :: <span class="type">Integer</span></span><br><span class="line"><span class="title">prod</span> = getProduct . mappend . map <span class="type">Product</span> $ lst</span><br></pre></td></tr></table></figure><p>当然这个例子显得舍近求远，非常地蠢。但这个模式可以方便的说明<code>Monoid</code>的应用方式。</p><p>两个可以作为<code>Monoid</code>实例的类组成的<code>Pair</code>也可以作为<code>Monoid</code>的实例，如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Monoid</span> <span class="title">a</span>, <span class="type">Monoid</span> <span class="title">b</span>) =&gt; <span class="type">Monoid</span> (<span class="title">a</span>, <span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty  = (mempty, mempty)</span><br><span class="line">    (a,b) `mappend` (c,d) = (a `mappend` c, b `mappend` d)</span><br></pre></td></tr></table></figure><p>试图构造一个<code>Bool</code>类型的<code>Monoid</code>，如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Or</span> = <span class="type">Or</span> &#123;<span class="title">getOr</span> :: <span class="type">Bool</span>&#125;</span></span><br><span class="line">    <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Or</span> <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">Or</span> <span class="type">False</span> </span><br><span class="line">    <span class="type">Or</span> x `mappend` <span class="type">Or</span> y = <span class="type">Or</span> $ x || y</span><br></pre></td></tr></table></figure><p>这个定义确实没错，但是无法通过语法检查。原因是<code>No instance for (Semigroup Or)</code>。</p><h2 id="补充：半群（Semigroup）"><a href="#补充：半群（Semigroup）" class="headerlink" title="补充：半群（Semigroup）"></a>补充：半群（Semigroup）</h2><p>上面的报错信息意为<code>Or</code>类型不是<code>Semigroup</code>类型类的实例，而Semigroup是半群的意思。这是怎么回事呢？</p><p>我们知道，幺半群就是有单位元的半群，则半群定义为一个带有符合结合律的二元运算符<code>* : M * M -&gt; M</code>的集合。因此Haskell把幺半群的二元运算符部分抽象出来作为半群类型类，如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Semigroup</span> a <span class="keyword">where</span></span></span><br><span class="line">    (&lt;&gt;) :: a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure><p>而幺半群的真实定义则为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Semigroup</span> a =&gt; <span class="type">Monoid</span> a <span class="keyword">where</span></span></span><br><span class="line">    mempty  :: a</span><br><span class="line">    mappend :: a -&gt; a -&gt; a</span><br><span class="line">    mconcat :: foldr mappend mempty</span><br><span class="line">    </span><br><span class="line">(&lt;&gt;) <span class="type">Monoid</span> m =&gt; m -&gt; m -&gt; m</span><br><span class="line">(&lt;&gt;) = mappend</span><br></pre></td></tr></table></figure><p>关于<code>&lt;&gt;</code>与<code>mappend</code>的关系更准确的说法是，<code>mappend</code>是<code>&lt;&gt;</code>的别名。因而，<code>&lt;&gt;</code>才是主要定义，就是说一个类要成为<code>Monoid</code>的实例就必须也成为<code>Semigroup</code>的实例。则<code>Bool</code>类型的<code>Monoid</code>应定义为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Or</span> = <span class="type">Or</span> &#123;<span class="title">getOr</span> :: <span class="type">Bool</span>&#125;</span></span><br><span class="line">    <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> <span class="type">Or</span> <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">Or</span> x &lt;&gt; <span class="type">Or</span> y = <span class="type">Or</span> $ x || y</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Or</span> <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">Or</span> <span class="type">False</span> </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">And</span> = <span class="type">And</span> &#123;<span class="title">getAnd</span> :: <span class="type">Bool</span>&#125;</span></span><br><span class="line">    <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> <span class="type">And</span> <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">And</span> x &lt;&gt; <span class="type">And</span> y = <span class="type">And</span> $ x &amp;&amp; y</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">And</span> <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">And</span> <span class="type">True</span></span><br></pre></td></tr></table></figure><p>甚至可以实现函数类型的<code>Monoid</code>：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Dot</span> a = <span class="type">Dot</span> &#123;<span class="title">run</span> :: <span class="title">a</span> -&gt; <span class="title">a</span>&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> (<span class="type">Dot</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">Dot</span> x &lt;&gt; <span class="type">Dot</span> y = <span class="type">Dot</span> $ x . y</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> (<span class="type">Dot</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">Dot</span> id</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0x03 从零开始的Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell：理解惰性求值与运算符优先级</title>
      <link href="/zh/blog/2022/01/08/0033-Haskell:operator_and_lazy/"/>
      <url>/zh/blog/2022/01/08/0033-Haskell:operator_and_lazy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>做 <a class="link"   href="https://www.seas.upenn.edu/~cis194/spring13/hw/06-laziness.pdf" >CIS 194 HomeWork6<i class="fas fa-external-link-alt"></i></a>时遇到了各种思维方面的困难。试图通过梳理它们加深对运算符优先级和惰性求值的理解。</p></blockquote><span id="more"></span><h2 id="引言：Fibonacci数列"><a href="#引言：Fibonacci数列" class="headerlink" title="引言：Fibonacci数列"></a>引言：Fibonacci数列</h2><p>斐波那契数列，相信大家都很熟悉了，每个人刚接触递归与动态规划的思想时候都会看到它的身影。其定义为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fib(1) = 1</span><br><span class="line">fib(2) = 1</span><br><span class="line">fib(n) = fib(n - 1) + fib(n - 2), n &gt; 2</span><br></pre></td></tr></table></figure><p>这在Haskell中是很容易实现的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fib</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">fib</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fib</span> <span class="number">2</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fib</span> n = fib (n - <span class="number">1</span>) + fib (n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="fib函数的递推实现"><a href="#fib函数的递推实现" class="headerlink" title="fib函数的递推实现"></a>fib函数的递推实现</h2><p>不难看出，上面的实现非常自然，几乎与数学方式给出的定义一样。然而大家可能都知道，这种定义方式的计算效率是很低的，在过程式语言中可以引出DP思想：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fibs[n] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        fibs[i] = fibs[i - <span class="number">1</span>] + fibs[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibs[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的计算方法将可能重复使用的资源记录了下来，使用少量空间换取了大量的时间。并且也很符合人的直觉。可以拆解成两步：</p><ol><li>维护一个长度至少为n的数列。</li><li>取出数列中对应的元素。</li></ol><p>那么在Haskell这样的无副作用语言中如何实现对列表的维护呢？如果使用下面方式：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fibs</span> :: [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">fibs</span> = map fib [<span class="number">1.</span>.]</span><br></pre></td></tr></table></figure><p>则不仅无法使用这个列表记录已使用的计算，反而每一步都要耗费大量的计算资源。这里如果根据直觉实现递推，或许会实现出这样的东西：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fibs</span> :: [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">fibs</span> = map fib&#x27; [<span class="number">1.</span>.]</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">fib&#x27; <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">fib&#x27; <span class="number">2</span> = <span class="number">1</span></span><br><span class="line">fib&#x27; n = fibs!!(n - <span class="number">1</span>) + fibs!!(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>然而，这样会寻致计算<code>!!</code>的时候试图求出<code>fib</code>的值，因此会进入一个死循环。不可行。</p><p>那么我们在<a class="link"   href="https://www.seas.upenn.edu/~cis194/spring13/lectures/06-laziness.html" >Lecture 6<i class="fas fa-external-link-alt"></i></a>中见过的<code>Data.Array</code>可以完成这个任务吗？答案是不行，它仅仅是一个对列表的封装，本身不支持处理无限列表。且此处并不需要使用映射。</p><p>黔驴技穷了，上网搜索解法，发现可以使用<code>zipWith</code>实现如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fibs</span> :: [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">fibs</span> = <span class="number">1</span>:<span class="number">1</span>:zipWith (+) fibs (tail fibs)</span><br></pre></td></tr></table></figure><p>于是开始了我的迷惑之旅。</p><h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><p>对于<code>fibs = 1:1:zipWith (+) fibs (tail fibs)</code>这种形式的定义，我简直闻所未闻。定义中不仅出现了自身，甚至出现了对自身的嵌套运算。将上式转换为C++形式可以帮助我们快速发现蹊跷：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1:1:zipWith (+) fibs (tail fibs) == (:) (1) ((:) (1) (zipWith (+) fibs (tail fibs)))</span></span><br><span class="line"><span class="function">list <span class="title">cons</span><span class="params">(Num i, list tail)</span></span>;</span><br><span class="line"><span class="function">list <span class="title">zipWith</span><span class="params">(operation op, list a, list b)</span></span>;</span><br><span class="line"><span class="function">list <span class="title">tail</span><span class="params">(list l)</span></span>;</span><br><span class="line"><span class="function">list <span class="title">fibs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cons</span>(<span class="number">1</span>, <span class="built_in">cons</span>(<span class="number">1</span>, <span class="built_in">zipWith</span>(plus, <span class="built_in">fibs</span>(), <span class="built_in">tail</span>(<span class="built_in">fibs</span>()))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现一个很明显的问题，这个函数没有递归终止条件。而在C++这样的直接求值语言中，这会导致传参时无限递归，计算不出任何结果。然而对于惰性求值的Haskell而言，就不存在这个问题了，首先看看<code>zipWith</code>的定义：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zipWith</span> :: (a-&gt;b-&gt;c) -&gt; [a] -&gt; [b] -&gt; [c]</span><br><span class="line"><span class="title">zipWith</span> f = go</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    go [] _ = []</span><br><span class="line">    go _ [] = []</span><br><span class="line">    go (x:xs) (y:ys) = f x y : go xs ys</span><br></pre></td></tr></table></figure><p>由于这个函数没有用到如<code>!!</code>或<code>length</code>这类需要先将值计算出来的函数，符合惰性求值的作用条件，计算过程如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fibs</span> = <span class="number">1</span>:<span class="number">1</span>:zipWith (+) fibs (tail fibs)</span><br><span class="line"> == <span class="number">1</span>:<span class="number">1</span>:(go (<span class="number">1</span>: (<span class="number">1</span>:ys))</span><br><span class="line"> == <span class="number">1</span>:<span class="number">1</span>:((<span class="number">1</span> + <span class="number">1</span>) : xs : ys)</span><br><span class="line"> == <span class="number">1</span>:<span class="number">1</span>:((<span class="number">1</span> + <span class="number">1</span>) : tail fibs : tail (tail fibs))</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>可以总结出一条规律，要想使用惰性求值特性，就要使每一个计算步骤都不依赖完整的结果。</p><h2 id="谈谈运算符优先级"><a href="#谈谈运算符优先级" class="headerlink" title="谈谈运算符优先级"></a>谈谈运算符优先级</h2><ul><li>Why not <code>fib = 1:1:(zipWith (+) fibs (tail fibs))</code></li></ul><p>这里的答案是<code>:</code>运算符是<code>cons</code>函数的语法糖，而<code>[emelments]</code>又是<code>:</code>的语法糖，关系如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] == <span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>:[] == cons <span class="number">1</span> (cons <span class="number">2</span> (cons <span class="number">3</span> []))</span><br></pre></td></tr></table></figure><p>不难看出，为满足这个关系，<code>:</code>是一个右结合运算符。因此：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:<span class="number">1</span>:(zipWith (+) fibs (tail fibs))</span><br><span class="line">== <span class="number">1</span>:(<span class="number">1</span>:((zipWith (+) fibs (tail fibs))))</span><br><span class="line">== <span class="number">1</span>:(<span class="number">1</span>:(zipWith (+) fibs (tail fibs)))</span><br><span class="line">== <span class="number">1</span>:<span class="number">1</span>:zipWith (+) fibs (tail fibs)</span><br></pre></td></tr></table></figure><p>之所以可以将<code>zipWith (+) fibs (tail fibs)</code>看做一个整体，是因为前缀函数调用的优先级高于中缀函数。</p><p>而不可以将<code>zipWith (+) fibs (tail fibs)</code>写做<code>zipWith (+) fibs tail fibs</code>，则是因为前缀函数调用优先级相同，且从左向右开始分析。因此上式等价于：<code>(zipWith (+) fibs tail) fibs</code>。</p><ul><li>Why not <code>fib = 1:1:zipWith (+) fibs $ tail fibs</code></li></ul><p>根据<code>$</code>运算符的作用是“<em>省略之后的括号</em>”来理解，这样写是可行的，然而这个理解是错误的。<code>$</code>运算符真正的作用是，将<strong>前后两部分都括上括号</strong>。因此上式转换为前缀写法后，错误就显而易见了，如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">($) (<span class="number">1</span>:<span class="number">1</span>:zipWith (+) fibs) (tail fibs)</span><br><span class="line">($) (cons <span class="number">1</span> (cons <span class="number">1</span> (zipWith (+) fibs))) (tail fibs)</span><br></pre></td></tr></table></figure><p>值得一提的是<code>$</code>的函数原型：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">($) :: (a -&gt; b) -&gt; a -&gt; b</span><br><span class="line">($) = id</span><br></pre></td></tr></table></figure><p>即接受一个函数，然后返回该函数本身。唯一的作用就是用其极低的运算优先级来省略多余的括号。没错，是极低的优先级，这有违直觉。因为直觉上似乎是：<em>“<code>$</code>运算符以极高的运算优先级为它的左右两边加上了括号”</em>。然而我们不妨思考一下，括号的意义正是优先运算，为了让自己的左右都先于自己运算，它的优先级必然很低。（事实上<code>$</code>的运算优先级是最低的一级，参见后附优先级表。）</p><p>考虑以下例子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: a -&gt; b</span><br><span class="line"><span class="title">g</span> :: c -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="title">f</span> g x == (f g) x</span><br><span class="line"><span class="title">f</span> $ g x /= ((f $) g) x</span><br><span class="line"><span class="title">map</span> + [<span class="number">1</span>] /= map (+) [<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>为什么同样是占据高优先级函数的参数位置，中缀运算符不会被当作参数传递呢？因为当我们使用中缀函数时，实际上表达式会被当作等价的前缀形式来处理，即：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> $ g x == ($) (f) (g x) == ($ f) (g x) == f (g x) <span class="comment">-- 注意：当转换为前缀形式后，由于所有的函数都成为了前缀函数，不再有优先级一说。</span></span><br><span class="line"><span class="title">map</span> + [<span class="number">1</span>] == (+) (map) ([<span class="number">1</span>]) == (+ map) ([<span class="number">1</span>]) <span class="comment">-- 错误：函数(+ map)参数类型与[]不匹配。</span></span><br></pre></td></tr></table></figure><p>上例也可看出，所谓的优先级只在中缀表达式到前缀表达式的转换中有效，即：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(f.g) x == ((.) f g) (x)</span><br><span class="line"><span class="title">f</span>.g $ x == ($) (f.g) (x) == ($) ((.) f g) (x)</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> * <span class="number">3</span> + <span class="number">4</span> </span><br><span class="line">  == (+) (<span class="number">1</span> + <span class="number">2</span> * <span class="number">3</span>) + (<span class="number">4</span>) </span><br><span class="line">  == (+) ((+) (<span class="number">1</span>) (<span class="number">2</span> * <span class="number">3</span>)) (<span class="number">4</span>) </span><br><span class="line">  == (+) ((+) (<span class="number">1</span>) ((*) <span class="number">2</span> <span class="number">3</span>)) <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这里又可看出一个有趣的规律：优先级不同的运算符先转换较低级的，同级的运算符则根据结合律来决定顺序（转换顺序与结合顺序相反）。即后运算的先转换。</p><p>这种将中缀函数转换成前缀的方式可以帮助我们理解两个内容：</p><ol><li>运算符优先级。</li><li>引用中缀函数时要加上括号。</li></ol><h2 id="附：运算符优先级表"><a href="#附：运算符优先级表" class="headerlink" title="附：运算符优先级表"></a>附：运算符优先级表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--------+----------------------+-----------------------+-------------------+</span><br><span class="line">| Prec-  |   Left associative   |    Non-associative    | Right associative |</span><br><span class="line">| edence |      operators       |       operators       |    operators      |</span><br><span class="line">+--------+----------------------+-----------------------+-------------------+</span><br><span class="line">| 9      | !!                   |                       | .                 |</span><br><span class="line">| 8      |                      |                       | ^, ^^, **         |</span><br><span class="line">| 7      | *, /, `div`,         |                       |                   |</span><br><span class="line">|        | `mod`, `rem`, `quot` |                       |                   |</span><br><span class="line">| 6      | +, -                 |                       |                   |</span><br><span class="line">| 5      |                      |                       | :, ++             |</span><br><span class="line">| 4      |                      | ==, /=, &lt;, &lt;=, &gt;, &gt;=, |                   |</span><br><span class="line">|        |                      | `elem`, `notElem`     |                   |</span><br><span class="line">| 3      |                      |                       | &amp;&amp;                |</span><br><span class="line">| 2      |                      |                       | ||                |</span><br><span class="line">| 1      | &gt;&gt;, &gt;&gt;=              |                       |                   |</span><br><span class="line">| 0      |                      |                       | $, $!, `seq`      |</span><br><span class="line">+--------+----------------------+-----------------------+-------------------+</span><br></pre></td></tr></table></figure><ul><li>函数调用拥有更高的优先级，可以认为其优先级是10。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 0x03 从零开始的Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APUE学习笔记01——UNIX标准与限制</title>
      <link href="/zh/blog/2021/12/11/0032-APUE_chapter2/"/>
      <url>/zh/blog/2021/12/11/0032-APUE_chapter2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本章主要介绍了UNIX的标准与限制，说明了三个标准范围ISO C、POSIX的SUS，并且对三个运行时限制函数sysconf、pathconf和fpathconf进行了介绍。</p></blockquote><span id="more"></span><p>UNIX系统中存在三个标准范围与一些限制。为了写出良好的可移植代码，了解这些标准是非常有必要的。</p><h2 id="标准范围"><a href="#标准范围" class="headerlink" title="标准范围"></a>标准范围</h2><h3 id="ISO-C"><a href="#ISO-C" class="headerlink" title="ISO C"></a>ISO C</h3><p>所有Unix系统都提供对ISO C标准的完整支持。包括以下头文件：</p><table><thead><tr><th>头文件</th><th>说明</th></tr></thead><tbody><tr><td>assert.h</td><td>验证程序断言</td></tr><tr><td>complex.h</td><td>复数算术运算支持</td></tr><tr><td>ctype.h</td><td>字符分类和映射支持</td></tr><tr><td>errno.h</td><td>出错码</td></tr><tr><td>fenv.h</td><td>浮点环境</td></tr><tr><td>float.h</td><td>浮点常量及特性</td></tr><tr><td>inttypes.h</td><td>整型格式变换</td></tr><tr><td>iso646.h</td><td>赋值、关系及一元操作符宏</td></tr><tr><td>limits.h</td><td>实现常量</td></tr><tr><td>locale.h</td><td>本地化类别及相关定义</td></tr><tr><td>math.h</td><td>数学函数、类型声明及常量</td></tr><tr><td>setjmp.h</td><td>非局部goto</td></tr><tr><td>signal.h</td><td>信号</td></tr><tr><td>stdarg.h</td><td>可变长度参数表</td></tr><tr><td>stdbool.h</td><td>布尔类型和值</td></tr><tr><td>stddef.h</td><td>标准定义</td></tr><tr><td>stdint.h</td><td>整型</td></tr><tr><td>stdio.h</td><td>标准I/O库</td></tr><tr><td>stdlib.h</td><td>实用函数</td></tr><tr><td>string.h</td><td>字符串操作</td></tr><tr><td>tgmath.h</td><td>通用类型数学宏</td></tr><tr><td>time.h</td><td>时间和日期</td></tr><tr><td>wchar.h</td><td>扩充的多字节和宽字符支持</td></tr><tr><td>wctype.h</td><td>宽字符分类和映射支持</td></tr></tbody></table><h3 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h3><p>可移植操作系统接口，最初是IEEE POSIX。在1988年由ISO标准化，称为POSIX.1，这个版本被广泛支持。包括三组头文件和一组可选接口组。</p><p>POSIX必需头文件：</p><table><thead><tr><th>头文件</th><th>说明</th></tr></thead><tbody><tr><td>aio.h</td><td>异步I/O</td></tr><tr><td>cpio.h</td><td>cpio归档值</td></tr><tr><td>dirent.h</td><td>目录项</td></tr><tr><td>dlfcn.h</td><td>动态链接</td></tr><tr><td>fcntl.h</td><td>文件控制</td></tr><tr><td>fnmatch.h</td><td>文件名匹配类型</td></tr><tr><td>glob.h</td><td>路径名模式匹配与生成</td></tr><tr><td>grp.h</td><td>组文件</td></tr><tr><td>iconv.h</td><td>代码集变换实用程序</td></tr><tr><td>langinfo.h</td><td>语言信息变量</td></tr><tr><td>monetary.h</td><td>货币类型与函数</td></tr><tr><td>netdb.h</td><td>网络数据库操作</td></tr><tr><td>nl_types.h</td><td>消息类</td></tr><tr><td>poll.h</td><td>投票函数</td></tr><tr><td>pthread.h</td><td>线程</td></tr><tr><td>pwd.h</td><td>口令文件</td></tr><tr><td>regex.h</td><td>正则表达式</td></tr><tr><td>sched.h</td><td>执行调度</td></tr><tr><td>semaphore.h</td><td>信号量</td></tr><tr><td>strings.h</td><td>字符串操作</td></tr><tr><td>tar.h</td><td>tar归档值</td></tr><tr><td>termios.h</td><td>终端I/O</td></tr><tr><td>unistd.h</td><td>符号常量</td></tr><tr><td>wordexp.h</td><td>字扩充类型</td></tr><tr><td>arpa/inet.h</td><td>Internet定义</td></tr><tr><td>net/if.h</td><td>socket本地接口</td></tr><tr><td>netinet/in.h</td><td>Internet地址族</td></tr><tr><td>netinet/tcp.h</td><td>TCP协议定义</td></tr><tr><td>sys/mman.h</td><td>存储管理声明</td></tr><tr><td>sys/select.h</td><td>select函数</td></tr><tr><td>sys/socket.h</td><td>socket接口</td></tr><tr><td>sys/stat.h</td><td>文件状态</td></tr><tr><td>sys/statvfs.h</td><td>文件系统信息</td></tr><tr><td>sys/times.h</td><td>进程时间</td></tr><tr><td>sys/types.h</td><td>基本系统数据类型</td></tr><tr><td>sys/un.h</td><td>UNIX域socket定义</td></tr><tr><td>sys/utsname.h</td><td>系统名</td></tr><tr><td>sys/wait.h</td><td>进程控制</td></tr></tbody></table><p>XSI可选头文件：</p><table><thead><tr><th>头文件</th><th>说明</th></tr></thead><tbody><tr><td>fmtmsg.h</td><td>消息显示结构</td></tr><tr><td>ftw.h</td><td>文件树漫游</td></tr><tr><td>libgen.h</td><td>路径名管理函数</td></tr><tr><td>ndbm.h</td><td>数据库操作</td></tr><tr><td>search.h</td><td>搜索表</td></tr><tr><td>syslog.h</td><td>系统出错日志记录</td></tr><tr><td>utmpx.h</td><td>用户账户数据库</td></tr><tr><td>sys/ipc.h</td><td>IPC</td></tr><tr><td>sys/msg.h</td><td>XSI消息队列</td></tr><tr><td>sys/resource.h</td><td>资源操作</td></tr><tr><td>sys/sem.h</td><td>XSI信号量</td></tr><tr><td>sys/shm.h</td><td>XSI共享存储</td></tr><tr><td>sys/time.h</td><td>时间类型</td></tr><tr><td>sys/uio.h</td><td>矢量I/O操作</td></tr></tbody></table><p>可选头文件：</p><table><thead><tr><th>头文件</th><th>说明</th></tr></thead><tbody><tr><td>mqueue.h</td><td>消息队列</td></tr><tr><td>spawn.h</td><td>实时spawn接口</td></tr></tbody></table><p>可选接口组和选项码：</p><table><thead><tr><th>选项码</th><th>符号常量</th><th>说明</th></tr></thead><tbody><tr><td>ADV</td><td><code>_POSIX_ADVISORY_INFO</code></td><td>建议性信息</td></tr><tr><td>CPT</td><td><code>_POSIX_CPUTIME</code></td><td>进程CPU时间时钟</td></tr><tr><td><strong>FSC</strong></td><td><code>_POSIX_FSYNC</code></td><td>文件同步</td></tr><tr><td>IP6</td><td><code>_POSIX_IPV6</code></td><td>IPv6接口</td></tr><tr><td>ML</td><td><code>_POSIX_MEMLOCK</code></td><td>进程存储区加锁（实时）</td></tr><tr><td>MLR</td><td><code>_POSIX_MEMLOCK_RANGE</code></td><td>存储区域加锁（实时）</td></tr><tr><td>MON</td><td><code>_POSIX_MONOTONIC_CLOCK</code></td><td>单调时钟（实时）</td></tr><tr><td>MSG</td><td><code>_POSIX_MSEEAGE_PASSING</code></td><td>消息传送（实时）</td></tr><tr><td>MX</td><td><code>__STDC_IEC_559__</code></td><td>IEC 60559 浮点选项</td></tr><tr><td>PIO</td><td><code>_POSIX_PRIORITIZED_IO</code></td><td>优先输入和输出</td></tr><tr><td>PS</td><td><code>_POSIX_PRIORITIZED_SCHEDULING</code></td><td>进程调度（实时）</td></tr><tr><td>RPI</td><td><code>_POSIX_THREAD_REBUST_PRIO_INHERIT</code></td><td>健壮的互斥量优先权继承（实时）</td></tr><tr><td>RPP</td><td><code>_POSIX_THREAD_REBUST_PRIO_PROTECT</code></td><td>健壮的互斥量优先权保护（实时）</td></tr><tr><td>RS</td><td><code>_POSIX_RAW_SOCKETS</code></td><td>原始Socket</td></tr><tr><td>SHM</td><td><code>_POSIX_SHARED_MEMORY_OBJECTS</code></td><td>共享存储对象</td></tr><tr><td>SIO</td><td><code>_POSIX_SYNCHRONIZED_IO</code></td><td>同步输入和输出</td></tr><tr><td>SPN</td><td><code>_POSIX_SPAWN</code></td><td>产生</td></tr><tr><td>SS</td><td><code>_POSIX_SPORADIC_SERVER</code></td><td>进程阵发性服务器</td></tr><tr><td>TCT</td><td><code>_POSIX_THREAD_CPUTIME</code></td><td>线程CPU时间时钟</td></tr><tr><td>TPI</td><td><code>_POSIX_THREAD_PRIO_INHERIT</code></td><td>非健壮的互斥量优先权继承</td></tr><tr><td>TPP</td><td><code>_POSIX_THREAD_PRIO_PROTECT</code></td><td>非健壮的互斥量优先权保护</td></tr><tr><td>TPS</td><td><code>_POSIX_THREAD_PRIORITY_SCHEDULING</code></td><td>线程执行调度</td></tr><tr><td><strong>TSA</strong></td><td><code>_POSIX_THREAD_ATTR_STACKADDR</code></td><td>线程栈地址属性</td></tr><tr><td><strong>TSH</strong></td><td><code>_POSIX_THREAD_PROCESS_SHARED</code></td><td>线程进程共享同步</td></tr><tr><td>TSP</td><td><code>_POSIX_THREAD_SPORADIC_SERVER</code></td><td>线程阵发性服务器</td></tr><tr><td><strong>TSS</strong></td><td><code>_POSIX_THREAD_ATTR_STACKSIZE</code></td><td>线程栈长度属性</td></tr><tr><td>TYM</td><td><code>_POSIX_TYPED_MEMORY_OBJECTS</code></td><td>类型存储对象</td></tr><tr><td><strong>XSI</strong></td><td><code>_XOPEN_UNIX</code></td><td>X/Open扩充接口</td></tr></tbody></table><h3 id="SUS"><a href="#SUS" class="headerlink" title="SUS"></a>SUS</h3><p>单一UNIX规范，是POSIX.1标准的一个超集，定义了一些附加接口扩展了POSIX.1。</p><p>SUS标准中，必须支持POSIX可选接口组中加粗的5组。同时一个系统必须满足此要求才能称为UNIX系统。</p><p>有些标准在SUS中也是可选的，包括：</p><ul><li>加密：由符号常量<code>_XOPEN_CRYPE</code>标记。</li><li>实时：由符号常量<code>_XOPEN_REALTIME</code>标记</li><li>高级实时。</li><li>实时线程：由符号常量<code>_XOPEN_REALTIME_THREADS</code>标记</li><li>高级实时线程。</li></ul><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>要使得程序具备良好的可移植性，就需要一种方法来获取系统的各种限制量。主要分为：</p><ol><li>编译时限制，如整型的最大值。</li><li>运行时限制，如文件名最大长度。</li></ol><p>编译时限制可以定义在头文件里，而运行时限制往往需要运行特定的函数取得。主要包括ISO C 限制、POSIX 限制和XSI限制。</p><h3 id="ISO-C限制"><a href="#ISO-C限制" class="headerlink" title="ISO C限制"></a>ISO C限制</h3><p>ISO C的所有编译时限制都定义在文件&lt;limits.h&gt;中。这些常量在一个特定的系统中是不会改变的。</p><table><thead><tr><th>名称</th><th>说明</th><th>可接受的最小值</th><th>典型值</th></tr></thead><tbody><tr><td><code>CHAR_BIT</code></td><td>char的位数</td><td>8</td><td>8</td></tr><tr><td><code>CHAR_MAX</code></td><td>char的最大值</td><td>取决于系统使用的字符是否带类型</td><td>127</td></tr><tr><td><code>CHAR_MIN</code></td><td>char的最小值</td><td>取决于系统使用的字符是否带类型</td><td>-128</td></tr><tr><td><code>SCHAR_MAX</code></td><td>signed char的最大值</td><td>127</td><td>127</td></tr><tr><td><code>SCHAR_MIN</code></td><td>signed char的最小值</td><td>-127</td><td>-127</td></tr><tr><td><code>UCHAR_MAX</code></td><td>unsigned char的最大值</td><td>255</td><td>255</td></tr><tr><td><code>INT_MAX</code></td><td>int的最大值</td><td>32767</td><td>2147483647</td></tr><tr><td><code>INT_MIN</code></td><td>int的最小值</td><td>-32767</td><td>-2147483647</td></tr><tr><td><code>UINT_MAX</code></td><td>unsigned int的最大值</td><td>65535</td><td>4294967295</td></tr><tr><td><code>SHRT_MAX</code></td><td>short的最大值</td><td>32767</td><td>32767</td></tr><tr><td><code>SHRT_MIN</code></td><td>short的最小值</td><td>-32767</td><td>-32767</td></tr><tr><td><code>USHRT_MAX</code></td><td>unsigned short的最大值</td><td>65535</td><td>65535</td></tr><tr><td><code>LONG_MAX</code></td><td>long的最大值</td><td>2147483647</td><td>2147483647</td></tr><tr><td><code>LONG_MIN</code></td><td>long的最小值</td><td>-2147483647</td><td>-2147483647</td></tr><tr><td><code>ULONG_MAX</code></td><td>unsigned long的最大值</td><td>4294967295</td><td>4294967295</td></tr><tr><td><code>LLONG_MAX</code></td><td>long long的最大值</td><td>9223372036854775807</td><td>9223372036854775807</td></tr><tr><td><code>LLONG_MIN</code></td><td>long long的最小值</td><td>-9223372036854775807</td><td>-9223372036854775807</td></tr><tr><td><code>ULLONG_MAX</code></td><td>unsigned long long的最大值</td><td>18446744073709551615</td><td>18446744073709551615</td></tr><tr><td><code>MB_LEN_MAX</code></td><td>一个多字节字符常量中的最大字符数</td><td>1</td><td>6</td></tr></tbody></table><p>表中典型值为主流32位系统的限制值，但在主流64位系统中也仅存在一个差别：long的长度为64bit。</p><p>除此之外，关于浮点数的编译时限制定义在文件&lt;float.h&gt;中，若需要大量使用浮点数时应仔细查看该文件。</p><p>另外还有一些常量定义在文件&lt;stdio.h&gt;中，<code>FOPEN_MAX</code>保证可同时打开标准I/P流的最小个数。ISO C规定其最小值为8，POSIX中的<code>STREAM_MAX</code>若有定义则应与<code>FOPEN_MAX</code>具有相同的值。<code>TMP_MAX</code>是由tmpnam函数产生的唯一文件名的最大个数，之后的章节中会对其进行说明。<code>FILENAME_MAX</code>是文件名的最大长度，我们应避免使用这个常量，因为POSIX提供了更好的替代常量(<code>NAME_MAX</code>和<code>PATH_MAX</code>)。</p><h3 id="POSIX限制"><a href="#POSIX限制" class="headerlink" title="POSIX限制"></a>POSIX限制</h3><p>POSIX定义了很多涉及操作系统实现限制的常量。我们只关心其中与基本POSIX接口有关的部分，可以分为下列7类。</p><ol><li><p>数值限制</p><p>基中一部分是对ISO C标准进行的扩充，包括<code>INT_MAX</code>的最小值为2147483647，<code>INT_MIN</code>为-2147483647，<code>UINT_MAX</code>为4294967295，<code>CHAR_BIT</code>必须是8，<code>SCHAR_MIN</code>必须是-128，<code>SCHAR_MAX</code>必须是127，<code>UCHAR_MAX</code>必须是255。</p><p>另外还包括<code>LONG_BIT</code>、<code>SSIZE_MAX</code>的<code>WORD_BIT</code>。</p></li><li><p>最小值，定义在&lt;limits.h&gt;中</p><table><thead><tr><th>名称</th><th>说明</th><th>值</th></tr></thead><tbody><tr><td><code>_POSIX_ARG_MAX</code></td><td>exec函数的参数长度</td><td>4096</td></tr><tr><td><code>_POSIX_CHILD_MAX</code></td><td>每个实际用户ID的子进程数</td><td>25</td></tr><tr><td><code>_POSIX_DELAYTIMER_MAX</code></td><td>定时器最大超限运行次数</td><td>32</td></tr><tr><td><code>_POSIX_HOST_NAME_MAX</code></td><td>gethostname函数返回的主机名长度</td><td>255</td></tr><tr><td><code>_POSIX_LINK_MAX</code></td><td>至一个文件的链接数</td><td>8</td></tr><tr><td><code>_POSIX_LOGIN_NAME_MAX</code></td><td>登录名长度</td><td>9</td></tr><tr><td><code>_POSIX_MAX_CANON</code></td><td>终端规范输入队列的字节数</td><td>255</td></tr><tr><td><code>_POSIX_MAX_INPUT</code></td><td>终端输入队列的可用空间</td><td>255</td></tr><tr><td><code>_POSIX_NAME_MAX</code></td><td>文件名中的字节数，不包括终止null字符</td><td>14</td></tr><tr><td><code>_POSIX_NGROUPS_MAX</code></td><td>每个进程同时添加的组ID数</td><td>8</td></tr><tr><td><code>_POSIX_OPEN_MAX</code></td><td>每个进程的打开文件数</td><td>20</td></tr><tr><td><code>_POSIX_PATH_MAX</code></td><td>路径名中的字节数，包括终止null字节</td><td>256</td></tr><tr><td><code>_POSIX_PIPE_BUF</code></td><td>能原子地写到一个管道中的字节数</td><td>512</td></tr><tr><td><code>_POSIX_RE_DUP_MAX</code></td><td>当使用间隔表示法时，regexec和regcomp函数允许的基本正则表达式重复发生次数</td><td>255</td></tr><tr><td><code>_POSIX_RTSIG_MAX</code></td><td>为应用预留的实时信号编号个数</td><td>8</td></tr><tr><td><code>_POSIX_SEM_NSEMS_MAX</code></td><td>一个进程可以同时使用的信号量个数</td><td>256</td></tr><tr><td><code>_POSIX_SEM_VALUE_MAX</code></td><td>信号量可持有的值</td><td>32767</td></tr><tr><td><code>_POSIX_SIGQUEUE_MAX</code></td><td>一个进程可发送和挂起的排队信号的个数</td><td>32</td></tr><tr><td><code>_POSIX_SSIZE_MAX</code></td><td>能存在ssize_t对象中的值</td><td>32767</td></tr><tr><td><code>_POSIX_STREAM_MAX</code></td><td>一个进程能同时打开的标准I/O流数</td><td>8</td></tr><tr><td><code>_POSIX_SYMLINK_MAX</code></td><td>符号链接中的字节数</td><td>255</td></tr><tr><td><code>_POSIX_SYMLOOP_MAX</code></td><td>在解析路径名时，可遍历的符号链接数</td><td>8</td></tr><tr><td><code>_POSIX_TIMER_MAX</code></td><td>每个进程的定时器数目</td><td>32</td></tr><tr><td><code>_POSIX_TTY_NAME_MAX</code></td><td>终端设备名长度，包括终止null字节</td><td>9</td></tr><tr><td><code>_POSIX_TZNAME_MAX</code></td><td>时区名字节数</td><td>6</td></tr></tbody></table><p>这些不变值的名字里虽然都有个max，但称为最小值，因为这是一个符合POSIX标准的系统至少应该提供的值。某些不变值在实际应用中太小了。例如大多数UNIX系统中，每个进程可打开的文件数远大于20。另外<code>_POSIX_PATH_MAX</code>的最小限制值为255，也太小了，实际使用中可能会超过这个值。</p></li><li><p>最大值：<code>_POSIX_CLOCKRES_MIN</code>。</p></li><li><p>运行时可以增加的值：<code>CHAR_CLASS_NAME_MAX</code>、<code>COLL_WEIGHTS_MAX</code>、<code>LINE_MAX</code>、<code>NGROUPS_MAX</code>的<code>RE_DUP_MAX</code>。</p></li><li><p>运行时不变值，定义在&lt;limits.h&gt;中</p><table><thead><tr><th>名称</th><th>说明</th><th>最小可接受值</th></tr></thead><tbody><tr><td><code>ARG_MAX</code></td><td>exec函数族的参数最大长度</td><td><code>_POSIX_ARG_MAX</code></td></tr><tr><td><code>ATEXIT_MAX</code></td><td>可用atexit函数登记的最大函数个数</td><td>32</td></tr><tr><td><code>CHILD_MAX</code></td><td>每个实际用户ID的子进程最大个数</td><td><code>_POSIX_CHILD_MAX</code></td></tr><tr><td><code>DELAYTIMER_MAX</code></td><td>定时器最大超限运行次数</td><td><code>_POSIX_DELAYTIMER_MAX</code></td></tr><tr><td><code>HOST_NAME_MAX</code></td><td>gethostname返回的主机名长度</td><td><code>_POSIX_HOST_NAME_MAX</code></td></tr><tr><td><code>LOGIN_NAME_MAX</code></td><td>登录名最大长度</td><td><code>_POSIX_LOGIN_NAME_MAX</code></td></tr><tr><td><code>OPEN_MAX</code></td><td>赋予新建文件描述符的最大值+1</td><td><code>_POSIX_OPEN_MAX</code></td></tr><tr><td><code>PAGESIZE</code></td><td>系统内存页大小（以字节为单位）</td><td>1</td></tr><tr><td><code>RTSIG_MAX</code></td><td>为应用程序预留的实时信号的最大个数</td><td><code>_POSIX_RTSIG_MAX</code></td></tr><tr><td><code>SEM_NSEMS_MAX</code></td><td>一个进程可使用的信号量最大个数</td><td><code>_POSIX_SEM_NSEMS_MAX</code></td></tr><tr><td><code>SEM_VALUE_MAX</code></td><td>信号量的最大值</td><td><code>_POSIX_SEM_VALUE_MAX</code></td></tr><tr><td><code>SIGQUEUE_MAX</code></td><td>一个进程可排队信号的最大个数</td><td><code>_POSIX_SIGQUEUE_MAX</code></td></tr><tr><td><code>STREAM_MAX</code></td><td>一个进程一次可打开的标准I/O流的最大个数</td><td><code>_POSIX_STREAM_MAX</code></td></tr><tr><td><code>SYMLOOP_MAX</code></td><td>路径解析过程中可访问的符号链接数</td><td><code>_POSIX_SYMLOOP_MAX</code></td></tr><tr><td><code>TIMER_MAX</code></td><td>一个进程的定时器最大个数</td><td><code>_POSIX_TIMER_MAX</code></td></tr><tr><td><code>TTY_NAME_MAX</code></td><td>终端设备名长度，其中包括终止的null字节</td><td><code>_POSIX_TTY_NAME_MAX</code></td></tr><tr><td><code>TZNAME_MAX</code></td><td>时区名的字节数</td><td><code>_POSIX_TZNAME_MAX</code></td></tr></tbody></table></li><li><p>其他不变值：<code>NL_ARGMAX</code>、<code>NL_MAGMAX</code>、<code>COLL_WEIGHTS_MAX</code>、<code>LINE_MAX</code>、<code>NGROUPS_MAX</code>和<code>RE_DUP_MAX</code>。</p></li><li><p>路径名可变值：<code>FILESIZEBITS</code>、<code>LINK_MAX</code>、<code>MAX_CANON</code>、<code>MAX_INPUT</code>、<code>NAME_MAX</code>、<code>PATH_MAX</code>、<code>PIPE_BUF</code>的<code>SYMLINK_MAX</code>。</p></li></ol><h3 id="XSI限制"><a href="#XSI限制" class="headerlink" title="XSI限制"></a>XSI限制</h3><p>XSI定义了两类常量：</p><ol><li><p>最小值，定义在&lt;limits.h&gt;中：</p><table><thead><tr><th>名称</th><th>说明</th><th>最小可接受值</th><th>典型值</th></tr></thead><tbody><tr><td><code>NL_LANGMAX</code></td><td>在LANG环境变量中最大字节数</td><td>14</td><td>14</td></tr><tr><td><code>NZERO</code></td><td>默认进程优先级</td><td>20</td><td>20</td></tr><tr><td><code>_XOPEN_IOV_MAX</code></td><td>readv在writev可使用的最多iovec结构个数</td><td>16</td><td>16</td></tr><tr><td><code>_XOPEN_NAME_MAX</code></td><td>文件名中的字节数</td><td>255</td><td>255</td></tr><tr><td><code>_XOPEN_PATH_MAX</code></td><td>路径名中的字节数</td><td>1024</td><td>1024</td></tr></tbody></table><p>关于文件名和路径名的两个常量值是SUS为了弥补POSIX中定义的最小值大小（这可能是考虑了嵌入式POSIX设备）而做的弥补。</p></li><li><p>运行时不变值（未必真的不变）：<code>IOV_MAX</code>和<code>PAGE_SIZE</code>。</p></li></ol><h3 id="三个运行时限制相关函数"><a href="#三个运行时限制相关函数" class="headerlink" title="三个运行时限制相关函数"></a>三个运行时限制相关函数</h3><p>之前提到的编译时限制可以在相关头文件中获得，而运行时变量则需要在运行时使用这三个函数之一获取，分别是：<code>sysconf</code>、<code>pathconf</code>和<code>fpathconf</code>。这三个函数都定义在&lt;unistd.h&gt;中，函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sysconf</span><span class="params">(<span class="keyword">int</span> name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pathconf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> name)</span></span>;</span><br></pre></td></tr></table></figure><p>对于这三个函数，都使用一个name参数指定要查询的限制，其中：</p><ul><li>如果name参数并不是一个合适的常量，则返回-1，并将errno置为<code>EINVAL</code>。</li><li>如果要返回的值是不确定的，也通过返回-1来体现，不过此时errno不会改变。</li><li>其它情况下返回name参数对应的值。</li></ul><p>其中sysconf用于获取系统限制，用以<code>_SC_</code>开头的常量作为标识运行时限制的name参数，具体参数列表如下：</p><table><thead><tr><th>限制名</th><th>说明</th><th>name参数</th></tr></thead><tbody><tr><td><code>ARG_MAX</code></td><td>exec函数的参数最大长度</td><td><code>_SC_ARG_MAX</code></td></tr><tr><td><code>ATEXIT_MAX</code></td><td>可用atexit函数登记的最大函数个数</td><td><code>_SC_ATEXIT_MAX</code></td></tr><tr><td><code>CHILD_MAX</code></td><td>每个实际用户ID的最大进程数</td><td><code>_SC_CHILD_MAX</code></td></tr><tr><td>clock ticks / second</td><td>每秒时钟tick数</td><td><code>_SC_CLK_TCK</code></td></tr><tr><td><code>COLL_WEIGHTS_MAX</code></td><td>在本地定义文件中可以赋予LC_COLLATE顺序关键字项的最大权重数</td><td><code>_SC_COLL_WEIGHTS_MAX</code></td></tr><tr><td><code>DELAYTIMER_MAX</code></td><td>定时器最大超限运行次数</td><td><code>_SC_DELAYTIMER_MAX</code></td></tr><tr><td><code>HOST_NAME_MAX</code></td><td>gethostname函数返回的主机名最大长度</td><td><code>_SC_HOST_NAME_MAX</code></td></tr><tr><td><code>IOV_MAX</code></td><td>readv或writev函数可以使用最多的iovec结构的个数</td><td><code>_SC_IOV_MAX</code></td></tr><tr><td><code>LINE_MAX</code></td><td>实用程序输入行的最大长度</td><td><code>_SC_LINE_MAX</code></td></tr><tr><td><code>LOGIN_NAME_MAX</code></td><td>登录名的最大长度</td><td><code>_SC_LOGIN_NAME_MAX</code></td></tr><tr><td><code>NGROUPS_MAX</code></td><td>每个进程同时添加的最大进程组ID数</td><td><code>_SC_NGROUPS_MAX</code></td></tr><tr><td><code>OPEN_MAX</code></td><td>每个进程最大打开文件数</td><td><code>_SC_OPEN_MAX</code></td></tr><tr><td><code>PAGESIZE</code></td><td>系统存储页最大长度</td><td><code>_SC_PAGESIZE</code></td></tr><tr><td><code>PAGE_SIZE</code></td><td>系统存储页最大长度</td><td><code>_SC_PAGE_SIZE</code></td></tr><tr><td><code>RE_DUP_MAX</code></td><td>当使用间隔表示法时，函数regexec和regcomp允许的基本正则表达式重复发生次数</td><td><code>_SC_RE_DUP_MAX</code></td></tr><tr><td><code>RTSIG_MAX</code></td><td>为应用程序预留的实时信号的最大个数</td><td><code>_SC_RTSIG_MAX</code></td></tr><tr><td><code>SEM_NSEMS_MAX</code></td><td>一个进程可使用的信号量的最大个数</td><td><code>_SC_SEM_NSEMS_MAX</code></td></tr><tr><td><code>SEM_VALUE_MAX</code></td><td>信号量的最大值</td><td><code>_SC_SEM_VALUE_MAX</code></td></tr><tr><td><code>SIGQUEUE_MAX</code></td><td>一个进程可排除信号的最大个数</td><td><code>_SC_SIGQUEUE_MAX</code></td></tr><tr><td><code>STREAM_MAX</code></td><td>一个SC_STREAM_MAX进程在任意给定时刻标准I/O流的最大个数。如果定义，必须与FOPEN_MAX有相同的值。</td><td><code>_SC_STREAM_MAX</code></td></tr><tr><td><code>SYMLOOP_MAX</code></td><td>解析路径名时，可遍历的符号链接数。</td><td><code>_SC_SYMLOOP_MAX</code></td></tr><tr><td><code>TIMER_MAX</code></td><td>每个进程的最大定时器个数。</td><td><code>_SC_TIMER_MAX</code></td></tr><tr><td><code>TTY_NAME_MAX</code></td><td>终端设备名长度，包括终止null字节。</td><td><code>_SC_TTY_NAME_MAX</code></td></tr><tr><td><code>TZNAME_MAX</code></td><td>时区名中的最大字节数</td><td><code>_SC_TZNAME_MAX</code></td></tr></tbody></table><p>而pathconf和fpathconf用以标识与路径相关的限制，它们的差别是前者使用路径作为参数，而后者使用一个文件描述符。它们都使用以<code>_PC_</code>开头的常量来表示name值，如下：</p><table><thead><tr><th>限制名</th><th>说明</th><th>name参数</th></tr></thead><tbody><tr><td><code>FILESIZEBITS</code></td><td>以带符号整型值表示在指定目录中允许的普通文件最大长度所需的最小位数</td><td><code>_PC_FILESIZEBITS</code></td></tr><tr><td><code>LINK_MAX</code></td><td>文件链接计数的最大值</td><td><code>_PC_LINK_MAX</code></td></tr><tr><td><code>MAX_CANON</code></td><td>终端规范输入队列的最大字节数</td><td><code>_PC_MAX_CANON</code></td></tr><tr><td><code>MAX_INPUT</code></td><td>终端输入队列可用空间的字节数</td><td><code>_PC_MAX_INPUT</code></td></tr><tr><td><code>NAME_MAX</code></td><td>文件名的最大字节数</td><td><code>_PC_NAME_MAX</code></td></tr><tr><td><code>PATH_MAX</code></td><td>相对路径名的最大字节数，包括终止null字节</td><td><code>_PC_PATH_BUF</code></td></tr><tr><td><code>PIPE_BUF</code></td><td>能原子地写到管道的最大字节数</td><td><code>_PC_PIPE_BUF</code></td></tr><tr><td><code>_POSIX_TIMESTAMP_RESOLUTION</code></td><td>文件时间戳的纳秒精度</td><td><code>_PC_TIMESTAMP_RESOLUTION</code></td></tr><tr><td><code>SYMLINK_MAX</code></td><td>符号链接的字节数</td><td><code>_PC_SYMLINK_MAX</code></td></tr></tbody></table><p>其中：</p><ul><li><p><code>_PC_MAX_CANON</code>和<code>_PC_MAX_INPUT</code>引用的文件必须是终端文件。</p></li><li><p><code>_PC_LINK_MAX</code>和<code>_PC_TIMESTAMP_RESOLUTION</code>引用的文件可以是文件或目录，如果是目录则返回值作用与目录本身，而不用于目录的文件名项。</p></li><li><p><code>_PC_FILESIZEBITS</code>的<code>_PC_NAME_MAX</code>引用的文件必须是目录，返回值用于目录中的文件名。</p></li><li><p><code>_PC_PATH_MAX</code>引用的文件必须是目录。当所指定的目录是工作目录时，返回值是相对路径名的最大长度。</p></li><li><p><code>_PC_PIPE_BUF</code>引用的文件必须是管道、FIFO或目录，当引用管道或FIFO时返回的值是对所引用的文件的限制值，引用目录时返回该目录中创建的任一FIFO的限制值。</p></li><li><p><code>_PC_SYMLINK_MAX</code>引用的文件必须是目录。返回值是该目录中符号链接可包含字符串的最大长度。</p></li></ul><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>如果编写的程序需要用到XSI选项组中的可选功能，我们就需要一种方法来判断实现是否支持一个给定的选项。和对限制的处理很类似，POSIX定义了三种处理选项的方法：</p><ul><li>编译时选项定义在&lt;unistd.h&gt;中</li><li>与文件或目录无关的运行时选项用sysconf来判断。</li><li>与文件或目录有关的运行时选项用pathconf或fpathconf来判断。</li></ul><p>对于每一个选项有三种可能的支持状态：</p><ul><li>如果符号常量没有定义或定义值为-1，则不受支持。</li><li>如果符号常量定义值大于0，则受支持。</li><li>如果符号常量的定义值等于0，则必须调用sysconf、pathconf或fpathconf来判断是否受支持。</li></ul><p>pathconf和fpathconf的选项与name参数：</p><table><thead><tr><th>选项名</th><th>说明</th><th>name参数</th></tr></thead><tbody><tr><td><code>_POSIX_CHOWN_RESTRICTED</code></td><td>使用chown是否是受限的</td><td><code>_PC_CHOWN_RESTRICTED</code></td></tr><tr><td><code>_POSIX_NO_TRUNC</code></td><td>路径名长于NAME_MAX是否出错</td><td><code>_PC_NO_TRUNC</code></td></tr><tr><td><code>_POSIX_VDISABLE</code></td><td>若定义，可用此值禁用终端特殊字符</td><td><code>_PC_VDISABLE</code></td></tr><tr><td><code>_POSIX_ASYNC_IO</code></td><td>对相关联的文件是否可以使用异步I/O</td><td><code>_PC_ASYNC_IO</code></td></tr><tr><td><code>_POSIX_PRIO_IO</code></td><td>对相关联的文件是否可以使用优先I/O</td><td><code>_PC_PRIO_IO</code></td></tr><tr><td><code>_POSIX_SYNC_IO</code></td><td>对相关联的文件是否可以使用同步I/O</td><td><code>_PC_SYNC_IO</code></td></tr><tr><td><code>_POSIX2_SYMLINKS</code></td><td>目录中是否支持符号链接</td><td><code>_PC_2_SYMLINKS</code></td></tr></tbody></table><p>sysconf的选项及name参数：</p><table><thead><tr><th>选项名</th><th>说明</th><th>name参数</th></tr></thead><tbody><tr><td><code>_POSIX_ASYNCHRONOUS_TO</code></td><td>是否支持POSIX异步I/O</td><td><code>_SC_ASYNCHRONOUS_TO</code></td></tr><tr><td><code>_POSIX_BARRIERS</code></td><td>是否支持屏障</td><td><code>_SC_BARRIERS</code></td></tr><tr><td><code>_POSIX_CLOCK_SELECTION</code></td><td>是否支持时钟选择</td><td><code>_SC_CLOCK_SELECTION</code></td></tr><tr><td><code>_POSIX_JOB_CONTROL</code></td><td>是否支持作业控制</td><td><code>_SC_JOB_CONTROL</code></td></tr><tr><td><code>_POSIX_MAPPED_FILES</code></td><td>是否支持存储映像文件</td><td><code>_SC_MAPPED_FILES</code></td></tr><tr><td><code>_POSIX_MEMORY_PROTECTION</code></td><td>是否支持存储保护</td><td><code>_SC_MEMORY_PROTECTION</code></td></tr><tr><td><code>_POSIX_READER_WRITER_LOCKS</code></td><td>是否支持读者写者保护</td><td><code>_SC_READER_WRITER_LOCKS</code></td></tr><tr><td><code>_POSIX_REALTIME_SIGNALS</code></td><td>是否支持实时信号</td><td><code>_SC_REALTIME_SIGNALS</code></td></tr><tr><td><code>_POSIX_SAVED_IDS</code></td><td>是否支持保存的设置用户ID的保存的的设置组ID</td><td><code>_SC_SAVED_IDS</code></td></tr><tr><td><code>_POSIX_SEMAPHORES</code></td><td>是否支持POSIX信号量</td><td><code>_SC_SEMAPHORES</code></td></tr><tr><td><code>_POSIX_SHELL</code></td><td>是否支持POSIX shell</td><td><code>_SC_SHELL</code></td></tr><tr><td><code>_POSIX_SPIN_LOCKS</code></td><td>是否支持旋转锁</td><td><code>_SC_SPIN_LOCKS</code></td></tr><tr><td><code>_POSIX_THREAD_SAFE_FUNCTIONS</code></td><td>是否支持线程安全函数</td><td><code>_SC_THREAD_SAFE_FUNCTIONS</code></td></tr><tr><td><code>_POSIX_THREADS</code></td><td>是否支持线程</td><td><code>_SC_THREADS</code></td></tr><tr><td><code>_POSIX_TIMEOUTS</code></td><td>是否支持基于超时的变量选择函数</td><td><code>_SC_TIMEOUTS</code></td></tr><tr><td><code>_POSIX_TIMERS</code></td><td>是否支持定时器</td><td><code>_SC_TIMERS</code></td></tr><tr><td><code>_POSIX_VERSION</code></td><td>POSIX版本</td><td><code>_SC_VERSION</code></td></tr><tr><td><code>_XOPEN_CRYPT</code></td><td>是否支持XSI加密可靠组</td><td><code>_XOPEN_CRYPT</code></td></tr><tr><td><code>_XOPEN_REALTIME</code></td><td>是否支持实时选项组</td><td><code>_SC_XOPEN_REALTIME</code></td></tr><tr><td><code>_XOPEN_REALTIME_THREADS</code></td><td>是否支持实时线程选项组</td><td><code>_SC_XOPEN_REALTIME_THREADS</code></td></tr><tr><td><code>_XOPEN_SHM</code></td><td>是否支持XSI共享存储选项组</td><td><code>_SC_XOPEN_SHM</code></td></tr><tr><td><code>_XOPEN_VERSION</code></td><td>XSI版本</td><td><code>_SC_XOPEN_VERSION</code></td></tr></tbody></table><h2 id="基本系统数据类型"><a href="#基本系统数据类型" class="headerlink" title="基本系统数据类型"></a>基本系统数据类型</h2><p>基本系统数据类型，定义在&lt;sys/types.h&gt;中，用于将系统变量与C数据类型联系在一起。这样就不用考虑具体系统实现细节。包括：</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>clock_t</td><td>时钟滴答计数器</td></tr><tr><td>comp_t</td><td>压缩的时针滴答</td></tr><tr><td>dev_t</td><td>设备号</td></tr><tr><td>fd_set</td><td>文件描述符集</td></tr><tr><td>fpos_t</td><td>文件位置</td></tr><tr><td>gid_t</td><td>数值组ID</td></tr><tr><td>ino_t</td><td>i节点编号</td></tr><tr><td>mode_t</td><td>文件类型，文件创建模式</td></tr><tr><td>nlink_t</td><td>目录项链接计数</td></tr><tr><td>off_t</td><td>文件长度的偏移量</td></tr><tr><td>pid_t</td><td>进程ID和进程组ID</td></tr><tr><td>pthread_t</td><td>线程ID</td></tr><tr><td>ptrdiff_t</td><td>两个指针相减的结果</td></tr><tr><td>rlim_t</td><td>资源限制</td></tr><tr><td>sig_atomic_t</td><td>能原子性地访问的数据类型</td></tr><tr><td>sigset_t</td><td>信号集</td></tr><tr><td>size_t</td><td>对象</td></tr><tr><td>ssize_t</td><td>返回字节计数的函数</td></tr><tr><td>time_t</td><td>日历时间的秒计数器</td></tr><tr><td>uid_t</td><td>数值用户ID</td></tr><tr><td>wchar_t</td><td>能表示所有不同的字符码</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 0x04 APUE学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> UNIX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配之AC自动机</title>
      <link href="/zh/blog/2021/11/02/0031-string_matching_automaton/"/>
      <url>/zh/blog/2021/11/02/0031-string_matching_automaton/</url>
      
        <content type="html"><![CDATA[<blockquote><p>AC自动机是一种综合了Tire树与KMP算法思想的字符串匹配算法，特点是同时进行多个模式串的匹配。</p></blockquote><span id="more"></span><h2 id="AC自动机介绍"><a href="#AC自动机介绍" class="headerlink" title="AC自动机介绍"></a>AC自动机介绍</h2><p>AC自动机利用KMP的最长成功匹配思想对Tire树进行改造，使得搜索效率大副提高，并且可以对多个模式串进行匹配。缺点是效大的空间复杂度，是一种空间换时间的算法。</p><h2 id="Tire树"><a href="#Tire树" class="headerlink" title="Tire树"></a>Tire树</h2><p>Tire树也就是字典树，可以提供高效的字符串查找。要构造一个Tire树，需要明确：</p><ol><li>一个字母表，包括所有模式串中可能出现的字符。</li><li>至少一个模式串。</li></ol><p>构造过程为从根节点开始，对每个串的字符逐位判断，若存在字符相同的子节点则转移到子节点。否则创建一个新节点，并令其字符为当前字符。将每个串遍历结束时停留的节点标记为接受节点。下一个串仍从根节点开始构造。</p><p>比如字母表限定为“小写英文字母（a-z）”，模式串为{“she”,”he”,”her”,”his”,”is”}时，可以生成如下所示Tire树：</p><p><img src="https://img.xilong.site/20211102/image-20211102120835270.png" alt="image-20211102120835270"></p><p>要判断一个串是否与某一模式串相同只需要从根节点开始，对待匹配串逐位判断，若存在与该位字符相同的子节点则转移，否则匹配失败。如果匹配结束时停留在接受节点则匹配成功。例如：</p><ul><li>待匹配串为”her”：<ul><li>初始位置为根节点，匹配字符’h’，存在字符为’h’的子节点，转移到对应节点。</li><li>匹配字符’e’，存在，转移到对应节点。</li><li>匹配字符’r’，存在，转移到对应节点。</li><li>匹配完成，当前节点为接受节点，匹配成功。</li></ul></li><li>待匹配串为”sh”:<ul><li>初始位置为根节点，匹配字符’s’，存在，转移到对应节点。</li><li>匹配字符’h’，存在，转移到对应节点。</li><li>匹配完成，当前节点不是接受节点，匹配失败。</li></ul></li><li>待匹配串为”rsg”:<ul><li>初始位置为根节点，匹配字符’r’，不存在，匹配失败。</li></ul></li></ul><h2 id="多模式匹配"><a href="#多模式匹配" class="headerlink" title="多模式匹配"></a>多模式匹配</h2><p>在Tire树中，一个节点表示的是从根节点到该点的路径对应的串。如上图树中最下层的’r’节点表示的是字符串”her”。考虑字符串”sher”，如果要求出各模式串在其中出现的次数，通常做法就是逐位与所有模式进行匹配：</p><ul><li>”sher”匹配{“she”,”he”,”her”,”his”,”is”}</li><li>”her”匹配{“she”,”he”,”her”,”his”,”is”}</li><li>”er”匹配{“she”,”he”,”her”,”his”,”is”}</li><li>”r”匹配{“she”,”he”,”her”,”his”,”is”}</li></ul><p>这里的匹配规则稍作改动，只要到达接受结点就算一次成功。也就是从匹配整个串变为匹配是否存在一个与模式相同的前缀。</p><p>问题是，匹配次数太多，且多数是不必要的。比如对”er”与”r”的10次（每个串分别与5个模式进行匹配）。以及”sher”对除”she”外的模式的4次匹配和”her”对”is”与”she”的2次匹配。在20次匹配中共有16次匹配是没有必要的，大大降低了去处效率。</p><p>在KMP思想的启发下，可以引入一个最长后缀的概念。当匹配失败时，转移到已匹配部分的最长后缀对应的节点继续匹配，就减少了不必要的匹配。</p><p>如对”sher”而言，匹配到”she”模式的末尾时位于第4层的’e’节点。匹配’r’时，无对应子节点而匹配失败，此时不从头开始，而是转移到第3层的’e’节点，其对应的”he”为”she”在该图中的最长后缀，此时继续匹配’r’，发现对应子节点，并转移到’r’。匹配结束，路径上的共有3个接受节点，分别对应”she”、”he”、”her”，这三个模式的匹配次数分别+1。</p><p>如果将每个节点的失败后转移节点标记出来，就形成了下图结构（蓝色箭头表示失败后转移节点，没有标记的则转移到根节点）：</p><p><img src="https://img.xilong.site/20211102/image-20211102130728715.png" alt="image-20211102130728715"></p><h2 id="失配指针"><a href="#失配指针" class="headerlink" title="失配指针"></a>失配指针</h2><p>上一节中的匹配方式就构成了AC自动机。AC自动机算法即是在Tire树的基础上加入了匹配失败的处理，使其达成了很高的多次匹配效率，主要用于匹配子串中各模式串出现的位置与次数。其中匹配失败处理就是通过失配指针实现的，即在每个节点中加入一个指针指向匹配失败后转移的节点。</p><p>失配指针可以使用如下方法得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// queue: 一个队列，保存节点指针</span><br><span class="line">// root: 根节点</span><br><span class="line">// 将根节点的fail指针设为null，并将其所有子节点入队</span><br><span class="line">root-&gt;fail = null</span><br><span class="line">for p in root.childs:</span><br><span class="line">    queue.push(p)</span><br><span class="line">// 层序遍历tire树</span><br><span class="line">while !queue.empty():</span><br><span class="line">    // 对当前节点，先将其fail值默认为root</span><br><span class="line">    cur = queue.pop();</span><br><span class="line">    cur-&gt;fail = root</span><br><span class="line">    </span><br><span class="line">    for p in cur.childs:</span><br><span class="line">        queue.push(p)</span><br><span class="line">    // 寻找其父节点的fail指针指向的节点的子节点</span><br><span class="line">    // 找到的第一个与当前节点值相同的节点就是当前节点的最长后缀节点</span><br><span class="line">    // 若没有相应的子节点，则迭代寻找fail的fail指针指向的节点。</span><br><span class="line">    fail = cur-&gt;parent-&gt;fail</span><br><span class="line">    while fail != null and cur-&gt;fail == root:</span><br><span class="line">        for p in fail.childs:</span><br><span class="line">            if p-&gt;value == cur-&gt;value:</span><br><span class="line">                cur-&gt;fail = p</span><br><span class="line">        fail = fail-&gt;fail</span><br></pre></td></tr></table></figure><h2 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// str:待匹配串</span><br><span class="line">// root:自动机根节点</span><br><span class="line">// 令cur指向根节点，并对str逐位匹配</span><br><span class="line">cur = root</span><br><span class="line">for i in (0, str.length()):</span><br><span class="line">    // 如果当前节点不存在str[i]对应的子节点，则进入cur-&gt;fail</span><br><span class="line">    // 循环直到存在对应节点或到达根节点</span><br><span class="line">auto index = Node::get_index(str[i])</span><br><span class="line">while cur-&gt;childs[index] == nullptr &amp;&amp; cur != root :</span><br><span class="line">cur = cur-&gt;fail</span><br><span class="line">// 如果仍没有对应节点，则退出此轮循环</span><br><span class="line">if cur-&gt;childs[index] == nullptr :</span><br><span class="line">    continue</span><br><span class="line">   // 进入到对应节点中，同时使用temp遍历该节点的所有后缀</span><br><span class="line">   // 将路径上的所有接受节点对应模式出现次数+1</span><br><span class="line">cur = cur-&gt;childs[index]</span><br><span class="line">temp = cur</span><br><span class="line">while temp != nullptr :</span><br><span class="line">for  p in temp-&gt;patterns :</span><br><span class="line">    ++nums[p]</span><br><span class="line">temp = temp-&gt;fail</span><br></pre></td></tr></table></figure><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><p>给出一个字母表为小写字母且不考虑内存泄露的简单实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACAutomaton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ACAutomaton</span>(<span class="keyword">const</span> vector&lt;string&gt; &amp;patterns) </span><br><span class="line">    : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">Node</span>(<span class="literal">nullptr</span>)), <span class="built_in">nums</span>(patterns.<span class="built_in">size</span>(), <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">generate_tire</span>(patterns);</span><br><span class="line">        <span class="built_in">generate_fails</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = root;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> index = Node::<span class="built_in">get_index</span>(str[i]);</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;childs[index] == <span class="literal">nullptr</span> &amp;&amp; cur != root) &#123;</span><br><span class="line">                cur = cur-&gt;fail;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;childs[index] == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            cur = cur-&gt;childs[index];</span><br><span class="line">            <span class="keyword">auto</span> temp = cur;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> p : temp-&gt;patterns) &#123;</span><br><span class="line">                    ++nums[p];</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp-&gt;fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;<span class="title">get_nums</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="built_in">Node</span> (Node *parent_) </span><br><span class="line">        : <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">parent</span>(parent_), <span class="built_in">fail</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_index</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> value;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; patterns;</span><br><span class="line"></span><br><span class="line">        Node *parent;</span><br><span class="line">        Node *fail;</span><br><span class="line">        Node *childs[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node *root;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generate_tire</span><span class="params">(<span class="keyword">const</span> vector&lt;string&gt; &amp;patterns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; patterns.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : patterns[i]) &#123;</span><br><span class="line">                <span class="keyword">auto</span> index = Node::<span class="built_in">get_index</span>(c);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;childs[index] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cur-&gt;childs[index] = <span class="keyword">new</span> <span class="built_in">Node</span>(cur);</span><br><span class="line">                    cur-&gt;childs[index]-&gt;value = c;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;childs[index];</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;patterns.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generate_fails</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        root-&gt;fail = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;childs[i])</span><br><span class="line">                q.<span class="built_in">push</span>(root-&gt;childs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            cur-&gt;fail = root;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;childs[i]) </span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;childs[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> f = cur-&gt;parent-&gt;fail;</span><br><span class="line">            <span class="keyword">while</span> (f != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;fail == root) &#123;</span><br><span class="line">                <span class="keyword">auto</span> index = Node::<span class="built_in">get_index</span>(cur-&gt;value);</span><br><span class="line">                <span class="keyword">if</span> (f-&gt;childs[index]) &#123;</span><br><span class="line">                    cur-&gt;fail = f-&gt;childs[index];</span><br><span class="line">                &#125;</span><br><span class="line">                f = f-&gt;fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// while !q.empty</span></span><br><span class="line">    &#125; <span class="comment">// generate_fails</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0x00 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配之KMP</title>
      <link href="/zh/blog/2021/11/01/0030-string_matching_KMP/"/>
      <url>/zh/blog/2021/11/01/0030-string_matching_KMP/</url>
      
        <content type="html"><![CDATA[<blockquote><p>字符串匹配算法半壁江山之KMP算法。</p></blockquote><span id="more"></span><h2 id="KMP算法介绍"><a href="#KMP算法介绍" class="headerlink" title="KMP算法介绍"></a>KMP算法介绍</h2><p>KMP算法是一种利用模式串中的信息来尽可能减少与待匹配串的匹配次数从而大副提高效率的算法。它的核心是一个<code>next</code>表，用以记录一次匹配失败后，下次匹配开始的位置。</p><h2 id="KMP匹配过程"><a href="#KMP匹配过程" class="headerlink" title="KMP匹配过程"></a>KMP匹配过程</h2><p>如何生成<code>next</code>表是KMP的核心内容，但在此之前，不妨先看看KMP算法是如何工作的。</p><p>设模式串为”ABAABAC”，待匹配串为”ABABAABAABAC”。根据模式串生成的<code>next</code>表为：{0, 0, 1, 1, 2, 3, 0}。之后会介绍如何生成<code>next</code>表。这里先解释这个表的意义，<code>next[n] = k</code>意为<strong>在模式串前n位构成的子串中，其最长相等严格前后缀的长度为k。</strong></p><p>解释一下黑体字就是说，对于模式串“ABAABAC”而言，其前6位构成的子串是”ABAABA”。所谓的严格前/后缀就是指除了串本身的前/后缀：<code>&#123;前/后缀&#125; - &#123;串本身&#125;</code>。相等严格前后缀是指既是串的严格前缀也是串的严格后缀的子串，对于”ABAABA”而言，其相等严格前后缀有：”A”、”ABA”两个。最长相等严格前后缀显然就是”ABA”。</p><p>上面这段话就可以表示为<code>next[6] = 3</code>。</p><p>从位置0开始匹配，结果如下：</p><p><img src="https://img.xilong.site/20211101/image-20211101183430703.png" alt="image-20211101183430703"></p><p>成功匹配的位数是3，查询匹配表项<code>next[3] = 1</code>。也就是已匹配部分的末位与首位相等，因此可以直接将首位移到末位位置开始下一轮匹配：</p><p><img src="https://img.xilong.site/20211101/image-20211101191242087.png" alt="image-20211101191242087"></p><p>成功匹配的位数是6，注意匹配并不是从位置2开始的，而是从位置3——上次匹配失败的位置开始，查询匹配表项<code>next[6] = 3</code>。说明已匹配部分前3位与后3位相等，将前3位移到后3位的位置开始下一轮匹配：</p><p><img src="https://img.xilong.site/20211101/image-20211101190744058.png" alt="image-20211101190744058"></p><p>匹配成功。</p><p>注意到，所谓移动其实就是从模式串的下标<code>next[匹配成功位数]</code>开始，从失败位置继续匹配。</p><p>代码表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str:待匹配串, pattern:模式串, next[pattern.size()]:失配表</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> string&amp; str, <span class="keyword">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// j与i匹配失败而j不为0时，说明有j - 1位匹配成功。</span></span><br><span class="line">        <span class="comment">// 尝试使用pattern[next[j - 1]]从失败位置继续匹配，直到</span></span><br><span class="line">        <span class="comment">//    1. j == 0</span></span><br><span class="line">        <span class="comment">//    2. 匹配成功</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; pattern[j] != str[i]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配成功则成功位数+1</span></span><br><span class="line">        <span class="keyword">if</span> (pattern[j] == str[i]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若匹配成功位数等于模式串大小，说明模式匹配成功，记录下这个位置。</span></span><br><span class="line">        <span class="keyword">if</span> (j == pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(i - pattern.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next表生成"><a href="#next表生成" class="headerlink" title="next表生成"></a>next表生成</h2><p>next表的生成方法可以理解成使用模式串去匹配自身。数学证明太过复杂按下不表，先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(<span class="keyword">const</span> string &amp;str)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(str.length(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// k &gt; 0且匹配失败说明之前存在k - 1位的匹配成功。</span></span><br><span class="line">        <span class="comment">// 尝试使用str[result[k - 1]]与str[i]继续匹配</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; str[k] != str[i]) &#123;</span><br><span class="line">            k = result[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果匹配成功，则说明str前i位这个子串的后k位与前k位相同</span></span><br><span class="line">        <span class="comment">// 即result[i] = k;</span></span><br><span class="line">        <span class="keyword">if</span> (str[k] == str[i]) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        result[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出与kmp匹配过程的代码非常相似，图解如下：</p><p>例P=”ABCDABA”</p><p><img src="https://img.xilong.site/20211101/image-20211101211913745.png" alt="image-20211101211913745"></p><p>因为严格前/后缀不能等于自身，因此从第2位开始匹配，并将第一位结果置0。可见匹配失败，且<code>k=0</code>，将此位结果置0，进入下一位。</p><p><img src="https://img.xilong.site/20211101/image-20211101212012168.png" alt="image-20211101212012168"></p><p>依然不匹配，且<code>k=0</code>，置0进入下一位。</p><p><img src="https://img.xilong.site/20211101/image-20211101212117026.png" alt="image-20211101212117026"></p><p>还是不匹配，且<code>k=0</code>，置0进入下一位。</p><p><img src="https://img.xilong.site/20211101/image-20211101212427058.png" alt="image-20211101212427058"></p><p>匹配，<code>++k</code>，并置<code>结果=k=1</code>。由于下一步比较时<code>k=1</code>增量与比较步长相同，看起来好像没有移动。</p><p><img src="https://img.xilong.site/20211101/image-20211101212506554.png" alt="image-20211101212506554"></p><p>匹配，<code>++k</code>，并置<code>结果=k=2</code>。进入下一步。</p><p><img src="https://img.xilong.site/20211101/image-20211101212649204.png" alt="image-20211101212649204"></p><p>不匹配，且<code>k &gt; 0</code>试图取<code>next[k - 1] = next[1] = 0</code>与该位比较。</p><p><img src="https://img.xilong.site/20211101/image-20211101212832132.png" alt="image-20211101212832132"></p><p>匹配，且<code>k=0</code>，<code>++k</code>置<code>结果=k=1</code>。结束匹配过程。</p><p>最终结果<code>next=&#123;0,0,0,0,1,2,1&#125;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 0x00 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APUE学习笔记00——UNIX基础</title>
      <link href="/zh/blog/2021/10/27/0029-APUE_chapter1/"/>
      <url>/zh/blog/2021/10/27/0029-APUE_chapter1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>APUE这本书实在是干而松散，不自己消化消化确实看不下去。这篇文章简单总结一下前两章，Unix基础与标准。</p></blockquote><span id="more"></span><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>操作系统在狭义上单指一种控制硬件单元，为程序提供运行环境的软件，称为内核（Kernel）。内核的接口称为系统调用（System call）。</p><p>广义上，操作系统包括内核以及一些软件，这些软件包括了公用函数库、shell和系统实用程序（system utility）以及一些应用程序。</p><p>其中，公用函数库就是建立在系统调用的基础上的一些函数。应用程序既可以使用系统调用也可以使用公用函数库。shell是一个特殊的应用程序，为运行其它程序提供了一个接口。</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>用户键入用户名与口令，系统在口令文件中读取相关信息并进行相应操作。口令文件通常是<code>/etc/passwd</code>，其中每行记录一个登录项。登录项由7个以冒号分隔的字段组成，依次是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登录名:加密口令:UID:GID:注释:起始目录:shell程序</span><br></pre></td></tr></table></figure><p>目前所有系统都将加密口令移到另一个文件中，但这里先略过。</p><p>登录后，通常进入到shell程序，shell是一个命令行解释器，它读取用户输入然后执行命令。</p><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p><strong>文件系统</strong></p><p>UNIX文件系统是目录和文件的一种层次结构，所有东西的起点是根(root)目录，其名称是<code>/</code>。</p><p>我们总听说UNIX中一切皆文件，对于目录也是适用的。实际上目录是一个包含目录项的文件，逻辑上可以认为每个目录项都包含一个文件名与文件属性信息。</p><p><strong>文件名</strong></p><p>目录中的各项拥有一个文件名(filename)。只有斜线<code>/</code>和空字符不能出现在文件名中。因为斜线用来分隔路径名和文件名而空字符表示路径结束。</p><p>但习惯上最好还是使用字母、数字、<code>.</code>、<code>-</code>、<code>_</code>作为文件名，这可以避免很多麻烦。</p><p>新的目录会创建两个文件名<code>.</code>、<code>..</code>，<code>.</code>指向当前目录，<code>..</code>指向上级目录。在根目录中都指向根目录。</p><p><strong>路径名</strong></p><p>由<code>/</code>分隔的一个或多个文件名组成的序列构成一个路径名，以<code>/</code>开头的称为绝对路径，以文件名开头称为相对路径。相对路径名指向相对于当前目录的文件。</p><p><strong>工作目录</strong></p><p>每个进程有一个工作目录，所有相对路径名从工作目录开始解释，进程可以使用<code>chdir</code>来更改工作目录。</p><p><strong>起始目录</strong></p><p>登录时的工作目录为起始目录，记录在口令文件中。</p><h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><p><strong>文件描述符</strong></p><p>文件描述符通常是一个小的非负整数，内核用以标识一个特定的进程正在访问的文件。当内核打开一个现有文件或创建一个新文件时，它都返回一个文件描述符。在读写文件时，可以使用这个文件描述符。</p><p><strong>标准输入</strong>、标准输出和标准错误</p><p>惯例上，每当运行一个新程序时，所有shell都为其打开3个文件描述符，分别为标准输入、标准输出、标准错误。如果不做特殊处理，它们都链接终端。</p><p>大多数shell提供一种方法，使其中任何一个都能重定向至某个文件。</p><p><strong>缓冲</strong></p><p>不带缓冲的I/O直接向文件中写入，而带缓冲的I/O在缓冲区满后才写入文件。</p><h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><p>程序是存储在磁盘上的可执行文件。内核使用<code>exec</code>函数将程序读入内存，并执行程序。</p><p>程序的执行实例被称为进程。UNIX系统确保每个进程都有一个唯一的数字标识符，称为PID，PID总是一个非负整数。</p><p>系统主要使用三个函数控制进程：<code>fork</code>、<code>exec</code>、<code>waitpid</code>。</p><p>通常一个进程只有一个控制线程——某一时刻执行的一组机器指令。但某些情况下可以拥有多个线程。一个进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关属性。因为它们能访问同一存储区，所以各线程在访问共享数据时需要采取同步措施以避免不一致性。</p><p>线程也用ID标识，称为TID。TID只在进程内起作用，对其它进程没有意义。</p><h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><p>当UNIX系统函数出错时通常返回一个负值，且整型变量<code>errno</code>通常被设置为具有特定信息的值。文件<code>&lt;errno.h&gt;</code>中定义了<code>errno</code>及可以赋予它的常量。这些常量都以字母<code>E</code>开头。对于<code>errno</code>有两条规则：</p><ol><li>只有出错时才改变它的值。</li><li>任何程序都不会将它的值设为0。</li></ol><p>两个函数可以用于打印出错消息，分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>; <span class="comment">// errnum通常是errno值，函数将其映射为一个出错消息的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// 先输出msg，然后接一个冒号，一个空格，errno对应的消息，一个换行符。</span></span><br></pre></td></tr></table></figure><h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><p><strong>UID</strong></p><p>UID是一个数值，向系统标识各个不同的用户。系统管理员在确定一个用户的登录名的同时，确定其UID。用户不能更改其UID。</p><p>UID为0的用户为root用户。root用户拥有系统的自由支配权。</p><p><strong>GID</strong></p><p>GID是一个标识用户所在组的ID，也是由系统管理员在创建用户时分配的。组文件将组名映射为数值的GID，通常是<code>/etc/group</code>。</p><p><strong>SGID</strong></p><p>SGID是附属组ID，UNIX允许一个用户同时属于多至16个其它的组。这些信息也存在组文件中。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号用于通知进程发生了某种情况。进程有3种处理信号的方式：</p><ol><li>忽略信号。</li><li>按系统默认方式处理。</li><li>提供一个函数，信号发生时调用该函数，称为捕捉信号。</li></ol><h2 id="时间值"><a href="#时间值" class="headerlink" title="时间值"></a>时间值</h2><p><strong>日历时间</strong>：从1970年1月1日00:00:00以来经过的秒数时间值，使用<code>time_t</code>保存。</p><p><strong>进程时间</strong>：被称为CPU时间，用以度量进程使用的中央处理器资源。进程时间以时钟tick计算。当一个进程创建时，系统维护3个进程时间值：</p><ol><li>时钟时间，进程消耗的总时间。</li><li>用户CPU时间，进程执行用户指令所用的时间。</li><li>系统CPU时间，进程执行内核程序所用的时间。</li></ol><p>其中用户CPU时间与系统CPU时间之和称为CPU时间。</p><h2 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h2><p>系统调用是内核提供的良好定义、数量有限、直接进入内核的入口点。从应用角度考虑，可以将系统调用看做C函数。通用库函数通常调用一个或多个系统调用，其中一个关键区别在于，我们可以在需要的时候替换库函数，但无法替换系统调用。另一方面，系统调用通常提供简单而单一的功能，而库函数则更加复杂。</p>]]></content>
      
      
      <categories>
          
          <category> 0x04 APUE学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> UNIX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树概念解析与C++实现</title>
      <link href="/zh/blog/2021/09/23/0028-RB_Tree_C++/"/>
      <url>/zh/blog/2021/09/23/0028-RB_Tree_C++/</url>
      
        <content type="html"><![CDATA[<blockquote><p>整理了红黑树的性质与基本操作的C++实现</p></blockquote><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>红黑树（Red Black Tree，简称R-B Tree）是一种特殊的二叉查找树。它的特殊性体现在：</p><ol><li>每个节点都有颜色，可以是红色或黑色。</li><li>根节点是黑色。</li><li>每个叶子节点（NULL）是黑色。尤其注意这里的结子节点指的是NULL。</li><li>红色节点的子节点必为黑色。</li><li>任一结点到其所有后代叶节点的路径中具有相同数目的黑色节点。</li></ol><p><em>特性5保证了任一路径不会超过最短路径的两倍，因而红黑树是接近平衡的二叉树。</em></p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>一个红黑树节点可以使用三叉链表的形式实现为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">R_BNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">COLOR</span> &#123;</span>BLACK = <span class="number">0</span>, RED = <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">R_BNode</span><span class="params">(<span class="keyword">int</span> data = <span class="number">0</span>, R_BNode::COLOR color = RED)</span> </span></span><br><span class="line"><span class="function">        : left_(Nil), right_(Nil), parent_(Nil)</span></span><br><span class="line"><span class="function">        , color_(color), data_(data)  &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    R_BNode *left_;</span><br><span class="line">    R_BNode *right_;</span><br><span class="line">    R_BNode *parent_;</span><br><span class="line">    COLOR color_;</span><br><span class="line">    <span class="keyword">int</span> data_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> R_BNode *Nil;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">R_BNode *R_BNode::Nil = <span class="keyword">new</span> <span class="built_in">R_BNode</span>(<span class="number">0</span>, R_BNode::BLACK);</span><br></pre></td></tr></table></figure><p>这里为简化问题将data定为int类型，这并不会影响对红黑树的研究。如有需要可以使用类模板或<code>void*</code>等方式来实现泛型的红黑树。</p><p>定义红黑树类型为指向红黑树节点的指针。并创建一个静态变量<code>Nil</code>作为所有叶子节点的指代，这样做就可以把本不存在的叶子节点视为普通节点来处理了。</p><p>红黑树可以实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">R_BTree</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">R_BTree</span><span class="params">()</span> : root_(R_BNODE::Nil) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    R_BNode *root_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="基本操作：旋转"><a href="#基本操作：旋转" class="headerlink" title="基本操作：旋转"></a>基本操作：旋转</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当修改红黑树上的节点时，可能会破坏树的性质，使得树不再是红黑树。此时需要调整一些节点的颜色与指针结构，使树重新成为红黑树。</p><p>其中对指针结构的调整就需要借助旋转操作，这是一种能保持二叉搜索树性质的局部操作。旋转分为左旋与右旋，下面以左旋为例介绍旋转操作：</p><p>任一右孩子不为Nil的结点x都可进行左旋操作，设其右孩子是y，则左旋后：</p><ol><li>y成为子树新的根节点。</li><li>x在新子树中成为y的左孩子。</li><li>上述变化后，x的右孩子变成双亲了，空出一个位置，而y原来的左孩子无家可归，由此让y原来的左孩子成为x新的右孩子。</li></ol><p>而右旋是左旋的镜像操作。两种旋转如下图所示：</p><p><img src="https://img.xilong.site/20210923/rotate.png" alt="rotate"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅给出实现，声明可以自行添加到对应的类中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_BTree::LeftRotate</span><span class="params">(R_BNode *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right_ == R_BNode::Nil) <span class="keyword">throw</span> <span class="string">&quot;Error while left rotate&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> y = x-&gt;right_;</span><br><span class="line">    x-&gt;right_ = y-&gt;left_;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left_ != R_BNode::Nil) &#123;</span><br><span class="line">        y-&gt;left_-&gt;parent_ = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;parent_ = x-&gt;parent_;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;parent_ == R_BNode::Nil) &#123;</span><br><span class="line">        root_ = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent_-&gt;left_) &#123;</span><br><span class="line">        x-&gt;parent_-&gt;left_ = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x-&gt;parent_-&gt;right_ = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;left_ = x;</span><br><span class="line">    x-&gt;parent_ = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_BTree::RightRotate</span><span class="params">(R_BNode *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;left_ == R_BNode::Nil) <span class="keyword">throw</span> <span class="string">&quot;Error while right rotate&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> y = x-&gt;left_;</span><br><span class="line">    x-&gt;left_ = y-&gt;right_;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;right_ != R_BNode::Nil) &#123;</span><br><span class="line">        y-&gt;right_-&gt;parent_ = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;parent_ = x-&gt;parent_;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;parent_ == R_BNode::Nil) &#123;</span><br><span class="line">        root_ = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent_-&gt;left_) &#123;</span><br><span class="line">        x-&gt;parent_-&gt;left_ = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x-&gt;parent_-&gt;right_ = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;right_ = x;</span><br><span class="line">    x-&gt;parent_ = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本操作：插入"><a href="#基本操作：插入" class="headerlink" title="基本操作：插入"></a>基本操作：插入</h2><p>红黑树是一种特殊的二叉查找树，因此插入节点时先按照二叉查找树的方法进行插入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_BTree::Insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> y = R_BNode::Nil;</span><br><span class="line">    <span class="keyword">auto</span> x = root_;</span><br><span class="line">    <span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in">R_BNode</span>(value, R_BNode::RED);</span><br><span class="line">    <span class="keyword">while</span> (x != R_BNode::Nil) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; x-&gt;data_) &#123;</span><br><span class="line">            x = x-&gt;left_;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x = x-&gt;right_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;parent_ = y;</span><br><span class="line">    <span class="keyword">if</span> (y = R_BNode::Nil) &#123;</span><br><span class="line">        root_ = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;data_ &lt; y-&gt;data_) &#123;</span><br><span class="line">        y-&gt;left_ = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;right_ = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InsertFixup</span>(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来我们可能破坏了树的结构，因此，我们寄希望于最后调用的<code>InsertFixup</code>函数。</p><p>如何实现<code>InsertFixup</code>函数呢？这就得慢慢分析：</p><blockquote><p>规则1：节点有颜色，且是红色或黑色。</p><p>规则3：叶子节点是黑色节点。</p></blockquote><p>这两条显然是不会违反的。</p><blockquote><p>规则5：任一结点到其所有后代叶节点的路径中具有相同数目的黑色节点。</p></blockquote><p>这就是我们插入的节点总是红色的原因，插入红色的结点并不影响树中原有路径中的黑色节点数目。因此不会违反规则5。</p><blockquote><p>规则2：根节点是黑色节点。</p></blockquote><p>当我们插入的节点作为根节点时，就违反了规则2。此时只要改变节点的颜色就可以修复红黑树。此时可以实现出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_BTree::InsertFixup</span><span class="params">(R_BNode *z)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    root_-&gt;color = R_BNode::BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>规则4：红色节点的孩子一定是黑色节点。</p></blockquote><p>当插入节点的父节点是红色时，违反规则4。总共存在三种可能的情况：</p><h3 id="情况一：叔节点是红色"><a href="#情况一：叔节点是红色" class="headerlink" title="情况一：叔节点是红色"></a>情况一：叔节点是红色</h3><p>此时将叔节点与父节点都设为黑色，并把祖父节点设为红色。然后对祖父节点使用<code>InsertFixup</code>函数即可。因为对祖父节点的任何子孙节点，都必然途径祖父节点，以及父节点、叔节点中的一个。将父节点与叔节点都设成黑色等于所有路径的黑色节点数加一，而将祖父节点设为红色等于所有路径的黑色节点数减一。因此不会违反规则5。同时这样将规则4的违反提升到了更高的层次去处理，这样至多处理log(h)（h为树高）次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_BTree::InsertFixup</span><span class="params">(R_BNode *z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (z-&gt;parent-&gt;color == R_BNode::RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;parent_ = z-&gt;parent_-&gt;parent_-&gt;left_) &#123;</span><br><span class="line">            <span class="keyword">auto</span> y = z-&gt;parent_-&gt;parent_-&gt;right_;</span><br><span class="line">            <span class="comment">// case 1</span></span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color_ = R_BNode::RED) &#123;</span><br><span class="line">                z-&gt;parent_-&gt;color_ == R_BNode::BLACK;</span><br><span class="line">                y-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">                z-&gt;parent_-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">                z = z-&gt;parent_-&gt;parent_;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> y = z-&gt;parent_-&gt;parent_-&gt;left_;</span><br><span class="line">            <span class="comment">// case 1</span></span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color_ = R_BNode::RED) &#123;</span><br><span class="line">                z-&gt;parent_-&gt;color_ == R_BNode::BLACK;</span><br><span class="line">                y-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">                z-&gt;parent_-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">                z = z-&gt;parent_-&gt;parent_;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root_-&gt;color = R_BNode::BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="情况二：叔节点是黑色，且z与父节点异侧"><a href="#情况二：叔节点是黑色，且z与父节点异侧" class="headerlink" title="情况二：叔节点是黑色，且z与父节点异侧"></a>情况二：叔节点是黑色，且z与父节点异侧</h3><p>所谓同侧，就是说z相对于父节点的方向和父节点相对于祖父节点的方向相同。如都是左孩子或都是右孩子。异侧则反之。</p><p>此时可以通过对父节点的一次旋转将情况二转化为情况三。</p><h3 id="情况三：叔节点是黑色，且z与父节点同侧"><a href="#情况三：叔节点是黑色，且z与父节点同侧" class="headerlink" title="情况三：叔节点是黑色，且z与父节点同侧"></a>情况三：叔节点是黑色，且z与父节点同侧</h3><p>此时对祖父节点进行一次与情况二反向的旋转即可修复红黑树。</p><p>以一个不同侧且父节点为左孩子的情况为例：</p><p><img src="https://img.xilong.site/20210923/insert.png" alt="insert"></p><p>如上图，对c而言，叔节点是Nil，为黑色。且c是b的右孩子，而b是a的左孩子，因此c与父节点不同侧，即为情况2。</p><p>此时要想使bc同侧，只需对b进行左旋，并将b当做插入节点重新考虑。显然一次左旋过后，b的叔节点为Nil，为黑色。且与父节点c同侧。即为情况3。</p><p>此时只需交换父节点与祖父节点的颜色，并对祖父节点进行右旋，即可完成对红黑树的修复。</p><p><strong>注意：上述旋转方向是父节点为左孩子时的情况，对于父节点为右孩子的情况，需要进行镜像操作，即左右互换。</strong></p><p>最终实现为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_BTree::InsertFixup</span><span class="params">(R_BNode *z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (z-&gt;parent_-&gt;color_ == R_BNode::RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;parent_ == z-&gt;parent_-&gt;parent_-&gt;left_) &#123;</span><br><span class="line">            <span class="keyword">auto</span> y = z-&gt;parent_-&gt;parent_-&gt;right_;</span><br><span class="line">            <span class="comment">// case 1</span></span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color_ == R_BNode::RED) &#123;</span><br><span class="line">                z-&gt;parent_-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">                y-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">                z-&gt;parent_-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">                z = z-&gt;parent_-&gt;parent_;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z == z-&gt;parent_-&gt;right_) &#123;</span><br><span class="line">                <span class="comment">//case 2</span></span><br><span class="line">                z = z-&gt;parent_;</span><br><span class="line">                <span class="built_in">LeftRotate</span>(z);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case 3</span></span><br><span class="line">            z-&gt;parent_-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">            z-&gt;parent_-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">            <span class="built_in">RightRotate</span>(z-&gt;parent_-&gt;parent_);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> y = z-&gt;parent_-&gt;parent_-&gt;left_;</span><br><span class="line">            <span class="comment">// case 1</span></span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color_ == R_BNode::RED) &#123;</span><br><span class="line">                z-&gt;parent_-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">                y-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">                z-&gt;parent_-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">                z = z-&gt;parent_-&gt;parent_;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z == z-&gt;parent_-&gt;left_) &#123;</span><br><span class="line">                <span class="comment">//case 2</span></span><br><span class="line">                z = z-&gt;parent_;</span><br><span class="line">                <span class="built_in">RightRotate</span>(z);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case 3</span></span><br><span class="line">            z-&gt;parent_-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">            z-&gt;parent_-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">            <span class="built_in">LeftRotate</span>(z-&gt;parent_-&gt;parent_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root_-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本操作：删除"><a href="#基本操作：删除" class="headerlink" title="基本操作：删除"></a>基本操作：删除</h2><p>要删除一个节点，首先要定义一个辅助操作，用以使用一个节点去替换另一个节点的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用v去替换u</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_BTree::Transplant</span><span class="params">(R_BNode *u, R_BNode *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;parent_ == R_BNode::Nil) &#123;</span><br><span class="line">        root_ = v;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u-&gt;parent_-&gt;left_) &#123;</span><br><span class="line">        u-&gt;parent_-&gt;left_ = v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        u-&gt;parent_-&gt;right_ = v;</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;parent_ = u-&gt;parent_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 删除一个节点的操作与二叉搜索树相似，当目标节点只有两个以下孩子时，使用它的孩子替换它自身。当目标节点存在两个孩子时则比较麻烦，需要找出目标节点的后继，并使用这个后继替换自身。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_BTree::Delete</span><span class="params">(R_BNode *z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> y = z;</span><br><span class="line">    <span class="keyword">auto</span> y_origin_color = z-&gt;color_;</span><br><span class="line">    R_BNode *x = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (z-&gt;left_ == R_BNode::Nil) &#123;</span><br><span class="line">        x = z-&gt;right_;</span><br><span class="line">        <span class="built_in">Transplant</span>(z, z-&gt;right_);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;right_ == R_BNode::Nil) &#123;</span><br><span class="line">        x = z-&gt;left_;</span><br><span class="line">        <span class="built_in">Transplant</span>(z, z-&gt;left_);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y = z-&gt;right_;</span><br><span class="line">        <span class="keyword">while</span> (y-&gt;left_ != R_BNode::Nil) &#123;</span><br><span class="line">            y = y-&gt;left_;</span><br><span class="line">        &#125;</span><br><span class="line">        y_origin_color = y-&gt;color_;</span><br><span class="line">        x = y-&gt;right_;</span><br><span class="line">        <span class="keyword">if</span> (y-&gt;parent_ != z) &#123;</span><br><span class="line">            <span class="built_in">Transplant</span>(y, y-&gt;right_);</span><br><span class="line">            y-&gt;right_ = z-&gt;right_;</span><br><span class="line">            y-&gt;right_-&gt;parent_ = y;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">Transplant</span>(z, y);</span><br><span class="line">        y-&gt;left_ = z-&gt;left_;</span><br><span class="line">        y-&gt;left_-&gt;parent_ = y;</span><br><span class="line">        y-&gt;color_ = z-&gt;color_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y_origin_color == R_BNode::BLACK) &#123;</span><br><span class="line">        <span class="built_in">DeleteFixup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序中，y用来标记删除或移动的节点。x用来标记y在移动或删除之前的位置。如果y是红色节点，那么移动或删除y并不会破坏红黑树的性质。因为：</p><ol><li>树的黑高（只计算黑色节点时的高度）没有改变。</li><li>y移动到z的位置并继承了z的颜色，而z的位置与颜色在删除操作前是合法的，因此y不会改变该位置合法性。</li><li>如果y为红色，则y不是根结点，因此根结点仍为黑色。</li></ol><p>现在考虑对破坏的修复，如果y黑色，将导致3个问题：</p><ol><li>如果y是原来的节结点，而继承它位置的节点是红色，则违反了性质2。</li><li>如果x和x.p是红色的，则违反了性质4。</li><li>移动y导致先前树中所有包含y的简单路径中黑色节点的数目减一，导致了所有y的祖先节点都不符合性质5。</li></ol><p>解决办法是将占有了y原来位置的节点x视为还有一层额外的黑色，这使得性质5成立，但因为现在的x要么是红黑色（颜色属性为红）要么是双重黑色（颜色属性为黑），又违反了性质1。注意这里所说的额外黑色是针对x节点的，并不反应在节点的颜色属性上。</p><p>对于x，如果：</p><ol><li>x是红黑色，则可以将x着为黑色。</li><li>x是根结点，则可以简单的消去一层黑色，什么也不做。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_BTree::DeleteFixup</span><span class="params">(R_BNode *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == root_ || x-&gt;color_ == R_BNode::RED) &#123;</span><br><span class="line">        x-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时要修复红黑树，需要分成4种情况：</p><h3 id="情况1：x的兄弟节点m为红色"><a href="#情况1：x的兄弟节点m为红色" class="headerlink" title="情况1：x的兄弟节点m为红色"></a>情况1：x的兄弟节点m为红色</h3><p>此时由于m的两个子节点都为黑色，可以改变m和父节点的颜色，然后对父节点进行一次旋转。并令x的新兄弟节点为新的m，这样情况就转移到了2、3或4。</p><p><img src="https://img.xilong.site/20210923/delete1.png" alt="delete1"></p><p>此时可以实现为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_BTree::DeleteFixup</span><span class="params">(R_BNode *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == root_ || x-&gt;color_ == R_BNode::RED) &#123;</span><br><span class="line">        x-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == x-&gt;parent_-&gt;left_) &#123;</span><br><span class="line">        <span class="keyword">auto</span> m = x-&gt;parent_-&gt;right_;</span><br><span class="line">        <span class="comment">// case 1</span></span><br><span class="line">        <span class="keyword">if</span> (m-&gt;color_ == R_BNode::RED) &#123;</span><br><span class="line">            m-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">            x-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">            <span class="built_in">LeftRotate</span>(x-&gt;parent_);</span><br><span class="line">            m = x-parent_-&gt;right_;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> m = x-&gt;parent_-&gt;left_;</span><br><span class="line">        <span class="comment">// case 1</span></span><br><span class="line">        <span class="keyword">if</span> (m-&gt;color_ == R_BNode::RED) &#123;</span><br><span class="line">            m-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">            x-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">            <span class="built_in">RightRotate</span>(x-&gt;parent_);</span><br><span class="line">            m = x-parent_-&gt;left_;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="情况2：x的兄弟节点m为黑色，且m的两个子节点都为黑色"><a href="#情况2：x的兄弟节点m为黑色，且m的两个子节点都为黑色" class="headerlink" title="情况2：x的兄弟节点m为黑色，且m的两个子节点都为黑色"></a>情况2：x的兄弟节点m为黑色，且m的两个子节点都为黑色</h3><p>此时由于x是双重黑色，而m与其两个子节点构成了两层黑色，因此可以从x与m上分别消去一层黑色，使得x为黑色，而m为红色。并令x-&gt;parent_为新的x，并对其进行<code>DeleteFixup</code>。</p><p><img src="https://img.xilong.site/20210923/delete2.png" alt="delete2"></p><p>此时由于重复调用，改变之前的程序结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_BTree::DeleteFixup</span><span class="params">(R_BNode *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != root_ &amp;&amp; x-&gt;color_ != R_BNode::RED) &#123;</span><br><span class="line">       <span class="keyword">if</span> (x == x-&gt;parent_-&gt;left_) &#123;</span><br><span class="line">           <span class="keyword">auto</span> m = x-&gt;parent_-&gt;right_;</span><br><span class="line">           <span class="comment">// case 1</span></span><br><span class="line">           <span class="keyword">if</span> (m-&gt;color_ == R_BNode::RED) &#123;</span><br><span class="line">               m-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">               x-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">               <span class="built_in">LeftRotate</span>(x-&gt;parent_);</span><br><span class="line">               m = x-parent_-&gt;right_;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// case 2</span></span><br><span class="line">           <span class="keyword">if</span> (m-&gt;left_-&gt;color_ == R_BNode::BLACK</span><br><span class="line">               &amp;&amp; m-&gt;right_-&gt;color_ == R_BNode::BLACK) &#123;</span><br><span class="line">               m-&gt;color_ = R_BNode::RED;</span><br><span class="line">               x = x-&gt;parent_;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">auto</span> m = x-&gt;parent_-&gt;left_;</span><br><span class="line">           <span class="comment">// case 1</span></span><br><span class="line">           <span class="keyword">if</span> (m-&gt;color_ == R_BNode::RED) &#123;</span><br><span class="line">               m-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">               x-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">               <span class="built_in">RightRotate</span>(x-&gt;parent_);</span><br><span class="line">               m = x-parent_-&gt;left_;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// case 2</span></span><br><span class="line">           <span class="keyword">if</span> (m-&gt;left_-&gt;color_ == R_BNode::BLACK</span><br><span class="line">               &amp;&amp; m-&gt;right_-&gt;color_ == R_BNode::BLACK) &#123;</span><br><span class="line">               m-&gt;color_ = R_BNode::RED;</span><br><span class="line">               x = x-&gt;parent_;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     x-&gt;color_ = R_BNode::Black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="情况3：x的兄弟节点m为黑色，且m的异侧孩子为红色，同侧孩子为黑色"><a href="#情况3：x的兄弟节点m为黑色，且m的异侧孩子为红色，同侧孩子为黑色" class="headerlink" title="情况3：x的兄弟节点m为黑色，且m的异侧孩子为红色，同侧孩子为黑色"></a>情况3：x的兄弟节点m为黑色，且m的异侧孩子为红色，同侧孩子为黑色</h3><p>此时交换m与异侧孩子的颜色，并进行旋转。使m的异侧孩子成为x新的兄弟节点，m成为新m的同侧孩子。这样就转化成了情况4。</p><p><img src="https://img.xilong.site/20210923/delete3.png" alt="delete3"></p><p>实现为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_BTree::DeleteFixup</span><span class="params">(R_BNode *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != root_ &amp;&amp; x-&gt;color_ != R_BNode::RED) &#123;</span><br><span class="line">       <span class="keyword">if</span> (x == x-&gt;parent_-&gt;left_) &#123;</span><br><span class="line">           <span class="keyword">auto</span> m = x-&gt;parent_-&gt;right_;</span><br><span class="line">           <span class="comment">// case 1</span></span><br><span class="line">           <span class="keyword">if</span> (m-&gt;color_ == R_BNode::RED) &#123;</span><br><span class="line">               m-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">               x-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">               <span class="built_in">LeftRotate</span>(x-&gt;parent_);</span><br><span class="line">               m = x-parent_-&gt;right_;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// case 2</span></span><br><span class="line">           <span class="keyword">if</span> (m-&gt;left_-&gt;color_ == R_BNode::BLACK</span><br><span class="line">               &amp;&amp; m-&gt;right_-&gt;color_ == R_BNode::BLACK) &#123;</span><br><span class="line">               m-&gt;color_ = R_BNode::RED;</span><br><span class="line">               x = x-&gt;parent_;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m-&gt;left_-&gt;color_ == R_BNode::RED</span><br><span class="line">                     &amp;&amp; m-&gt;right_color_ == R_BNode::BLACK) &#123;</span><br><span class="line">               <span class="comment">// case 3</span></span><br><span class="line">               m-&gt;color_ = R_BNode::RED;</span><br><span class="line">               m-&gt;left_-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">               <span class="built_in">RightRotate</span>(m);</span><br><span class="line">               m = x-&gt;parent_-&gt;right_;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">auto</span> m = x-&gt;parent_-&gt;left_;</span><br><span class="line">           <span class="comment">// case 1</span></span><br><span class="line">           <span class="keyword">if</span> (m-&gt;color_ == R_BNode::RED) &#123;</span><br><span class="line">               m-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">               x-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">               <span class="built_in">RightRotate</span>(x-&gt;parent_);</span><br><span class="line">               m = x-parent_-&gt;left_;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// case 2</span></span><br><span class="line">           <span class="keyword">if</span> (m-&gt;left_-&gt;color_ == R_BNode::BLACK</span><br><span class="line">               &amp;&amp; m-&gt;right_-&gt;color_ == R_BNode::BLACK) &#123;</span><br><span class="line">               m-&gt;color_ = R_BNode::RED;</span><br><span class="line">               x = x-&gt;parent_;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m-&gt;right_-&gt;color_ == R_BNode::RED</span><br><span class="line">                     &amp;&amp; m-&gt;left_color_ == R_BNode::BLACK) &#123;</span><br><span class="line">               <span class="comment">// case 3</span></span><br><span class="line">               m-&gt;color_ = R_BNode::RED;</span><br><span class="line">               m-&gt;right_-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">               <span class="built_in">LeftRotate</span>(m);</span><br><span class="line">               m = x-&gt;parent_-&gt;left_;</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     x-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="情况4：x的兄弟节点为黑色，且m的同侧孩子为红色。"><a href="#情况4：x的兄弟节点为黑色，且m的同侧孩子为红色。" class="headerlink" title="情况4：x的兄弟节点为黑色，且m的同侧孩子为红色。"></a>情况4：x的兄弟节点为黑色，且m的同侧孩子为红色。</h3><p>使m为父节点的颜色，并将父节点与m的同侧孩子设为黑色。对父节点进行旋转，使m成为新的取代父节点的位置，并设x为根节点。即可修复红黑树。</p><p><img src="https://img.xilong.site/20210923/delete4.png" alt="delete4"></p><p>此时得出了最终实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_BTree::DeleteFixup</span><span class="params">(R_BNode *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != root_ &amp;&amp; x-&gt;color_ != R_BNode::RED) &#123;</span><br><span class="line">       <span class="keyword">if</span> (x == x-&gt;parent_-&gt;left_) &#123;</span><br><span class="line">           <span class="keyword">auto</span> m = x-&gt;parent_-&gt;right_;</span><br><span class="line">           <span class="comment">// case 1</span></span><br><span class="line">           <span class="keyword">if</span> (m-&gt;color_ == R_BNode::RED) &#123;</span><br><span class="line">               m-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">               x-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">               <span class="built_in">LeftRotate</span>(x-&gt;parent_);</span><br><span class="line">               m = x-&gt;parent_-&gt;right_;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// case 2</span></span><br><span class="line">           <span class="keyword">if</span> (m-&gt;left_-&gt;color_ == R_BNode::BLACK</span><br><span class="line">               &amp;&amp; m-&gt;right_-&gt;color_ == R_BNode::BLACK) &#123;</span><br><span class="line">               m-&gt;color_ = R_BNode::RED;</span><br><span class="line">               x = x-&gt;parent_;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m-&gt;left_-&gt;color_ == R_BNode::RED</span><br><span class="line">                     &amp;&amp; m-&gt;right_-&gt;color_ == R_BNode::BLACK) &#123;</span><br><span class="line">               <span class="comment">// case 3</span></span><br><span class="line">               m-&gt;color_ = R_BNode::RED;</span><br><span class="line">               m-&gt;left_-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">               <span class="built_in">RightRotate</span>(m);</span><br><span class="line">               m = x-&gt;parent_-&gt;right_;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// case 4</span></span><br><span class="line">           m-&gt;color_ = x-&gt;parent_-&gt;color_;</span><br><span class="line">           x-&gt;parent_-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">           m-&gt;right_-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">           <span class="built_in">LeftRotate</span>(x-&gt;parent_);</span><br><span class="line">           x = root_;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">auto</span> m = x-&gt;parent_-&gt;left_;</span><br><span class="line">           <span class="comment">// case 1</span></span><br><span class="line">           <span class="keyword">if</span> (m-&gt;color_ == R_BNode::RED) &#123;</span><br><span class="line">               m-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">               x-&gt;parent_-&gt;color_ = R_BNode::RED;</span><br><span class="line">               <span class="built_in">RightRotate</span>(x-&gt;parent_);</span><br><span class="line">               m = x-&gt;parent_-&gt;left_;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// case 2</span></span><br><span class="line">           <span class="keyword">if</span> (m-&gt;left_-&gt;color_ == R_BNode::BLACK</span><br><span class="line">               &amp;&amp; m-&gt;right_-&gt;color_ == R_BNode::BLACK) &#123;</span><br><span class="line">               m-&gt;color_ = R_BNode::RED;</span><br><span class="line">               x = x-&gt;parent_;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m-&gt;right_-&gt;color_ == R_BNode::RED</span><br><span class="line">                     &amp;&amp; m-&gt;left_-&gt;color_ == R_BNode::BLACK) &#123;</span><br><span class="line">               <span class="comment">// case 3</span></span><br><span class="line">               m-&gt;color_ = R_BNode::RED;</span><br><span class="line">               m-&gt;right_-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">               <span class="built_in">LeftRotate</span>(m);</span><br><span class="line">               m = x-&gt;parent_-&gt;left_;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// case 4</span></span><br><span class="line">           m-&gt;color_ = x-&gt;parent_-&gt;color_;</span><br><span class="line">           x-&gt;parent_-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">           m-&gt;left_-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">           <span class="built_in">LeftRotate</span>(x-&gt;parent_);</span><br><span class="line">           x = root_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     x-&gt;color_ = R_BNode::BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>红黑树是一种特殊的二叉搜索树，因此适用二叉搜索树的所有不改变树结构的操作。而对于改变了红黑树结构的操作则需要牢记，主要分为旋转、插入和删除。</p>]]></content>
      
      
      <categories>
          
          <category> 0x00 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于C++的Java入门笔记</title>
      <link href="/zh/blog/2021/09/19/0027-Java:Getting_started_base_on_C++/"/>
      <url>/zh/blog/2021/09/19/0027-Java:Getting_started_base_on_C++/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：Java的语法和C++实在是很相似，这一方面方便了C++选手们上手Java，另一方面也使得我们在使用Java的时候总是串语法。不得不写篇文章总结一下Java的语法差异。</p></blockquote><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Java分为三个版本：SE（Standard Edition）、EE（Enterprise Edition）和ME（Micro Edition）。</p><p>Java有三个重要工具：JRE（Java Runtime Environment）、JDK（Java Development Toolkit）和JVM（Java Virtual Machine）。其中JDK是开发中使用到的工具集；JRE是运行Java程序所必需的环境，它包括了JVM和一些类库等文件。</p><p>Java程序后缀为<code>.java</code>通过将其编译为后缀<code>.class</code>的字节码文件，交由JVM运行。</p><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><p>Java是一个静态弱类型语言。即一个变量声明后就不可以改变类型，并且语言支持隐式类型转换。Java虽然是弱类型，但没有完全弱，它仅支持小类型向大类型的隐式类型转换，换言之，不存在精度丢失的问题。</p><p>同时Java中并不存在指针类型，对于大类型的处理策略是<strong>默认为引用</strong>，同时语言带有GC系统。这大大减少了程序员的心智负担，但同时也带来了深浅拷贝这样的需要留意的问题。</p><p>同C++相比，Java牺牲了不少运行效率。因此具体场所使用Java还是C++还需自行斟酌。不过这个时代需要极高性能的场所正在渐渐减少，且语言性能带来的提升很多时候比不上一个更优秀的算法带来的提升。</p><p>总体而言，Java是一门非常实用的语言，能带来更高的开发效率和更少的折磨。</p><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p>Java中的任何函数或变量都必须定义在类里，不允许出现类外的全局变量。</p><p>Java程序以一个函数签名为<code>public static void main(String args[]）&#123;&#125;</code>的函数为入口。这个函数同样要定义在一个类里。</p><h3 id="编译单元"><a href="#编译单元" class="headerlink" title="编译单元"></a>编译单元</h3><p>一个<code>.java</code>文件就是一个编译单元，每个编译单元中只能有一个<code>public</code>类。这个<code>public</code>类的名字必须与<code>.java</code>文件的名字相同。编译单元中的其它类由于不能声明为<code>public</code>，只能在编译单元内访问与使用。</p><h3 id="包-Package"><a href="#包-Package" class="headerlink" title="包(Package)"></a>包(Package)</h3><p>Java并不存在头文件源文件之分，所有类都定义在<code>.java</code>文件中。这样的结构会引发一个经典问题——命名冲突，于是Java引入了<code>包(Package)</code>的概念，同时引入了<code>import</code>关键字用以指定一个包中的类的简称。</p><p>系统中会为每个包建立文件夹，以避免文件重名。</p><p>这其实和C++的<code>namespace</code>与<code>using</code>比较相似。不过存在一些区别：</p><ol><li>包可以嵌套，但是每个包的命名空间是独立的。也就是说不存在C++中可以访问上层命名空间中的名字的情况。</li><li><code>import</code>只取<code>using</code>的声明这一层含义，并不能给类型起别名。</li></ol><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译单元开头声明，表示该编译单元属于此包</span></span><br><span class="line"><span class="keyword">package</span> name1[.name2.name3 ... .namen];</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> name1[.name2.name3 ... .classname]; <span class="comment">// 使用classname代替其全称。</span></span><br><span class="line"><span class="keyword">import</span> name1[.name2.name3 ... .*] <span class="comment">//对包内所有public类，使用类名代替全称。</span></span><br></pre></td></tr></table></figure><p>同时，由于包之间是独立的，默认包中的类将不能被其它包中的类访问。</p><h2 id="基础语法差异"><a href="#基础语法差异" class="headerlink" title="基础语法差异"></a>基础语法差异</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><code>char</code>是一个16位的Unicode字符，表示一字节长的类型叫<code>byte</code>。</p><p><code>boolean</code>类型并非数值类型，其值为<code>true</code>或<code>false</code>，不可以进行算数运算。</p><p>自动类型转换仅出现在不损失精度的运算中，大类型转小类型要使用强制类型转换，语法与C类似。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><code>&lt;&lt;</code>: 丢弃最高位，0补最低位。</p><p><code>&gt;&gt;</code>: 符号位不变，高补符号位。</p><p><code>&gt;&gt;&gt;</code>：忽略符号位，0补最高位。</p><p><code>instanceof</code>：二元中缀运算符，检测左边对象是否为右边指定类型。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p><code>default</code>：什么也不写，同一包内可见。</p><p><code>public</code>：所有包可见。</p><p><code>private</code>：同一类可见。不能修饰外部类。</p><p><code>protected</code>：同一包内所有子类skmb。不能修饰外部类。</p><p><code>static</code>：用以声明独立于类的变量与函数。不可以修饰局部变量。</p><p><code>final</code>：变量不能变、函数不能重写、类不能继承。</p><p><code>abstract</code>：声明抽象方法与抽象类，与<code>final</code>冲突，有抽象方法的类一定是抽象类。</p><p><code>synchronized</code>：同一时间仅能被一个线程访问。</p><p><code>transient</code>：使变量跳过序列化。</p><p><code>volatile</code>：用来修饰需线程同步的变量。</p><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><p>不产生任何副作用的表达式不是语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i;  <span class="comment">// 非法，表达式没有任何副作用。</span></span><br><span class="line">i++; <span class="comment">// 合法，改变了i的值。</span></span><br></pre></td></tr></table></figure><h3 id="函数-方法"><a href="#函数-方法" class="headerlink" title="函数/方法"></a>函数/方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;修饰符&gt; 返回值类型 方法名(参数) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;修饰符&gt; 类名 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 花括号后没有分号</span></span><br></pre></td></tr></table></figure><p>构造函数名称与类名相同。</p><p>析构函数统一为<code>protected void finalize() &#123;...&#125;</code>。</p><p><code>this</code>是自身的引用。<code>super</code>是直接基类的引用。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>Java作为一门面向对象语言，引入了一些特性来提供更好的面向对象支持。除了基本类型的对象外，对象一律使用<code>new</code>来声明。因为有GC机制，并不需要使用<code>delete</code>来手动释放对象。</p><p>Java中没有提供指针，为了解决类的拷贝开销过大问题，默认使用引用的方式来使用类。换言之，用<code>new</code>声明的对象都可以看作限制版的指针。传参的时候就要注意实际上传的是值还是引用。</p><p>这时就出现了一个问题，要使用引用类型的副本可以手动拷贝一份，可是要使用值类型的引用时怎么办呢？比如一个简单的交换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用C++可以使用引用与指针两种方式实现。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Java里既不能使用引用也不能使用指针，就比较棘手。只能曲线救国，将基本类型封装到引用类型里，比如一个类或者数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> fst_, <span class="keyword">int</span> snd_)</span> </span>&#123;</span><br><span class="line">        fst = fst_;</span><br><span class="line">        snd = snd_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fst;</span><br><span class="line">    <span class="keyword">int</span> snd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时可以使用Pair传递两个值并交换了。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = p.fst;</span><br><span class="line">    p.fst = p.snd;</span><br><span class="line">    p.snd = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但这样写并不如直接在Pair类里写成员函数自然。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = fst;</span><br><span class="line">        fst = snd;</span><br><span class="line">        snd = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看来传基本类型的引用基本上是一个伪需求。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组使用<code>type[] var = new type[size]</code>来声明。等号左边也可以写成C风格的<code>type var[]</code>，但不推荐。也可以使用<code>type[] var = &#123;...&#125;</code>的方式来更方便的使用。</p><p>数组提供<code>length</code>成员保存大小。</p><p>数组的一些常用操作以<code>static</code>方法的方式提供在<code>java.util.Arrays</code>类中。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p> Java不支持多继承，即一个类只能有一个父类。子类继承父类的非<code>private</code>方法。子类使用<code>extend</code>关键字继承父类。</p><p>Java中所有类都是<code>java.lang.Object</code>类的子类。</p><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><p>子类可以重写父类的函数，可以理解为所有函数都是虚函数，而<code>abstract</code>函数相当于纯虚函数。</p><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p>含有任何<code>abstract</code>函数的类或被显式声明为<code>abstract</code>的类为抽象类，抽象类不能被实例化的类。</p><p>接口使用<code>interface</code>声明，是一个抽象方法的集合。接口可以使用<code>extends</code>来继承其它接口，允许多继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[可见度] <span class="class"><span class="keyword">interface</span> [名称] [<span class="keyword">extends</span> 其它接口名] </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法，隐式指定为public abstract，同时也只能是这种类型。</span></span><br><span class="line">    <span class="comment">// 变量，隐式指定为public static final，同时只能是这种类型。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类可以通过<code>implements</code>关键字实现接口。抽象类可以不实现接口中的方法，但普通类必需全部实现。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>使用<code>try-catch-finally</code>语句块来处理异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型 变量名) &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型 变量名) &#123;</span><br><span class="line">&#125; <span class="keyword">final</span> &#123; </span><br><span class="line">&#125; <span class="comment">// catch数量大于等于1个，final是可选的，处理未被catch的类型异常。</span></span><br></pre></td></tr></table></figure><p>程序中使用<code>throw</code>抛出异常，一个可能抛出异常的函数要使用<code>throws</code>声明可能抛出的异常的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>泛型这个概念是C++的模板带来的，因此声明语法上也大差不差。但有两点不同：</p><ol><li>参数只能是类型，不能是值。</li><li>参数必需是引用类型， 不能是基础类型。</li></ol><p><strong>泛型类/接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">name</span> &lt;<span class="title">T1</span>, <span class="title">T2</span>,...,<span class="title">Tn</span>&gt; </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">name</span> &lt;<span class="title">T1</span>, <span class="title">T2</span>,...,<span class="title">Tn</span>&gt; </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">func</span><span class="params">(T obj)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>Java的泛型是使用类型擦除的方式实现的，运行时丢失所有类型信息。因此不能使用与类型有关的操作，如：转型、<code>instanceof</code>和<code>new</code>。这也意味着，泛型类无法向上转型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer ---&gt; Object</span><br><span class="line">ArrayList&lt;Integer&gt; ---&gt; List&lt;Interger&gt;</span><br><span class="line">List&lt;Integer&gt; -x--&gt; List&lt;Object&gt;</span><br></pre></td></tr></table></figure><p><code>Integer</code>继承了<code>Object</code>，可以转为<code>Object</code>。<code>ArrayList</code>继承了<code>List</code>，可以转为<code>List</code>。但<code>List&lt;Integer&gt;</code>不能转为<code>List&lt;object&gt;</code>。</p><p>因为泛型类并不存在独有的Class对象，即不存在<code>List&lt;Object&gt;.class</code>或<code>List&lt;Integer&gt;.class</code>，编译器会将两者都视为<code>List.class</code>。</p><h3 id="类型边界"><a href="#类型边界" class="headerlink" title="类型边界"></a>类型边界</h3><p>可以使用<code>extends</code>限制类型必需是某个类的子类或实现了哪些接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends A &amp; B &amp; C&gt; <span class="comment">// 可以有多个限制，使用&amp;隔开。只有第一个限制可以是类，其它的必需是接口。</span></span><br></pre></td></tr></table></figure><h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p>使用泛型类实例时可以通过通配符匹配类型，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;; <span class="comment">// 可以是任何类型</span></span><br><span class="line">List&lt;? extends A &amp; B &amp; C&gt;; <span class="comment">// 匹配A &amp; B &amp; C的子类或实现</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> S&gt; <span class="comment">// 匹配S的父类</span></span><br></pre></td></tr></table></figure><p>可以使用通配符实现向上转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; intList1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt;  numList1 = intList1; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">List&lt;? extends Integer&gt; intList2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;? extends Number&gt;  numList2 = intList2; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0x02 技术杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的Haskell（六）——惰性求值</title>
      <link href="/zh/blog/2021/09/15/0026-Re0:Haskell_06/"/>
      <url>/zh/blog/2021/09/15/0026-Re0:Haskell_06/</url>
      
        <content type="html"><![CDATA[<blockquote><p>系列第六篇，介绍惰性求值。</p></blockquote><span id="more"></span><p>经过了前几篇的折磨，是时候介绍惰性求值了。</p><h2 id="直接求值"><a href="#直接求值" class="headerlink" title="直接求值"></a>直接求值</h2><p>在讨论惰性求值之前首先来了解一下直接求值。在直接求值方式下，参数在传入函数之前就已经计算过了，传入函数的是计算结果。考虑如下函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> x y = x + <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在直接求值的语言中，<code>f 5 (29^35792)</code>会先分别计算出<code>5</code>和<code>29^35792</code>的值，然后才将这两个值传入函数中进行处理。对于我们这个函数而言，这样做显然浪费了计算<code>29^35792</code>耗费的计算资源。因为我们跟本没有使用参数<code>y</code>。</p><p>那么为什么要使用直接求值呢？一个显著的好处是直接求值可以很方便的预测处理表达式的时机，对于有副作用的语言而言，比如C++中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span> (<span class="built_in">x</span>(), <span class="built_in">y</span>());</span><br></pre></td></tr></table></figure><p>可以确保在函数<code>f</code>调用之前已经对<code>x()</code>与<code>y()</code>函数进行了处理，比如更改全局变量的值。因此我们可以使程序的行为和我们的预期相符。</p><h2 id="副作用和纯净"><a href="#副作用和纯净" class="headerlink" title="副作用和纯净"></a>副作用和纯净</h2><p>所谓的副作用就是指表达式计算时对该表达式之外的事物造成了影响。这里的关键是对外界事物的影响是时间敏感的。比如：</p><ul><li>更改全局变量：当全局变量的值改变时可能会对其它表达式的结果造成影响。</li><li>在屏幕上打印内容：需要一个确定的打印顺序。</li><li>读取文件或网络内容：文件中的内容会影响表达式的结果。</li></ul><p>就像我们之前看到的，惰性求值使得确定事情何时发生变得很难。因此如果引入副作用将会使得程序非常不直观。这就是Haskell没有副作用的历史原因，当时设计者想设计一门惰性求值语言，但他很快意识到只有禁止表达式产生副作用才可能实现。</p><p>但是没有副作用的语言几乎没有什么用。你能做的唯一一件事就是使用你的程序去翻译和计算表达式。你不能获取任何用户输入或是读写文件，也不能在屏幕上输出任何东西。Haskell的设计者面对的挑战是设计一种严格且规范的方式去允许一部分副作用，并且不能影响到基础语言部分的纯净。他们最终搞出来一个叫做<code>IO monad</code>的东西，这个我们之后再说。</p><h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><p>现在我们已经知道了什么是直接求值，是时候看看惰性求值长什么样了。在惰性求值方式下，对函数参数的计算会尽可能地拖延：只有在必须用到它们的值的时候才计算它们。当向函数传递一个参数的时候，它们被整个打包（这个包称为thunk），以未计算表达式的方式传入。这过程中不作任何实际处理。</p><p>举例来说，计算<code>f 5 (29^35792)</code>时，第二个参数被简单的打包成thunk并且不做任何实际的计算，并且<code>f</code>会被立刻调用。因为<code>f</code>实际上根本没用到第二个参数，这个thunk会被GC系统直接抛弃。</p><h2 id="模式匹配驱动计算"><a href="#模式匹配驱动计算" class="headerlink" title="模式匹配驱动计算"></a>模式匹配驱动计算</h2><p>所以一个表达式什么时候才必须进行计算呢？一个关键是看它什么时候被使用，但实际上这 并不是最重要的区别。考虑下面的例子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f1</span> :: <span class="type">Maybe</span> a -&gt; [<span class="type">Maybe</span> a]</span><br><span class="line"><span class="title">f1</span> m = [m, m]</span><br><span class="line"></span><br><span class="line"><span class="title">f2</span> :: <span class="type">Maybe</span> a -&gt; [a]</span><br><span class="line"><span class="title">f2</span> <span class="type">Nothing</span> = []</span><br><span class="line"><span class="title">f2</span> <span class="type">Just</span> x = [x]</span><br></pre></td></tr></table></figure><p>这里的<code>f1</code>与<code>f2</code>都使用了它们的参数，但其中有很大的区别。<code>f1</code>并不在乎参数是个什么东西，只要把它整个地丢进列表里就行了。而<code>f2</code>就必须知道参数的值，来决定如何处理参数。</p><p>另一个关键是，thunk只会被计算到足够使用的程度，比如说<code>safeHead [3 ^ 500, 49]</code>会得到结果<code>Just (3^500)</code>，而不会接着计算<code>3 ^ 500</code>（属实够懒的……）。至于这个<code>3 ^ 500</code>之后会不会被计算，取决于这个thunk的使用方式。</p><p>一个方便记忆的口诀就是本节标题：<strong>模式匹配驱动计算</strong>。两个重点：</p><ul><li>表达式仅在被模式匹配时计算。</li><li>表达式仅计算到足够当前模式使用的程度。</li></ul><p>来看一个更有趣的例子，<code>take 3 (repeat 7)</code>。作为参考，<code>take</code>和<code>repeat</code>的定义如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">repeat</span> a -&gt; [a]</span><br><span class="line"><span class="title">repeat</span> x = x : repeat x</span><br><span class="line"></span><br><span class="line"><span class="title">take</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">take</span> n _ | n &lt;= <span class="number">0</span> = []</span><br><span class="line"><span class="title">take</span> _ [] = []</span><br><span class="line"><span class="title">take</span> n (x:xs) = x : take (n - <span class="number">1</span>) xs</span><br></pre></td></tr></table></figure><p>来一步一步地考虑这个式子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">take</span> <span class="number">3</span> (repeat <span class="number">7</span>) <span class="comment">-- 首先对take的第一个模式进行匹配，3 &lt;= 0为False，因此第一个模式不匹配，此时尝试匹配第二模式，这里需要知道第二个参数是不是空列表，因此我们必须展开repeat 7。但我们是惰性求值，所以先展开一步看看。</span></span><br><span class="line"><span class="title">take</span> <span class="number">3</span> (<span class="number">7</span> : repeat <span class="number">7</span>) <span class="comment">-- 这里已经足够看出第二个参数不是空列表了，所以不用继续展开，尝试匹配第三个模式，匹配。因此使用第三个表达式进行处理。注意（3-1）还不需要计算。</span></span><br><span class="line"><span class="number">7</span> : take (<span class="number">3</span> - <span class="number">1</span>) (repeat <span class="number">7</span>) <span class="comment">-- 尝试对第一个模式进行匹配，判断(3 - 1) &lt;= 0时需要对（3 - 1）进行计算。</span></span><br><span class="line"><span class="number">7</span> : take <span class="number">2</span> (repeat <span class="number">7</span>) <span class="comment">-- 2 &lt;= 0为False，试图匹配第二个模式，过程不再赘述。</span></span><br><span class="line"><span class="number">7</span> : take <span class="number">2</span> (<span class="number">7</span> : repeat <span class="number">7</span>)</span><br><span class="line"><span class="number">7</span> : <span class="number">7</span> : take (<span class="number">2</span> - <span class="number">1</span>) (repeat <span class="number">7</span>)</span><br><span class="line"><span class="number">7</span> : <span class="number">7</span> : take <span class="number">1</span> (repeat <span class="number">7</span>)</span><br><span class="line"><span class="number">7</span> : <span class="number">7</span> : take <span class="number">1</span> (<span class="number">7</span> : repeat <span class="number">7</span>)</span><br><span class="line"><span class="number">7</span> : <span class="number">7</span> : <span class="number">7</span> : take (<span class="number">1</span> - <span class="number">1</span>) (repeat <span class="number">7</span>)</span><br><span class="line"><span class="number">7</span> : <span class="number">7</span> : <span class="number">7</span> : take <span class="number">0</span> (repeat <span class="number">7</span>) <span class="comment">-- 0 &lt;= 0为True，匹配第一个模式。</span></span><br><span class="line"><span class="number">7</span> : <span class="number">7</span> : <span class="number">7</span> : []</span><br></pre></td></tr></table></figure><p>注意，虽然逻辑上一个表达示是这样步步展开的，但大多数Haskell的编译器实现会使用一些更有效率的方式进行处理，以提高性能。</p><h2 id="惰性求值带来的影响"><a href="#惰性求值带来的影响" class="headerlink" title="惰性求值带来的影响"></a>惰性求值带来的影响</h2><p>惰性求值带来了一些有趣、无处不在而又不甚明显的影响，试说明几例。 </p><h3 id="纯净"><a href="#纯净" class="headerlink" title="纯净"></a>纯净</h3><p>正如之前所说，惰性求值特性迫使了我们选择纯净（除非你不想要程序员活了）。</p><h3 id="理解空间消耗"><a href="#理解空间消耗" class="headerlink" title="理解空间消耗"></a>理解空间消耗</h3><p>惰性求值也有其缺点，其中之一就是很难估算程序对空间资源的消耗。考虑下例：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给出标准库foldl定义作为参考</span></span><br><span class="line"><span class="title">foldl</span> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="title">foldl</span> _ z []  = z</span><br><span class="line"><span class="title">foldl</span> f z (x:xs) = foldl f (f z x) xs</span><br></pre></td></tr></table></figure><p>来看看如何处理<code>foldl (+) 0 [1,2,3]</code>：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldl</span> (+) <span class="number">0</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">= foldl (+) (<span class="number">0</span>+<span class="number">1</span>) [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">= foldl (+) ((<span class="number">0</span>+<span class="number">1</span>)+<span class="number">2</span>) [<span class="number">3</span>]</span><br><span class="line">= foldl (+) (((<span class="number">0</span>+<span class="number">1</span>)+<span class="number">2</span>)+<span class="number">3</span>) []</span><br><span class="line">= (((<span class="number">0</span>+<span class="number">1</span>)+<span class="number">2</span>)+<span class="number">3</span>)</span><br><span class="line">= ((<span class="number">1</span>+<span class="number">2</span>)+<span class="number">3</span>)</span><br><span class="line">= (<span class="number">3</span>+<span class="number">3</span>)</span><br><span class="line">= <span class="number">6</span></span><br></pre></td></tr></table></figure><p>这个式子一开始被处理为一个大的thunk<code>(((0+1)+2)+3)</code>并且没有进行实际上的运算，然后最终才由thunk计算出一个数值。这里至少存在两个问题，其一是将一个列表转换成一个类似列表的东西并没有任何价值。其二是处理这样的thunk将会消耗很多空间资源，比如在计算<code>1+2</code>时要先将<code>3</code>推入栈中。在这样的小例子中可能看不出什么消耗，但在处理大列表时这样的空间消耗是非常巨大的。</p><p>这个问题的解决方案是使用<code>foldl&#39;</code>，它是一个更接近直接求值的<code>foldl</code>实现，因此不会构建出一个巨大的thunk：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldl&#x27;</span> (+) <span class="number">0</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">= foldl&#x27; (+) (<span class="number">0</span> + <span class="number">1</span>) [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">= foldl&#x27; (+) <span class="number">1</span> [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">= foldl&#x27; (+) (<span class="number">1</span> + <span class="number">2</span>) [<span class="number">3</span>]</span><br><span class="line">= foldl&#x27; (+) <span class="number">3</span> [<span class="number">3</span>]</span><br><span class="line">= foldl&#x27; (+) (<span class="number">3</span> + <span class="number">3</span>) []</span><br><span class="line">= foldl&#x27; (+) <span class="number">6</span> []</span><br><span class="line">= <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="短路运算符"><a href="#短路运算符" class="headerlink" title="短路运算符"></a>短路运算符</h3><p>对C++和Java比较熟悉的话，一定知道其中<code>&amp;&amp;</code>和<code>||</code>运算符的短路现象。对于这样的直接求值语言而言，函数的参数在传入之前应该先计算。显然短路是不符合这个特性的，因此短路其实是这些语言的一个特例。</p><p>而对于Haskell，短路就显得非常自然了，比如<code>(&amp;&amp;)</code>函数定义如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&amp;&amp;) :: <span class="type">Bool</span> -&gt; <span class="type">Bool</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="type">True</span>  &amp;&amp; x = x</span><br><span class="line"><span class="type">False</span> &amp;&amp; _ = <span class="type">False</span></span><br></pre></td></tr></table></figure><p>同时也有一个不短路的版本<code>&amp;&amp;!</code>，定义为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(&amp;&amp;!) :: <span class="type">Bool</span> -&gt; <span class="type">Bool</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="type">True</span>  &amp;&amp;! <span class="type">True</span>  = <span class="type">True</span></span><br><span class="line"><span class="type">True</span>  &amp;&amp;! <span class="type">False</span> = <span class="type">True</span></span><br><span class="line"><span class="type">False</span> &amp;&amp;! <span class="type">True</span>  = <span class="type">True</span></span><br><span class="line"><span class="type">False</span> &amp;&amp;! <span class="type">False</span> = <span class="type">True</span></span><br></pre></td></tr></table></figure><h3 id="用户定义的控制结构"><a href="#用户定义的控制结构" class="headerlink" title="用户定义的控制结构"></a>用户定义的控制结构</h3><p>基于与上面的短路同样的思路，我们可以定义自己的用户控制结构。大多数语言有内置的<code>if</code>语句，而在Haskell中可以简单的将<code>if</code>定义为一个函数，定义如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">if&#x27;</span> <span class="type">Bool</span> -&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">if&#x27;</span> <span class="type">True</span>  x _ = x</span><br><span class="line"><span class="title">if&#x27;</span> <span class="type">False</span> _ y = y</span><br></pre></td></tr></table></figure><p>然而Haskell还是存在一个内置的<code>if</code>语句，可能是语言设计者觉得大家需要吧。不过<code>if</code>在Haskell中并没有许多用处，最好还是使用模式匹配和哨卫。</p><p>我们也能定议其它的控制结构，这些会在讨论<code>monad</code>时展开。</p><h3 id="无限数据结构"><a href="#无限数据结构" class="headerlink" title="无限数据结构"></a>无限数据结构</h3><p>由于惰性求值特性，我们可以定义无限的数据结构，比如<code>repeat 7</code>这样的无限列表，或是一个完整的记录状态空间的树（比如棋类游戏）。由于我们只会计算使用到的部分，这样的定义并不会带来额外的负担。</p><h3 id="管道-全麦编程"><a href="#管道-全麦编程" class="headerlink" title="管道/全麦编程"></a>管道/全麦编程</h3><p>之前我们说过使用管道的形式组合小函数成获得更好的内存性能，现在可以解释为什么了。因为管道中的每个小函数的值在传递给下一个函数时都会被计算出来。因此对内存的浪费局限在了一个小的范围内。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>惰性求值给我们带来了更方便的动态规划技术。通常我们使用动态规划时要小心考虑状态表的求值顺序，如果顺序错了就将得到一个完全错误的结果。</p><p>然而，我们可以使用惰性求值特性来让Haskell运行时为我们选择求值顺序。比如对于经典的0-1背包问题，我们可以这样解决：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Array</span><br><span class="line"></span><br><span class="line"><span class="title">knapsack01</span> :: [<span class="type">Double</span>]   <span class="comment">--物品价值</span></span><br><span class="line">           -&gt; [<span class="type">Integer</span>]  <span class="comment">--物品重量</span></span><br><span class="line">           -&gt; <span class="type">Integer</span>    <span class="comment">--背包载量</span></span><br><span class="line">           -&gt; <span class="type">Double</span>     <span class="comment">--最大价值</span></span><br><span class="line"><span class="title">knaspsack01</span> vs ws maxW = m!(numItems - <span class="number">1</span>, maxW)</span><br><span class="line">    <span class="keyword">where</span> numItems = length vs</span><br><span class="line">          m = array ((<span class="number">-1</span>, <span class="number">0</span>), (numItems - <span class="number">1</span>, maxW)) $</span><br><span class="line">                [((<span class="number">-1</span>, w), <span class="number">0</span>) | w &lt;- [<span class="number">0</span> .. maxW]] ++</span><br><span class="line">                [((i, <span class="number">0</span>), <span class="number">0</span>) | i &lt;- [<span class="number">0</span> .. numItems - <span class="number">1</span>]] ++</span><br><span class="line">                [((i, w), best)</span><br><span class="line">                    | i &lt;- [<span class="number">0</span> .. numItems - <span class="number">1</span>]</span><br><span class="line">                    , w &lt;- [<span class="number">1</span> .. maxW]</span><br><span class="line">                    , <span class="keyword">let</span> best</span><br><span class="line">                           | ws!!i &gt; w = m!(i - <span class="number">1</span>, w)</span><br><span class="line">                           | otherwise = max (m!(i - <span class="number">1</span>, w))</span><br><span class="line">                                          (m!(i - <span class="number">1</span>, w - ws!!i) + vs!!i)</span><br><span class="line">                ]</span><br></pre></td></tr></table></figure><p>为了理解这个程序，首先解释一下<code>array</code>，其作用为封装一个指定范围内索引到值的映射列表，并提供运算符<code>!</code>实现方便的<code>k-v</code>映射，用法为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- array key范围 映射列表</span></span><br><span class="line"><span class="comment">-- array (min, max) [(index, value)]</span></span><br><span class="line"><span class="title">array</span> :: <span class="type">Ix</span> i =&gt; (i, i) -&gt; [(i, e)] -&gt; <span class="type">Array</span> i e</span><br><span class="line"><span class="comment">-- 如下例生成一个索引范围从1到10的映射，每个索引对应的值为索引值+1</span></span><br><span class="line"><span class="title">a</span> = array (<span class="number">1</span>, <span class="number">10</span>) [(i, i + <span class="number">1</span>) | i &lt;- [<span class="number">1.</span><span class="number">.10</span>]]</span><br><span class="line"><span class="comment">-- 取该映射中的一个value时，使用array！key的方式，如</span></span><br><span class="line"><span class="title">a</span>!<span class="number">1</span> == <span class="number">1</span></span><br><span class="line"><span class="comment">-- 似乎等效于直接对列表进行如下操作</span></span><br><span class="line"><span class="title">l</span> = [(i, i + <span class="number">1</span>) | i &lt;- [<span class="number">1.</span><span class="number">.10</span>]]</span><br><span class="line"><span class="title">snd</span> $ l!!<span class="number">1</span> == <span class="number">1</span></span><br></pre></td></tr></table></figure><p>再回顾一下0-1背包问题，问题描述为:</p><blockquote><p>给定n个物品与一个最大载重为maxW的背包。每个物品的重量w与价值v各不相同，可以选定任意物品装入背包，但背包中物品重量总和不可超过背包的最大载重。求背包最多可以装入多少价值的物品。</p></blockquote><p>而解决思路可以概括为：</p><blockquote><p>maxV(i, w)视作前i个物品在限重w时的最大价值。此时，如果没有将第i个物品加入背包，则其值等于maxV(i - 1, w)；如果将第i个物品加入了背包，其值则等于maxV(i - 1, w - ws[i]) + vs[i]。因此，只要选择两种情况下值比较大的作为maxV(i,w)的值就可以确保这个值是最优解。</p><p>同时要注意，如果当前物品价值超过了背包最大载重，则只有不加入背包一个选择。</p></blockquote><p>现在来逐步解析这个程序：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Array</span><br><span class="line"></span><br><span class="line"><span class="title">knapsack01</span> :: [<span class="type">Double</span>]   <span class="comment">--物品价值</span></span><br><span class="line">           -&gt; [<span class="type">Integer</span>]  <span class="comment">--物品重量</span></span><br><span class="line">           -&gt; <span class="type">Integer</span>    <span class="comment">--背包载量</span></span><br><span class="line">           -&gt; <span class="type">Double</span>     <span class="comment">--最大价值</span></span><br><span class="line"><span class="comment">-- 我们知道了m是一个Array类型，!运算可以取其对应索引的值</span></span><br><span class="line"><span class="comment">-- m (i, w)这个形式即是之前所说的maxV(i,w)，求前n个物品的在限重w下的最大价值</span></span><br><span class="line"><span class="comment">-- 这里numItems - 1是因为数组下标从0开始，第一个物品对应的i值为0</span></span><br><span class="line"><span class="title">knaspsack01</span> vs ws maxW = m!(numItems - <span class="number">1</span>, maxW)</span><br><span class="line">    <span class="keyword">where</span> numItems = length vs</span><br><span class="line">          <span class="comment">-- 这里构建一个二维数组作状态表</span></span><br><span class="line">          <span class="comment">-- 索引范围是(-1, 0)到(numItems - 1, maxW)</span></span><br><span class="line">          m = array ((<span class="number">-1</span>, <span class="number">0</span>), (numItems - <span class="number">1</span>, maxW)) $</span><br><span class="line">                <span class="comment">-- 对边界条件初始化，所有0个物品与载重为0是情况取值都为0</span></span><br><span class="line">                [((<span class="number">-1</span>, w), <span class="number">0</span>) | w &lt;- [<span class="number">0</span> .. maxW]] ++</span><br><span class="line">                [((i, <span class="number">0</span>), <span class="number">0</span>) | i &lt;- [<span class="number">0</span> .. numItems - <span class="number">1</span>]] ++</span><br><span class="line">                <span class="comment">-- 定义一般情况的映射关系</span></span><br><span class="line">                [((i, w), best)</span><br><span class="line">                    | i &lt;- [<span class="number">0</span> .. numItems - <span class="number">1</span>]</span><br><span class="line">                    , w &lt;- [<span class="number">1</span> .. maxW]</span><br><span class="line">                    <span class="comment">-- 这里就是上面说的对两种情况的比较</span></span><br><span class="line">                    , <span class="keyword">let</span> best</span><br><span class="line">                           | ws!!i &gt; w = m!(i - <span class="number">1</span>, w)</span><br><span class="line">                           | otherwise = max (m!(i - <span class="number">1</span>, w))</span><br><span class="line">                                          (m!(i - <span class="number">1</span>, w - ws!!i) + vs!!i)</span><br><span class="line">                ]</span><br></pre></td></tr></table></figure><p>这样看除了语法默生一点外似乎并没有什么太特别的地方，为了对比，给出这个问题的C++实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">kanpsack01</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">double</span>&gt; &amp;vs, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;ws</span></span></span><br><span class="line"><span class="params"><span class="function">                , <span class="keyword">int</span> maxW)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> numItems = vs.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留出物品数与载重为0的情况所需空间</span></span><br><span class="line">    <span class="keyword">auto</span> m = <span class="built_in">vector</span>(numItems + <span class="number">1</span>, vector&lt;<span class="keyword">double</span>&gt;(maxW + <span class="number">1</span>， <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numItems; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= maxW; ++w) &#123;</span><br><span class="line">            <span class="keyword">auto</span> unadd = m[i - <span class="number">1</span>][w];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于物品数量从1开始，物品属性下标从0开始，当前物品索引应为i-1</span></span><br><span class="line">            <span class="keyword">auto</span> index = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ws[index] &gt; w) &#123;</span><br><span class="line">                m[i][w] = unadd;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> added = m[i - <span class="number">1</span>][w - ws[index]] + vs[index];</span><br><span class="line">            m[i][w] = (added &gt; unadd) ? added : unadd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m[numItems][maxW];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>亲自动手写出这两个程序，就会发现C++程序要格外地考虑状态表的求值顺序。另一方面，C++程序在运行时要浪费许多计算资源在可能根本没用到的状态上（然而还是比较快）。而Haskell在这些方面的心智负担要小得多。</p>]]></content>
      
      
      <categories>
          
          <category> 0x03 从零开始的Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的Haskell（五）——更多多态与类型类</title>
      <link href="/zh/blog/2021/09/10/0025-Re0:Haskell_05/"/>
      <url>/zh/blog/2021/09/10/0025-Re0:Haskell_05/</url>
      
        <content type="html"><![CDATA[<blockquote><p>系列第五篇，介绍更强的多态性和类型类。</p></blockquote><span id="more"></span><p>Haskell关于多态性的一个广为人知的特点是参数多态，即一个多态函数对任何类型的输入都应该有一个一致的行为。这个特性导致了许多有趣的隐患，对程序开发者和多态函数的使用者皆有影响。</p><h2 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h2><p>考虑如下类型：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">a</span> -&gt; a -&gt; a</span><br></pre></td></tr></table></figure><p>记住<code>a</code>是一个能代表任何类型的类型变量。哪些函数是这种类型？下面这个函数怎么样？</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: a -&gt; a -&gt; a</span><br><span class="line"><span class="title">f</span> x y = x &amp;&amp; y</span><br></pre></td></tr></table></figure><p>这个函数是无法工作的，即使它符合语法。因为无法通过类型检查。我们可以获取以下报错信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">• Couldn&#x27;t match expected type ‘Bool’ with actual type ‘a’</span><br><span class="line">  ‘a’ is a rigid type variable bound by</span><br><span class="line">    the type signature for:</span><br><span class="line">      f :: forall a. a -&gt; a -&gt; a</span><br><span class="line">    at test.hs:1:1-12</span><br><span class="line">• In the first argument of ‘(&amp;&amp;)’, namely ‘x’</span><br><span class="line">  In the expression: x &amp;&amp; y</span><br><span class="line">  In an equation for ‘f’: f x y = x &amp;&amp; y</span><br></pre></td></tr></table></figure><p>无法工作的原因是多态函数的调用者可以选择类型，而这个我们——函数的实现者——已经选择了一个特定的类型（Bool），但我们仍可能接收到一个<code>String</code>，或<code>Int</code>甚至是一个用户自定义类型。因此这个函数无法工作，换言之，你可以将类型声明视为一个保证，<code>a-&gt;a-&gt;a</code>保证这个函数无论接收了什么类型的参数都可以正常工作。</p><p>为了处理这种情况，我们或许为想到类似这样的处理方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f a1 a2 = case (typeOf a1) of</span><br><span class="line">   Int  -&gt; a1 + a2</span><br><span class="line">   Bool -&gt; a1 &amp;&amp; a2</span><br><span class="line">   _    -&gt; a1</span><br></pre></td></tr></table></figure><p>这里<code>f</code>为特定类型定义特定的行为，我们可以使用C++实现出一个这样的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::is_same;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">f</span><span class="params">(T a1, T a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_same&lt;T, <span class="keyword">int</span>&gt;::value) &#123;</span><br><span class="line">        <span class="keyword">return</span> a1 + a2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_same&lt;T, <span class="keyword">bool</span>&gt;::value) &#123;</span><br><span class="line">        <span class="keyword">return</span> a1 &amp;&amp; a2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="literal">true</span>, <span class="literal">false</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">2.1</span>, <span class="number">3.0</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果为： 5 0 2.1</span></span><br></pre></td></tr></table></figure><p>但这种方式在Haskell中是行不通的，Haskell并没有类似<code>is_same</code>的类型检查函数，这主要是因为Haskell是一种静态强类型语言，在通过编译期类型检查后Haskell就不再保留任何类型信息了。同时我们即将看到一个更好的理由。</p><p>C++与Java中对多态的支持主要是通过泛型提供的，而泛型编程这一思想正是受到Haskell的启发而诞生的。言归正传，什么样的函数可以是<code>a -&gt; a -&gt; a</code>类型的？其实只有两个函数可以：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f1</span> :: a -&gt; a -&gt; a</span><br><span class="line"><span class="title">f1</span> x y = x</span><br><span class="line"></span><br><span class="line"><span class="title">f2</span> :: a -&gt; a -&gt; a</span><br><span class="line"><span class="title">f2</span> x y = y</span><br></pre></td></tr></table></figure><p>来做一个参数化游戏！考虑以下的多态类型，确定每种类型可能具有的行为方式。</p><ul><li><p><code>a -&gt; a</code></p><p>这类型的函数仅可能是接受一个参数并返回参数本身的函数。</p></li><li><p><code>a -&gt; b</code></p><p>这类型的函数很难写出来，因为它的含义不是“接受一个任意类型的参数并<strong>任意返回一个类型</strong>的值”，而是“接受一个任意类型的参数并<strong>返回一个任意类型</strong>的值”。也就是说这个返回值必须能被视作任意类型。</p><p>可能只有<code>f _ = undefined</code>与<code>f x = f x</code>符合这个要求。</p></li><li><p><code>a -&gt; b -&gt; a</code></p><p>这个函数可以是一个返回第一个参数并抛弃第二个参数的的函数，如<code>const</code>。</p></li><li><p><code>[a] -&gt; [a]</code></p><p>操作列表但不操作元素的函数皆可，比如<code>f xs = [head xs]</code>。</p></li><li><p><code>(b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code></p><p><code>f g h = \x -&gt; g(h x)</code>，即<code>.</code>运算符。也就是对函数进行操作，但不对具体类型进行操作即可。</p></li><li><p><code>(a -&gt; a) -&gt; a -&gt; a</code></p><p>由于函数的返回类型和参数类型相同，符合要求的函数可以是一个自已定义自己的函数，如：<code>f = f</code>。</p></li></ul><p>经过这几个例子的思考，你可能会发现，想要实现多态性，就不要对元素进行任何操作。因为你要接受一个任意类型的参数，而无论什么操作，总会有不支持的类型。这并不只是一个约束，同时是一个非常强大的保护。这样严格的类型系统使得函数的使用者可以更放心的调用函数，同时也使得一个函数的类型说明包含了足够大致了解一个函数的信息。</p><p>比如你看到一个<code>a -&gt; a</code>类型的函数就可以肯定这个函数接受任意接收一个类型的值并返回一个同类型的值，而无需担心其它影响。而一个函数签名为<code>T func(T)</code>的C++函数则无法提供如此担保，你可能会担心这个函数对全局状态产生影响，或是传入的类型不对导致程序崩溃。</p><p>等等，既然如此，<code>+</code>是怎么实现的？对<code>Integer</code>的加法和对<code>Double</code>的加法完全是两回事，难道不需要判断类型吗？事实上确实不需要判断类型，但也并非什么魔法，看一下<code>+</code>的定义：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+) :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure><p>又见<code>=&gt;</code>，还有前面看起来像一个ADT的奇怪符号<code>Num a</code>。还有其它几个函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(==) :: <span class="type">Eq</span> a   =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">(&lt;)  :: <span class="type">Ord</span> a  =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">show</span> :: <span class="type">Show</span> a =&gt; a -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure><p>所以这些符号是什么意思？</p><h2 id="类型类"><a href="#类型类" class="headerlink" title="类型类"></a>类型类</h2><p>揭晓答案的时候到了，<code>Num</code>、<code>Eq</code>、<code>Ord</code>和<code>Show</code>都是类型类，并且使用了类型类的函数称为“类型类多态”。类型类是对函数接受的类型的约束，它表示定义了指定操作的类型的集合。同时类型类多态函数仅为符合类型类定义的类型工作。</p><p>通俗点说，C++等语言中的函数无论什么参数都得先请进来看看，不合适再请出去，或者一个想不开就崩溃了。而Haskell的函数做为一等公民比较霸道，可以事先对参数类型作一个要求，并且让那些达不到要求的参数爬。这个要求就是类型类，例如<code>Eq</code>的定义如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span></span><br><span class="line">  (==) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">  (/=) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>这个定义可以这么理解：一个接受一个参数的类型类<code>Eq</code>，符合<code>Eq</code>要求的类型必须定义两个操作：<code>==</code>和<code>/=</code>。比如要使<code>Int</code>成为<code>Eq</code>的实例，就必须定义函数<code>(==) :: Int -&gt; Int -&gt; Bool</code>和<code>(/=) :: Int -&gt; Int -&gt; Bool</code>。再看看<code>(==)</code>的定义：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(==) :: <span class="type">Eq</span> a =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>这个定义理解为：一个类型如果是<code>Eq</code>的实例，那么对两个参数进行比较并返回比较结果，如果参数不是<code>Eq</code>的实例则解释期报错。一个普通多态函数保证对任何类型生效，而一个类型类多态函数仅保证对类型类实例类生效。</p><p>需要注意的是，当调用<code>(==)</code>时，编译器根据类型选择使用哪个实例。这个机制与C++中的多态比较类似，即根据类型选择合适的实例。</p><p>为了更好的掌握类型类的概念，我们来构建一个ADT并使其成为<code>Eq</code>的实例。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Foo</span> = <span class="type">F</span> <span class="type">Int</span> | <span class="type">G</span> <span class="type">Char</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> <span class="type">Foo</span> <span class="keyword">where</span></span></span><br><span class="line">  (<span class="type">F</span> i1) == (<span class="type">F</span> i2) = i1 == i2</span><br><span class="line">  (<span class="type">G</span> c1) == (<span class="type">G</span> c2) = c1 == c2</span><br><span class="line">  _ == _ = <span class="type">False</span></span><br><span class="line">  </span><br><span class="line">  foo1 /= foo2 = not (foo1 == foo2)</span><br></pre></td></tr></table></figure><p>定义了<code>==</code>还要定义<code>/=</code>。我们可以修改一下<code>Eq</code>的定义，来为<code>/=</code>定义一个默认实现模式。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span></span><br><span class="line">  (==) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">  (/=) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">  x /= y = not (x == y)</span><br></pre></td></tr></table></figure><p>这样就可以仅定义<code>==</code>，由默认实现模式去生成<code>/=</code>的定义。实际上<code>Eq</code>的定义如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span></span><br><span class="line">  (==), (/=) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">  x == y = not (x /= y)</span><br><span class="line">  x /= y = x == y</span><br></pre></td></tr></table></figure><p>这个定义可以使我们只用定义<code>==</code>与<code>/=</code>中的任意一个，但要小心，如果我们一个也没定义就会导致一个无限循环。</p><p>对于<code>Eq</code>与其它几个比较特殊的类型类，GHC可以为我们自动生成它们的实例，就像我们之前使用过的那样：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Foo&#x27;</span> = <span class="type">F&#x27;</span> <span class="type">Int</span> | <span class="type">G&#x27;</span> <span class="type">Char</span></span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>)</span><br></pre></td></tr></table></figure><h3 id="类型类与面向对象接口"><a href="#类型类与面向对象接口" class="headerlink" title="类型类与面向对象接口"></a>类型类与面向对象接口</h3><p>类型类可能看起来与面向对象语言中的接口比较相似，但它更为强大，体现在：</p><ol><li><p>接口的实例类一但定义就必须实现所有接口，而类型类可以被每个类型自由组合。</p></li><li><p>类型类在处理多类型时更为强大，目前Java没有简单的方法可以做到：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Blerg</span> a b <span class="keyword">where</span></span></span><br><span class="line">  blerg :: a -&gt; b -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure></li><li><p>并且类型类可以更方便的处理多元运算，如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Num</span> a <span class="keyword">where</span></span></span><br><span class="line">  (+) :: a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure><p>而在Java或C++中，对多元运算符的重载总是以某一个类型为主，比较尴尬。</p></li></ol><h3 id="其它标准类型类"><a href="#其它标准类型类" class="headerlink" title="其它标准类型类"></a>其它标准类型类</h3><p><code>Ord</code>：确保类型可以被完全排序，在C++中的常见做法是实现<code>&lt;</code>运算符。</p><p><code>Num</code>：数字类型，使得类型可以进行加减法等运算。一个非常重要的事情是，数字常量也是类型类多态：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t <span class="number">5</span></span><br><span class="line"><span class="number">5</span> :: <span class="type">Num</span> a =&gt; a</span><br></pre></td></tr></table></figure><p>这意味着5可以被用作任何数字类型，包括自己定义的类型。</p><p><code>Show</code>：定义模式show，将值转换为<code>String</code>类型。</p><p><code>Read</code>：<code>Show</code>的逆运算。</p><p><code>Integal</code>：表示整数类型，如<code>Int</code>和<code>Integer</code>。</p><h3 id="类型类实例"><a href="#类型类实例" class="headerlink" title="类型类实例"></a>类型类实例</h3><p>这一节我们来定义一个自己的类型类，如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Listable</span> a <span class="keyword">where</span></span></span><br><span class="line">  toList :: a -&gt; [<span class="type">Int</span>]</span><br></pre></td></tr></table></figure><p><code>Listable</code>类型类表示可以转换为<code>Int</code>列表的类型。首先，<code>Int</code>和<code>Bool</code>都可以简单的转换为一个只有一个元素的列表：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Listable</span> <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">  toList x = [x]</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Listable</span> <span class="type">Bool</span> <span class="keyword">where</span></span></span><br><span class="line">  toList <span class="type">True</span> = [<span class="number">1</span>]</span><br><span class="line">  toList <span class="type">False</span> = [<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>我们无需对<code>[Int]</code>类型进行转换：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Listable</span> [<span class="type">Int</span>] <span class="keyword">where</span></span></span><br><span class="line">  toList = id</span><br></pre></td></tr></table></figure><p>最后，我们也可以将一个自定义类型转换为<code>[Int]</code>列表：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Empty</span> | <span class="type">Node</span> a (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Listable</span> (<span class="type">Tree</span> <span class="type">Int</span>) <span class="keyword">where</span></span></span><br><span class="line">  toList <span class="type">Empty</span> = []</span><br><span class="line">  toList (<span class="type">Node</span> x l r) = toList l ++ [x] ++ toList r</span><br></pre></td></tr></table></figure><p>我们可以使用<code>Listable</code>的特性定义其它函数，如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sumL</span> :: <span class="type">Listable</span> a =&gt; a -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">sumL</span> x = sum (toList x)</span><br></pre></td></tr></table></figure><p><code>sumL</code>只为<code>Listable</code>类型工作，那么下面的函数呢？</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> x y = sum (toList x) == sum (toList y) || x &lt; y</span><br></pre></td></tr></table></figure><p><code>foo</code>的类型为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> :: (<span class="type">Listable</span> a, <span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>即它的参数类型必须同时是<code>Listable</code>和<code>Ord</code>的实例。</p><p>最后，来看一个复杂点的实例：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Listable</span> <span class="title">a</span>, <span class="type">Listable</span> <span class="title">b</span>) =&gt; <span class="type">Listable</span> (<span class="title">a</span>, <span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">  toList (x, y) = toList x ++ toList y</span><br></pre></td></tr></table></figure><p>只要类型变量在函数定义中，我们就可以为它指定类型类。注意，这个函数并不是递归函数，调用的<code>toList x</code>与<code>toList y</code>是其它类型的实例，而不是该函数本身。</p>]]></content>
      
      
      <categories>
          
          <category> 0x03 从零开始的Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的Haskell（四）——高阶编程与类型接口</title>
      <link href="/zh/blog/2021/09/06/0024-Re0:Haskell_04/"/>
      <url>/zh/blog/2021/09/06/0024-Re0:Haskell_04/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不幸遭遇飞机延误，候机室写下系列第四篇，主题是高阶编程与类型接口。</p></blockquote><span id="more"></span><h2 id="匿名函数（lambda表达式）"><a href="#匿名函数（lambda表达式）" class="headerlink" title="匿名函数（lambda表达式）"></a>匿名函数（lambda表达式）</h2><p>设想一下这样的函数，功能仅仅是简单的：保留数列中大于100的数。如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">greaterThan100</span> :: [<span class="type">Integer</span>] -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">greaterThan100</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">300</span>,<span class="number">4</span>,<span class="number">245</span>] = [<span class="number">300</span>,<span class="number">245</span>]</span><br></pre></td></tr></table></figure><p>我们可以使用很棒的方法实现：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">gt100</span> :: <span class="type">Integer</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">gt100</span> x = x &gt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="title">greaterThan100</span> :: [<span class="type">Integer</span>] -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">greaterThan100</span> xs = filter gt100 xs</span><br></pre></td></tr></table></figure><p>但我们可能并不希望定义<code>gt100</code>这样的只使用一次的函数。此时就可以使用lambda表达式来代替<code>gt100</code>：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">greaterThan100_new</span> :: [<span class="type">Integer</span>] -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">greaterThan100_new</span> xs = filter (\x -&gt; x &gt; <span class="number">100</span>) xs</span><br></pre></td></tr></table></figure><p>其中<code>\x -&gt; x &gt; 100</code>就是一个lambda表达式，它也可以有多个参数，如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 结果为6</span></span><br><span class="line">(\x y z -&gt; x + y + z) <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>lambda已经足够简单了，但这个函数还有一种更好的写法：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">greaterThan100_newer</span> :: [<span class="type">Integer</span>] -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">greaterThan100_newer</span> xs = filter (&gt;<span class="number">100</span>) xs</span><br></pre></td></tr></table></figure><p>这里的<code>(&gt;100)</code>是一个操作片段，操作片段允许我们使用一个函数的部分调用。对于任意一个二元操作符<code>?</code>：<code>(?y)</code>等价于<code>\x -&gt; x?y</code>；<code>(y?)</code>等价于<code>\x -&gt; y?x</code>。即将缺少的部分作为函数的参数。例如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&gt;<span class="number">100</span>) <span class="number">110</span> <span class="comment">-- True</span></span><br><span class="line">(<span class="number">100</span>&gt;) <span class="number">110</span> <span class="comment">-- False</span></span><br><span class="line"><span class="title">map</span> (*<span class="number">2</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">-- [2,4,6]</span></span><br></pre></td></tr></table></figure><h2 id="函数组成"><a href="#函数组成" class="headerlink" title="函数组成"></a>函数组成</h2><p>试写出一个类型为<code>(b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code>的函数。首先我们能知道这个函数的两个参数都是函数，并且该函数的返回值也是一个函数。首先我们给出类型签名：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</span><br></pre></td></tr></table></figure><p>试着写出函数的参数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> f g = ...</span><br></pre></td></tr></table></figure><p>由于返回值是一个函数，我们可以使用lambda表达式来实现：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> f g = \x -&gt; ...</span><br></pre></td></tr></table></figure><p>根据类型签名可以看出<code>x</code>先由<code>g</code>处理再由<code>f</code>处理就得到了类型为<code>c</code>的值，因此有：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> f g = \x -&gt; f (g x)</span><br></pre></td></tr></table></figure><p>思考一下，这个函数有什么用？答案是组合两个函数。Haskell中这样的操作是非常常用的，因此语言内置了这个操作，用操作符<code>.</code>表示，上式可写为：<code>f.g</code>。</p><p>题外话，在引入了函数式范式后，C++也能实现类似操作了（什么叫头号粉丝啊，战术后仰.jpg）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::function;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> a, <span class="keyword">typename</span> b, <span class="keyword">typename</span> c&gt;</span></span><br><span class="line"><span class="function">function&lt;<span class="title">c</span><span class="params">(a)</span>&gt; <span class="title">foo</span><span class="params">(<span class="keyword">const</span> function&lt;c(b)&gt; &amp;f, <span class="keyword">const</span> function&lt;b(a)&gt; &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [&amp;f, &amp;g](a x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(<span class="built_in">g</span>(x));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见C++在这方面已经挻不错了，不过与真正的函数式编程语言相比仍有些距离。</p><p>言归正传，<code>.</code>操作乍看起来好像没什么用，但下面这个例子会为其用途提供一个有力的说明：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">test</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">test</span> xs = even (length (greatThan100 xs))</span><br><span class="line"><span class="comment">-- 可以写作</span></span><br><span class="line"><span class="title">test&#x27;</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">test&#x27;</span> = even.length.greatThan100</span><br></pre></td></tr></table></figure><p>去掉了层层叠叠的括号和有些累缀的参数后，看起来优雅多了。<code>.</code>运算将函数<code>test&#39;</code>的定义表示为了几个小函数的组合。接下来让我们再看看<code>.</code>运算：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t (.)</span><br><span class="line">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</span><br></pre></td></tr></table></figure><p>疑点出现了：返回值为什么不是<code>(a -&gt; c)</code>?</p><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>回顾我们的函数定义，如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">f</span> x y = <span class="number">2</span>*x + y</span><br></pre></td></tr></table></figure><p>还记得之前说过使用连续的<code>-&gt;</code>作为参数与返回值的声明背后有非常<del>暖心</del>优雅的理由吗？现在就是揭晓谜底的时刻了，先说结论：<strong>Haskell中的任何函数都接收一个参数</strong>。等等，难道上面刚定义的函数<code>f</code>不是接收了<code>x</code>和<code>y</code>两个参数吗？确实不是，实际上<code>f</code>是接收<code>x</code>作为参数，同时返回一个<code>Int -&gt; Int</code>型的函数，<code>y</code>是作为这个返回函数的参数被接收的。实际上就是lambda演算，之后会单独写一篇文章介绍lambda演算。也就是说，函数<code>f</code>的定义等价于：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>)</span><br></pre></td></tr></table></figure><p>由于<code>-&gt;</code>符合右结合律，因此上式括号可以不写。这也解释了上一节末尾的疑问。同时，函数调用符合左结合律，因此：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> x y = ((f x) y)</span><br></pre></td></tr></table></figure><p>思考一下，<code>f x</code>的类型是一个<code>Int -&gt; Int</code>型的函数，而表达式中这个函数又接受了<code>y</code>返回一个<code>Int</code>。整个运算过程就是将参数逐个输入到对应的函数中，因此使用<code>-&gt;</code>符号来声明函数再贴切不过了。</p><h2 id="函数的部分应用"><a href="#函数的部分应用" class="headerlink" title="函数的部分应用"></a>函数的部分应用</h2><p>函数的部分调用本质上就是对柯里化的应用，但永远记住每个函数本质上只有一个参数，因此我们<strong>只能对函数的第一个参数进行部分应用</strong>。唯一的例外是中缀函数，正如之前的例子所示，可以对中缀函数两个参数中的任何一个进行部分应用。</p><p>由于只能对第一个参数进行部分应用，因此我们的参数顺序应该遵循由普通到特殊的规则。即最容易相同的参数放在最前面。</p><h2 id="全麦编程"><a href="#全麦编程" class="headerlink" title="全麦编程"></a>全麦编程</h2><p>记得一开始介绍过的全麦编程概念吗？站在整体的角度思考问题，考虑如何处理整个列表而不是处理列表中的元素，就像全麦面粉一样，直接对麦子打粉而不考虑脱壳。现在是时候体会下全麦风格的威力了，考虑下面程序：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foobar</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">foobar</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">foobar</span> (x:xs)</span><br><span class="line">    | x &gt; <span class="number">3</span> = (<span class="number">7</span> * x + <span class="number">2</span>) + foobar xs</span><br><span class="line">    | otherwise foobar xs</span><br></pre></td></tr></table></figure><p>这个程序的功能看起来很直观，但并不是良好的Haskell风格，主要存在两点问题：</p><ol><li>一个程序同时处理了过多的事务。</li><li>代码工作得太底层了。</li></ol><p>我们可以将其功能实现为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foobar&#x27;</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">foobar&#x27;</span> sum . map (\x -&gt; <span class="number">7</span> * x + <span class="number">2</span>) . filter (&gt;<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>这样的实现将很多只做好一件事的小函数组合起来，使得函数更加清晰与直观。</p><h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><p>增加了许多知识后，我们可以讨论上一节中被搁置的折叠操作了。先来直观体会折叠操作：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum&#x27;</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">sum&#x27;</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sum&#x27;</span> (x:xs) = x + sum&#x27; xs</span><br><span class="line"></span><br><span class="line"><span class="title">product&#x27;</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">product&#x27;</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">product&#x27;</span> (x:xs) = x * product&#x27; xs</span><br><span class="line"></span><br><span class="line"><span class="title">length&#x27;</span> :: [a] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">length&#x27;</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">length&#x27;</span> (x:xs) = <span class="number">1</span> + length&#x27; xs</span><br></pre></td></tr></table></figure><p>这三个函数的共性是什么？是通过某种方式将元素们组合成一个最终结果。我们可以将其抽象为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fold</span> :: b -&gt; (a -&gt; b -&gt; b) -&gt; [a] -&gt; b</span><br><span class="line"><span class="title">fold</span> z f [] = z</span><br><span class="line"><span class="title">fold</span> z f (x:xs) = f x (fold z f xs)</span><br></pre></td></tr></table></figure><p>此时函数运算过程可以做如下展开：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fold</span> z f [a,b,c] == f a (f b (f c z))</span><br><span class="line"><span class="comment">-- 写成中缀形式可能更好理解</span></span><br><span class="line"><span class="title">fold</span> z f [a,b,c] == a `f` (b `f` (c `f` z))</span><br></pre></td></tr></table></figure><p>看出来了吗？<code>fold</code>函数是把一个列表最右边的两个元素进行组合，并使用组合后的元素代替原来的两个函数，直到列表为空。</p><p>有了这个函数，之前的几个函数就可以写为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum&#x27;&#x27;</span> = fold <span class="number">0</span> (+)</span><br><span class="line"><span class="title">product&#x27;&#x27;</span> = fold <span class="number">0</span> (*)</span><br><span class="line"><span class="title">length&#x27;&#x27;</span> = fold <span class="number">0</span> (\_ s -&gt; s + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>观察<code>\_ s -&gt; s + 1</code>，可以消去两边的<code>s</code>，化为<code>\_ -&gt; (+1)</code>。</p><p>另一种思路是使用<code>const</code>函数。<code>const</code>函数的类型为<code>a-&gt;b-&gt;a</code>，效果是输入两个参数，并返回第一个参数作为结果（即丢弃第二个参数），和C++的const关键字完全不是一回事。</p><p><code>\_ s -&gt; s + 1</code>的作用显然是丢弃第一个参数，并返回第二个参数+1后的值。可写为<code>const (+1)</code>。</p><p>解说一下：<code>const (+1)  </code>是一个对<code>const</code>的部分应用，即使用<code>(+1)</code>作为<code>const</code>的第一个参数，此时这个部分应用变成了接受一个参数并返回<code>(+1)</code>的函数。不要忘记<code>(+1)</code>本身也是一个部分应用，其类型为<code>a -&gt; a</code>，则<code>const (+1)</code>的类型就是<code>b -&gt; a -&gt; a</code>。符合了我们<code>fold</code>函数对参数<code>f</code>的要求。</p><p>具体举例，对于<code>f 2 3</code>，有：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- f = \_ s -&gt; s + 1</span></span><br><span class="line"><span class="title">f</span> <span class="number">2</span> <span class="number">3</span> == <span class="number">3</span> + <span class="number">1</span> == <span class="number">4</span></span><br><span class="line"><span class="comment">-- f = \_ -&gt; (+1)</span></span><br><span class="line"><span class="title">f</span> <span class="number">2</span> <span class="number">3</span> == (+<span class="number">1</span>) <span class="number">3</span> == <span class="number">4</span></span><br><span class="line"><span class="comment">-- f = const (+1)</span></span><br><span class="line"><span class="title">f</span> <span class="number">2</span> <span class="number">3</span> == const (+<span class="number">1</span>) <span class="number">2</span> <span class="number">3</span> == (+<span class="number">1</span>) <span class="number">3</span> == <span class="number">4</span></span><br></pre></td></tr></table></figure><p>作为一个常用的函数，<code>fold</code>在<code>Prelude</code>中当然也有定义，即为<code>foldr</code>。<code>Prelude</code>中依赖于<code>foldr</code>定义的函数有：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">length</span> :: [a] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">sum</span> :: <span class="type">Num</span> a =&gt; a -&gt; a</span><br><span class="line"><span class="title">product</span> :: <span class="type">Num</span> a =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">and</span> :: [<span class="type">Bool</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">or</span> :: [<span class="type">Bool</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">any</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">all</span> :: (a-&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>你可能会对<code>=&gt;</code>感到默生，这个符号我们会在下一节进行介绍。</p><p>还有一个<code>foldl</code>函数，表示从左边折叠，与<code>foldr</code>的区别如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldr</span> f z [a,b,c] = a `f` (b `f` (c `f` z))</span><br><span class="line"><span class="title">foldl</span> f z [a,b,c] = ((z `f` a) `f` b) `f` c</span><br></pre></td></tr></table></figure><p>注意<code>foldr</code>和<code>foldl</code>的参数顺序与我们的<code>fold</code>函数不同。</p><p>一般来说我们还可以使用<code>Data.List</code>模块中的<code>foldl&#39;</code>函数，它是<code>foldl</code>的一个更高性能的实现。</p>]]></content>
      
      
      <categories>
          
          <category> 0x03 从零开始的Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的Haskell（三）——递归模式、多态和Prelude</title>
      <link href="/zh/blog/2021/09/03/0023-Re0:Haskell_03/"/>
      <url>/zh/blog/2021/09/03/0023-Re0:Haskell_03/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是系列的第三篇，主要对Haskell中的递归模式、多态性和Prelude进行介绍。学习本篇内容可以大幅减少代码的重复现象。</p></blockquote><span id="more"></span><p>之前的学习可能会使你产生Haskell程序员会花费大量的时间去编写复杂的递归函数。其实有经验的Haskell程序员几乎不使用递归函数。</p><p>为什么会这样呢？因为递归函数实质上是对递归模式的反复处理。通过将这些递归的模式抽象出来，封装成库，就使得程序员免于过多的与底层细节纠缠，从而在更高的层次进行思考——这就是全麦编程思想的目标。</p><h2 id="递归模式"><a href="#递归模式" class="headerlink" title="递归模式"></a>递归模式</h2><p>一个关于<code>Int</code>类型的列表可以定义为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IntList</span> = <span class="type">Empty</span> | <span class="type">Cons</span> <span class="type">Int</span> <span class="type">IntList</span></span></span><br><span class="line">  <span class="keyword">deriving</span> <span class="type">Show</span></span><br></pre></td></tr></table></figure><p>我们可能对这个列表进行哪些操作呢？可能有这些：</p><ul><li>对每一个元素分别进行某种操作。</li><li>基于某种判断保留列表中的一些元素并抛弃其它元素。</li><li>通过某种方式对列表中的元素进行“概括”，如获取所有元素的最大值，总和，乘积等。</li></ul><h3 id="映射（Map）"><a href="#映射（Map）" class="headerlink" title="映射（Map）"></a>映射（Map）</h3><p>考虑第一种操作，对每个元素进行特定操作，即为映射操作。比如对每个元素取绝对值，可以写成如下形式：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">absAll</span> :: <span class="type">IntList</span> -&gt; <span class="type">IntList</span></span><br><span class="line"><span class="title">absAll</span> <span class="type">Empty</span> = <span class="type">Empty</span></span><br><span class="line"><span class="title">absAll</span> (<span class="type">Cons</span> x xs) = <span class="type">Cons</span> (abs x) (absAll xs)</span><br></pre></td></tr></table></figure><p>如果要对每个元素做平方运算呢？可以写成如下形式：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">squareAll</span> :: <span class="type">IntList</span> -&gt; <span class="type">IntList</span></span><br><span class="line"><span class="title">squareAll</span> <span class="type">Empty</span> = <span class="type">Empty</span></span><br><span class="line"><span class="title">squareAll</span> (<span class="type">Cons</span> x xs) = <span class="type">Cons</span> (x*x) (squreAll xs)</span><br></pre></td></tr></table></figure><p>有没有发现些许违和感？是的，这两个函数实在太像了，看起来非常啰嗦。我们可以用一个<code>Int-&gt;Int</code>类型的函数来指定这些操作，并且使用一个接受对应参数的函数来处理列表：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">square</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">square</span> x = x * x</span><br><span class="line"></span><br><span class="line"><span class="title">mapIntList</span> :: (<span class="type">Int</span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">IntList</span> -&gt; <span class="type">IntList</span></span><br><span class="line"><span class="title">mapIntList</span> _ <span class="type">Empty</span> = <span class="type">Empty</span></span><br><span class="line"><span class="title">mapIntList</span> func (<span class="type">Cons</span> x xs) = <span class="type">Cons</span> (func x) (mapIntList func xs)</span><br></pre></td></tr></table></figure><p>此时就可以通过：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- list是一个IntList</span></span><br><span class="line"><span class="title">mapIntList</span> abs list</span><br><span class="line"><span class="title">mapIntList</span> square list</span><br></pre></td></tr></table></figure><p>来分别实现<code>absAll</code>和<code>squareAll</code>的功能了。</p><h3 id="筛选（Filter）"><a href="#筛选（Filter）" class="headerlink" title="筛选（Filter）"></a>筛选（Filter）</h3><p>考虑第二种操作，即通过某种判断保留列表中的一些元素并抛弃其它元素，即为筛选。比如仅保留列表中的偶数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">evenOnly</span> :: <span class="type">IntList</span> -&gt; <span class="type">IntList</span></span><br><span class="line"><span class="title">evenOnly</span> <span class="type">Empty</span> = <span class="type">Empty</span></span><br><span class="line"><span class="title">evenOnly</span> (<span class="type">Cons</span> x xs)</span><br><span class="line">    | even x = <span class="type">Cons</span> x (evenOnly xs)</span><br><span class="line">    | otherwise = evenOnly xs</span><br></pre></td></tr></table></figure><p>同样，我们可以对这种操作进行抽象，令它成为一个接受<code>(Int -&gt; Bool)</code>类型与<code>IntList</code>类型参数的函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filterIntList</span> :: (<span class="type">Int</span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">IntList</span> -&gt; <span class="type">IntList</span></span><br><span class="line"><span class="title">filterIntList</span> _ <span class="type">Empty</span> = <span class="type">Empty</span></span><br><span class="line"><span class="title">filterIntList</span> func (<span class="type">Cons</span> x xs)</span><br><span class="line">    | func x = <span class="type">Cons</span> x (filterIntList xs)</span><br><span class="line">    | otherwise = filterIntList xs</span><br></pre></td></tr></table></figure><p>此时即可通过下面代码实现<code>evenOnly</code>的功能了：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- list是一个IntList</span></span><br><span class="line"><span class="title">filterIntList</span> even list</span><br></pre></td></tr></table></figure><h3 id="折叠（Fold）"><a href="#折叠（Fold）" class="headerlink" title="折叠（Fold）"></a>折叠（Fold）</h3><p>第三种操作，获取一个列表的某种“概括”，即为折叠操作。我们将在下一篇对折叠操作进行详细讨论。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>通过上一节递归模式的抽象，我们可以漂亮的处理对<code>Int</code>列表的映射与筛选了。然而，我们要如何处理一个<code>Integer</code>、<code>Bool</code>、<code>String</code>甚至是<code>一个String的栈的树的列表的列表</code>的列表呢？如果为每个类型都写出对应的实现，那么你会发现除了操作的类型外这些函数完全一样。为了解决这个问题，我们需要使用Haskell中的多态。</p><h3 id="多态的数据类型"><a href="#多态的数据类型" class="headerlink" title="多态的数据类型"></a>多态的数据类型</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> t = <span class="type">E</span> | <span class="type">C</span> t (<span class="type">List</span> <span class="title">t</span>)</span></span><br></pre></td></tr></table></figure><p>这里的<code>t</code>叫做类型变量，可以表示任何类型，<strong>类型变量必须以小写字母开头</strong>。</p><h3 id="多态函数"><a href="#多态函数" class="headerlink" title="多态函数"></a>多态函数</h3><p>有了多态的数据类型，我们就可以写出多态的函数了。比如一个接收任何类型列表的折叠：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filterList</span> _ <span class="type">E</span> = <span class="type">E</span></span><br><span class="line"><span class="title">filterList</span> func (<span class="type">C</span> x xs)</span><br><span class="line">    | func x = <span class="type">C</span> x (filterList xs)</span><br><span class="line">    | otherwise = filterList xs</span><br></pre></td></tr></table></figure><p>那么filterList的类型是什么呢？通过ghci查询结果如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:t filterList</span><br><span class="line"><span class="title">filterList</span> :: (t -&gt; <span class="type">Bool</span>) -&gt; <span class="type">List</span> t -&gt; <span class="type">List</span> t</span><br></pre></td></tr></table></figure><p>可见一个多态数据类型在使用时也要接受一个类型变量作为参数。如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">a</span> :: <span class="type">List</span> <span class="type">Bool</span></span><br><span class="line"><span class="title">a</span> = <span class="type">C</span> <span class="type">True</span> (<span class="type">C</span> <span class="type">False</span> (<span class="type">C</span> <span class="type">True</span> <span class="type">E</span>))</span><br></pre></td></tr></table></figure><h2 id="Prelude"><a href="#Prelude" class="headerlink" title="Prelude"></a>Prelude</h2><p><a class="link"   href="https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.15.0.0/Prelude.html" >Prelude<i class="fas fa-external-link-alt"></i></a>是一个所有Haskell程序都默认包括的模块，定义了很多常用的多态数据类型和多态函数。例如<code>filter</code>和<code>map</code>就是<code>filterList</code>和<code>map</code>在<code>Prelude</code>中的对应版本。另外，<code>Data.List</code>模块中定义了一个更强大的<code>List</code>类型。</p><p>此外，一个常用的多态数据类型是<code>Maybe</code>，定义为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a</span></span><br></pre></td></tr></table></figure><p>一个<code>Maybe</code>类型可以是<code>Nothing</code>或一个类型的值，模块<code>Data.Maybe</code>中定义了关于<code>Maybe</code>的操作。</p><h2 id="全函数与偏函数"><a href="#全函数与偏函数" class="headerlink" title="全函数与偏函数"></a>全函数与偏函数</h2><p>考虑一个<code>[a] -&gt; a</code>类型的函数，如<code>head</code>。它返回一个列表的首元素，如果它接受一个空列表，就会出错。这样无法处理所有合法参数的函数，就被称为偏函数。对应地，一个无论参数取值如何都能正常工作的函数称为全函数。</p><h3 id="偏函数转化为全函数"><a href="#偏函数转化为全函数" class="headerlink" title="偏函数转化为全函数"></a>偏函数转化为全函数</h3><p>比如<code>head</code>的实现如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">head</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">head</span> (x : _) = x</span><br></pre></td></tr></table></figure><p><code>head</code>作为一个不安全的函数是不应该出现在<code>Prelude</code>里的，这是一个失误。我们应该尽可能地不用偏函数。如果要将head转化为一个全函数，只需使用上面的<code>Maybe</code>：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">headSafe</span> :: [<span class="type">Maybe</span> a] -&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="title">head</span> [] = <span class="type">Nothing</span></span><br><span class="line"><span class="title">head</span> (x : _) = <span class="type">Just</span> x</span><br></pre></td></tr></table></figure><p>尽可能地使用全函数可以大大减少我们犯错的可能。</p>]]></content>
      
      
      <categories>
          
          <category> 0x03 从零开始的Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++结构体内存对齐</title>
      <link href="/zh/blog/2021/08/11/0022-C++:Memory_alignment_of_structure/"/>
      <url>/zh/blog/2021/08/11/0022-C++:Memory_alignment_of_structure/</url>
      
        <content type="html"><![CDATA[<blockquote><p>疏理一下结构体的内存对齐规则 </p></blockquote><span id="more"></span><h2 id="内存对齐是什么？为什么要进行内存对齐？"><a href="#内存对齐是什么？为什么要进行内存对齐？" class="headerlink" title="内存对齐是什么？为什么要进行内存对齐？"></a>内存对齐是什么？为什么要进行内存对齐？</h2><p>现代计算机以字节为单位划分内存空间，但大多不是以字节为单位存取内存的。一次存取往往涉及多个字节，这个大小称为存取粒度。存取粒度通常与系统有关，如32位系统存取粒度大多为4字节，而64位系统的存取粒度大多为8字节。</p><p>对于这个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span>  a; <span class="comment">// 假定int占用4字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，它的成员大小总和为5字节。但通常这个结构体的大小会被填充到8字节。原因如下：</p><p>考虑不对齐字节的情况，如果结构体地址为0x00，则c的地址为0x00，a的地址为0x01。此时一个存取粒度为4字节的机器要取出a，需要以下几步。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌─┬────┐        1.取地址0x00开始的4字节，并保留需要的数据0x01、0x02、0x03</span><br><span class="line">│c│a   │        2.取地址0x04开始的4字节，并保留需要的数据0x04</span><br><span class="line">└─┴────┘        3.将上两步获取的数据合并，计算出a的值</span><br><span class="line"> 0|1234</span><br></pre></td></tr></table></figure><p>这样的过程对计算机来说是很麻烦的，而如果进行字节对齐，则结构体地址和c的地址依然是0x00，而a的地址移到了0x04，此时一个存取粒度为4字节的机器可以直接取出a的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌───────┬───────┐    直接取地址0x04开始的4字节即可取出a的值。</span><br><span class="line">│c      │a      │</span><br><span class="line">└───────┴───────┘</span><br><span class="line">0 1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure><p>由此不难看出，所谓的内存对齐就是为了便于机器存取而根据存储粒度对内存布局的调整。</p><h2 id="内存对齐的规则"><a href="#内存对齐的规则" class="headerlink" title="内存对齐的规则"></a>内存对齐的规则</h2><h3 id="规则1：结构体内部成员的地址一定是自身大小的整数倍，否则就进行对齐。"><a href="#规则1：结构体内部成员的地址一定是自身大小的整数倍，否则就进行对齐。" class="headerlink" title="规则1：结构体内部成员的地址一定是自身大小的整数倍，否则就进行对齐。"></a>规则1：结构体内部成员的地址一定是自身大小的整数倍，否则就进行对齐。</h3><p>比如上面的例子中，int类型大小为4字节，而0x01并不是4字节的整数倍，因此对齐到0x04。</p><p>考虑下面结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>  a; <span class="comment">// 假定int为4字节</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据规则1：a的地址为0x00，不需对齐；c的地址为0x04，是char类型大小的整数倍，也不需对齐。于是该结构体的大小应当是5字节。</p><p>但此时，对于数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo1 arr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>其内存布局为如下，此时若想取出<code>arr[1].a</code>，则有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌───────┬─┬──────┬─┐    1.由于arr[1].a的地址为0x05，则需要先取出0x04开始的4个字节，</span><br><span class="line">│a      │c│a     │c│      并保留0x05、0x06、0x07。</span><br><span class="line">└───────┴─┴──────┴─┘    2.然后取出0x08开始的4字节，并保留0x08</span><br><span class="line">0 1 2 3 4 5 6 7 8 9     3.将上两步数据合并计算出arr[1].a的值。</span><br></pre></td></tr></table></figure><p>这又回到了没有对齐的情况了，因此为了避免这种情况，引入了规则2：</p><h3 id="规则2：结构体的大小为其最大成员大小的整数倍，若基最大成员大小大于存取粒度，则结构体的大小为存取粒度的整数倍，否则就在结构体末尾补齐。"><a href="#规则2：结构体的大小为其最大成员大小的整数倍，若基最大成员大小大于存取粒度，则结构体的大小为存取粒度的整数倍，否则就在结构体末尾补齐。" class="headerlink" title="规则2：结构体的大小为其最大成员大小的整数倍，若基最大成员大小大于存取粒度，则结构体的大小为存取粒度的整数倍，否则就在结构体末尾补齐。"></a>规则2：结构体的大小为其最大成员大小的整数倍，若基最大成员大小大于存取粒度，则结构体的大小为存取粒度的整数倍，否则就在结构体末尾补齐。</h3><p>在此规则下，结构体foo1的大小应为8字节。需要注意，结构体中最大成员并不包括结构体成员，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假定int占4字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">byte8</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo2</span> &#123;</span></span><br><span class="line">    byte8 a;</span><br><span class="line">    <span class="keyword">char</span>  b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo3</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时foo2的最大成员并不是看做整体的byte8的8字节，而是byte8与foo2中的基础成员中的最大成员，此处为int。因此foo2对4字节对齐，大小为12字节。而foo3的最大成员为long long，对8字节对齐，大小为16字节。</p>]]></content>
      
      
      <categories>
          
          <category> 0x01 C++之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMakeLists.txt编写入门</title>
      <link href="/zh/blog/2021/08/02/0021-CMakeLists/"/>
      <url>/zh/blog/2021/08/02/0021-CMakeLists/</url>
      
        <content type="html"><![CDATA[<blockquote><p>整理一下CMakeLists的相关知识。</p></blockquote><span id="more"></span><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>听说CMake已经被证明图灵完备了，不过它的语法还是很简单的，由命令、变量和注释组成。</p><p>注释：以<code>#</code>开头的行即为注释。</p><p>命令：包括命令名和一个括号括起来的参数列表。形式如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">command</span>(arg1 arg2 ...) <span class="comment"># 参数以空格分隔</span></span><br></pre></td></tr></table></figure><p>变量：由命令生成或CMake环境定义，使用<code>$</code>和<code>&#123;&#125;</code>来引用变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;SOMEVAR&#125;</span> <span class="comment"># 变量的值</span></span><br><span class="line">SOMEVAR    <span class="comment"># 字面值</span></span><br></pre></td></tr></table></figure><p>CMakeList.txt是逐行解析的，因此变量的定义应在使用之前。</p><p>好了，现在你已经学会CMake了。了解几个常用命令和变量就可以使用了。</p><h2 id="基础命令与变量"><a href="#基础命令与变量" class="headerlink" title="基础命令与变量"></a>基础命令与变量</h2><p><code>cmake_minimum_required(&lt;version&gt;)</code>：指定CMake的最小版本号。</p><p><code>project(&lt;name&gt;)</code>：指定工程名称。</p><p><code>include_directories(&lt;dir1&gt; &lt;dir2&gt; ...)</code>：指定include目录。</p><ul><li>变量<code>CMAKE_SOURCE_DIR</code>：表示工程顶层目录。</li></ul><p><code>aux_source_directory(&lt;dir&gt; &lt;var&gt;)</code>：将一个目录中所有源文件赋予一个变量。</p><p><code>add_executable(&lt;target&gt; &lt;source1&gt; &lt;source2&gt; ...)</code>：构建可执行文件，第一个参数为文件名称，后面的参数为源文件列表。</p><p>有了这几条命令，我们就可以编写一个能用的CMakeList.txt文件了：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimun_required(<span class="number">3.1</span>)</span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line">aux_source_dirctory(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/src DIR_SRC)</span><br><span class="line"><span class="keyword">add_executable</span>(helloworld <span class="variable">$&#123;DIR_SRC&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="控制流命令"><a href="#控制流命令" class="headerlink" title="控制流命令"></a>控制流命令</h2><ul><li>if</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(conditon)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">elseif</span>(condition)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><ul><li>while</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure><ul><li>foreach</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(var arg1 arg2 ...)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endforeach</span>(var)</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>set(var value)</code>：为变量赋值。</p><p><code>add_definitions(-Dxxxx1 -Dxxxx2 ...)</code>：向编译器添加-D定义，此时代码内的<code>#ifdef xxxx ... #endif</code>代码块生效。</p><p><code>add_dependencies(target-name depend-target1 ...)</code>：添加依赖目标。</p><p><code>add_library(name [STATIC|SHARED] src1 src2...)</code>：创建库，如果未指定库类型则默认构建STATIC库，可以通过定义变量<code>BUILD_SHARED_LIBS</code>改为默认构建SHARED库。</p><p><code>target_link_library(target-name lib1 lib2 ...)</code>：为taget链接库。</p><p><code>add_subdirectory(subdir1 subdir2 ...)</code>：添加子目录，使用子目录的CMakeLists.txt构建子目录中的文件。</p><p><code>add_test(testname execname arg1 arg2...)</code>：添加测试，execname可以是任何可执行文件的名称。在生成makefile后可以使用<code>make test</code>来进行测试。</p><p><code>ebable_test()</code>：开启测试开关，没有这条指令则任何add_test指令都是无效的。</p><p><code>find_library(var NAMES name1 name2 ... PATHS path1 path2 ...)</code>：在path中查找基础名称为name的库，并将其完整路径赋予变量var。</p><p><code>file_path(var file path1 path2 ...)</code>：在path中查找file，并将path路径赋予变量var。</p><h2 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h2><p><code>CMAKE_BINARY_DIR</code> = <code>PROJECT_BINARY_DIR</code> = <code>&lt;projectname&gt;_BINARY_DIR</code>：可执行文件生成目录。</p><p><code>CMAKE_SOURCE_DIR</code> = <code>PROJECT_SOURCE_DIR</code> = <code>&lt;projectname&gt;_SOURCE_DIR</code>：工程顶层目录。</p><p><code>CMAKE_CURRENT_SOURCE_DIR</code>：当前文件（可以是子文件夹的CMakeLists.txt）所在目录。</p><p><code>CMAKE_CURRENT_BINARY_DIR</code>：当前文件产生的可执行文件目录。</p><p><code>CMAKE_CURRENT_LIST_FILE</code>：调用此变量的CMakeLists.txt的完整路径。</p><p><code>CMAKE_CURRENT_LIST_LINE</code>：此变量所在的行。</p><p><code>CMAKE_MODULE_PATH</code>：模块的路径。</p><p><code>EXECUTABLE_OUTPUT_PATH</code>：可执行文件的存放路径。</p><p><code>LIBRARY_OUTPUT_PATH</code>：库文件的存放路径。</p><p><code>CMAKE_MAJOR_VERSION</code>：主版本号。</p><p><code>CMAKE_MINOR_VERSION</code>：次版本号。</p><p><code>CMAKE_PATCH_VERSION</code>：补丁等级。</p><p><code>CMAKE_SYSTEM</code>：系统名称。</p><p><code>CMAKE_SYSTEM_NAME</code>：不含版本的系统名。</p><p><code>CMAKE_SYSTEM_PROCESSOR</code>：处理器名称。</p><p><code>UNIX</code>：在unix环境下为TRUE。</p><p><code>WIN32</code>：在win32环境下为TRUE。</p>]]></content>
      
      
      <categories>
          
          <category> 0x02 技术杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL容器备忘总结</title>
      <link href="/zh/blog/2021/07/21/0020-STL_containers/"/>
      <url>/zh/blog/2021/07/21/0020-STL_containers/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用容器总有几个细节记不清，梳理一番以作备忘。</p></blockquote><span id="more"></span><h2 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h2><h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><table><thead><tr><th>顺序容器</th><th>描述</th></tr></thead><tbody><tr><td>vector</td><td>可变大小数组，快速随机访问，快速尾部增删。</td></tr><tr><td>deque</td><td>双端队列，快速随机访问，快速头尾增删。</td></tr><tr><td>list</td><td>双向列表，双向顺序访问，快速任意增删。</td></tr><tr><td>forward_list</td><td>单向列表，单向顺序访问，快速任意增删。</td></tr><tr><td>array</td><td>固定大小数组，快速随机访问，不可增删。</td></tr><tr><td>string</td><td>与vector性质相似，专门保存字符。</td></tr></tbody></table><table><thead><tr><th>顺序容器适配器</th><th>描述</th></tr></thead><tbody><tr><td>stack</td><td>栈</td></tr><tr><td>queue</td><td>队列</td></tr><tr><td>priority_queue</td><td>优先队列</td></tr></tbody></table><h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><table><thead><tr><th>关联容器</th><th>描述</th></tr></thead><tbody><tr><td>map</td><td>关联数组，保存key-value对。</td></tr><tr><td>unordered_map</td><td>map的无序版本。</td></tr><tr><td>set</td><td>只保存key的容器。</td></tr><tr><td>unordered_set</td><td>set的无序版本。</td></tr><tr><td>multimap</td><td>key可重复出现的map。</td></tr><tr><td>unordered_multimap</td><td>multimap的无序版本。</td></tr><tr><td>multiset</td><td>key可重复出现的set。</td></tr><tr><td>unordered_multiset</td><td>multiset的无序版本。</td></tr></tbody></table><p>有序关联容器要求key值类型必顺定义&lt;运算符。无序关联容器则要求key值定义==运算符。</p><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p><code>iterator</code>: 容器的迭代器类型。</p><p><code>const_iterator</code>: 迭代器的只读版本。</p><p><code>size_type</code>: 无符号整数类型，保存最大容器大小。</p><p><code>differenct_type</code>: 带符号整数类型，保存两个迭代器间的距离。</p><p><code>value_type</code>: 元素类型。</p><p><code>reference</code>: 元素的左值类型，含义为value_type&amp;。</p><p><code>const_reference</code>: 元素的const左值类型，含义为const value_type&amp;。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>C c;</code>：默认构造函数，构造一个空容器。</p><p><code>C c1(c2)</code>：构造c2的拷贝c1。</p><p><code>C c(b, e)</code>：构造c并将迭代器b和e之间的元素拷贝到c。</p><p><code>C c&#123;a, b, c, d, e...&#125;</code>：列表初始化c。</p><h4 id="赋值与swap"><a href="#赋值与swap" class="headerlink" title="赋值与swap"></a>赋值与swap</h4><p><code>c1 = c2</code>：将c1中的元素替换为c2中的元素。</p><p><code>c = &#123;a, b, c, d...&#125;</code>：将c中的元素替换为列表中的元素（array不可用）。</p><p><code>a.swap(b)</code>, <code>swap(a, b)</code>：交换a,b中的元素。</p><h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><p><code>c.size()</code>：c中元素数目。</p><p><code>c.max_size()</code>：c最大可保存元素数目。</p><p><code>c.empty</code>：c是否为空。</p><h4 id="增删元素（array不可用）"><a href="#增删元素（array不可用）" class="headerlink" title="增删元素（array不可用）"></a>增删元素（array不可用）</h4><p><code>c.insert(args)</code>：将args中的元素拷贝进c。</p><p><code>c.emplace(inits)</code>：使用inits构造c中的一个元素。inits必需与元素的构造函数匹配。</p><p><code>c.erase(args)</code>：删除c中的指定元素。</p><p><code>c.clear()</code>：删除c中所有元素，返回void。</p><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p><code>==</code>，<code>!=</code>：所有容器都支持。</p><p><code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code>：除无序关联容器外都支持。</p><h4 id="获取迭代器"><a href="#获取迭代器" class="headerlink" title="获取迭代器"></a>获取迭代器</h4><p><code>c.begin()</code>，<code>c.end()</code>：返回首迭代器和尾后迭代器。</p><p><code>c.cbegin()</code>，<code>c.cend()</code>：返回const迭代器。</p><h4 id="反向迭代器-不支持forward-list"><a href="#反向迭代器-不支持forward-list" class="headerlink" title="反向迭代器(不支持forward_list)"></a>反向迭代器(不支持forward_list)</h4><p><code>reverse_iterator</code>：按逆序寻址元素的迭代器</p><p><code>const_reverse_iterator</code>：反向迭代器的只读版本。</p><p><code>c.rbegin()</code>，<code>c.rend()</code>：返回尾迭代器和首前迭代器。</p><p><code>c.crbegin()</code>，<code>c.crend()</code>：返回const反向迭代器。</p><h3 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h3><p><strong>总是可以使用两个迭代器的范围表示多个已存在元素，用(n, t)或{a, b, c…}表示多个新元素。将这三种表示方法称为range</strong></p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>C seq(n)</code>：一个包含n个元素的顺序容器。</p><p><code>C seq(range)</code>：一个元素为range的顺序容器。</p><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p><code>seq.assign(range)</code>：将seq中元素替换为迭代器range中的元素，b的e不可指向seq中的元素。</p><h4 id="关系运算符-1"><a href="#关系运算符-1" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>两个大小相等且对位元素相等的顺序容器相等。</p><p>顺序容器a是另一个顺序容器b的前缀子序列时，a &lt; b。</p><p>否则，以两容器中第一对不相等的元素的大小关系作为结果。</p><h4 id="增删元素（array不支持）"><a href="#增删元素（array不支持）" class="headerlink" title="增删元素（array不支持）"></a>增删元素（array不支持）</h4><ul><li>forward_list有专有的emplace、insert和erase操作。</li><li>forward_list不支持push_back、emplace_back和pop_back。</li><li>vector和string不支持push_front、emplace_front和pop_front。</li></ul><p><code>c.push_back(t)</code>，<code>c.emplace_back(inits)</code>：在尾部创建一个元素。</p><p><code>c.push_front(t)</code>，<code>c.emplace_front(inits)</code>：在首部创建一个元素。</p><p><code>c.insert(p, t)</code>，<code>c.emplace(p, inits)</code>：在迭代器p位置之前添加一个元素，返回新元素的迭代器。</p><p><code>c.insert(p, range)</code>：在p之前添加n个值为t的元素。返回第一个新元素的迭代器。</p><p><strong>任何添加操作都会导致指向容器内元素的迭代器、指针和引用失效。</strong></p><p><code>c.pop_back()</code>：删除c的尾元素，c为空时UB。</p><p><code>c.pop_front()</code>：删除c的首元素，c为空时UB。</p><p><code>c.erase(p)</code>：删除迭代器p指向的元素，返回下一个元素的迭代器。p为尾后迭代器时UB。</p><p><code>c.erase(b, e)</code>：删除迭代器b, e范围内的所有元素，返回下一个元素的迭代器。</p><p><code>c.clear()</code>：删除所有元素，返回void。</p><p><strong>删除deque中除首尾元素的任何元素会导致迭代器、指针和引用失效。</strong></p><p><strong>删除vector或string中的元素会导致删除点之后的迭代器、指针和引用失效。</strong></p><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><ul><li>at和下标操作不适用于任何list。</li><li>back不适用forward_list。</li></ul><p><code>c.back()</code>：返回c中尾元素的引用。c为空时UB。</p><p><code>c.front()</code>：返回c中首元素的引用。c为空时UB。</p><p><code>c[n]</code>，<code>c.at(n)</code>：返回下标为n的元素的引用。[下标]越界UB。at(下标)越界抛出一个out_of_range异常。</p><h4 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h4><p><code>c.resize(n)</code>：将容器大小调整为n，若缩小则丢弃多余元素，增大则添加新元素。</p><p><code>c.resize(n, t)</code>：若增大则添加值为t的新元素。</p><h4 id="forward-list特有操作"><a href="#forward-list特有操作" class="headerlink" title="forward_list特有操作"></a>forward_list特有操作</h4><p><code>lst.before_begin()</code>：返回首前迭代器，不可解引用。</p><p><code>lst.cbefore_begin()</code>：返回首前迭代器的只读版本。</p><p><code>lst_insert_after(p, args)</code>，<code>emplace_after(p, inits)</code>：在p后添加元素，参数形式与通用的insert相同。</p><p><code>lst_erase_after(p)</code>，<code>lst_erase_after(p, e)</code>：删除p之后的一个或一段元素，返回下一个位置。</p><h4 id="缓存操作"><a href="#缓存操作" class="headerlink" title="缓存操作"></a>缓存操作</h4><p><code>c.shrink_to_fit()</code>：将实际内存占用减少为与size()相同。只适用于vector，string和deque</p><p><code>c.capacity()</code>：已分配的实际内存可以保存多少元素。只适用于vector和string。</p><p><code>c.reserve(n)</code>：分配至少能容纳n个元素的空间。只适用于vector和string。</p><h4 id="string特有操作"><a href="#string特有操作" class="headerlink" title="string特有操作"></a>string特有操作</h4><h5 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h5><p><code>string s(cp, n)</code>：cp指向数组中前n个字符。</p><p><code>string s(s2, pos, len = 0)</code>：字符串s2从下标pos开始的len个字符。下标越界则UB。</p><p><code>s.sub_str(pos = 0, n = s.size() - pos)</code>：返回s从下标pos开始的n的字符的拷贝。</p><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><p>string提供了六个不同的搜索函数，每个函数又有4个重载版本。它们成功时返回匹配位置的下标，失败则返回<code>string::npos</code>。返回数类型都是<code>string::size_type</code>，是无符号整数类型。</p><p><code>s.find(args)</code>：args第一次出现的位置。</p><p><code>s.rfind(args)</code>：args最后一次出现的位置。</p><p><code>s.find_first_of(args)</code>：args中任一字符第一次出现的位置。</p><p><code>s.find_last_of(args)</code>：args中任一字符最后一次出现的位置。</p><p><code>s.find_first_not_of(args)</code>：第一次出现不属于args中的字符的位置。</p><p><code>s.find_last_not_of(args)</code>：最后一次出现不属于args中的字符的位置。</p><p>args为以下四种形式之一：</p><p><code>c, pos</code>：从pos处开始查找字符c，pos默认为0。</p><p><code>str, pos</code>：从pos处开始查找字符串str，pos默认为0。</p><p><code>cp, pos</code>：从pos处开始查找C风格字符串指针cp，pos默认为0。</p><p><code>cp, pos, n</code>：从pos开始查找指针cp指向的数组的前n个字符。pos和n皆无默认值。</p><h5 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h5><p><code>s.compare(args)</code>：跟据比较结果等于，小于或大于args，返回0，负数或正数。</p><p>args为以下形式之一：</p><p><code>s2</code>：与字符串s2比较。</p><p><code>pos1, n1, s2</code>：从pos1开始的n1个字符与s2比较。</p><p><code>pos1, n1, s2, pos2, n2</code>：从pos1开始的n1人字符与s2中从pos2开始的n2的字符比较。</p><p><code>cp</code>：与C风格字符串cp比较。</p><p><code>pos1, n1, cp</code>：从pos1开始的n1个字符与cp比较。</p><p><code>pos1, n1, cp, n2</code>：从pos1开始的n1个字符与从cp开始的n2个字符比较。</p><h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><p><code>to_string(val)</code>：返回val的string表示。</p><p><code>sto&#123;type&#125;(s, p, b)</code>：返回s起始的子串的数值，由type指定返回值类型。b表示进制，默认为10。p是size_t指针，用来保存第一个非数值字符的下标，默认为0，即不保存下标。type可以为：i (int)、l (long)、ul (unsigned long)、ll (long long)、ull (unsigned long long)。</p><p><code>sto&#123;type&#125;(s, p)</code>：基本同上，返回浮点数，不能指定进制。type可以为：f (float)、d (double)、ld (long double)。</p><h4 id="容器适配器操作"><a href="#容器适配器操作" class="headerlink" title="容器适配器操作"></a>容器适配器操作</h4><p><code>container_type</code>：实现适配器的底层容器类型。</p><ul><li><p>stack</p><p><code>s.pop</code>：删除栈顶元素。</p><p><code>s.push(item)</code>：压入元素item的拷贝或移动。</p><p><code>s.emplace(args)</code>：压入由args构造的元素。</p><p><code>s.top()</code>：返回栈顶元素。</p></li><li><p>queue &amp; priority_queue</p><p>// 通用</p><p><code>q.pop()</code>：删除queue的首元素或priority_queue最高优先级的元素。</p><p><code>s.push(item)</code>：加入元素item的拷贝或移动。</p><p><code>s.emplace(args)</code>：加入由args构造的元素。</p><p>// 仅适用于queue</p><p><code>q.front()</code>：返回首元素。</p><p><code>q.back()</code>：返回尾元素。</p><p>// 仅适用于priority_queue</p><p><code>q.top()</code>：返回最高优先级元素。</p></li></ul><h3 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h3><p><code>key_type</code>：关键字类型。</p><p><code>mapped_type</code>：映射类型，仅适用于map。</p><p><code>value_type</code>：值类型，对于set与<code>key_type</code>等效，对于map等于<code>pair&lt;const key_type, mapped_type&gt;</code>。</p><h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>可以通过<code>begin()</code>和<code>end()</code>获取对应的迭代器从而实现遍历。</p><h5 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h5><p><code>c.insert(v)</code>：对于map和set，key值重复的插入会失败，返回一个bool表示是否成功。而multimap和multiset可以插入key值重复的元素，返回指向该元素的迭代器。</p><p><code>c.emplace(args)</code>：行为同上，使用args构建元素。</p><p><code>c.insert(b, e)</code>：插入迭代器范围内的元素。</p><p><code>c.insert(li)</code>：插入初始化列表中的元素。</p><p><code>c.insert(p, v)</code>：从迭代器位置开始插入元素。</p><p><code>c.emplace(p, args)</code>：同上。</p><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><p><code>c.erase(k)</code>：删除所有key值为k的元素。</p><p><code>c.erase(p)</code>：删除迭代器指向的元素。</p><p><code>c.erase(b, e)</code>：删除迭代器范围内的元素。</p><h5 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h5><p><code>map[key]</code>：取得key对应的value，如果key不存在则创建新元素。</p><h5 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h5><p><code>c.find(k)</code>：返回指向第一个key值为k的元素的迭代器。</p><p><code>c.count(k)</code>：返回key值为k的元素的数量。</p><p><code>c.lower_bound(k)</code>：返回指向第一个key值不小于k的元素的迭代器。</p><p><code>c.upper_bound(k)</code>：返回指向第一个key值大于k的元素的迭代器。</p><p><code>c.equal_range(k)</code>：返回一个迭代器pair，表示关键字等于k的元素的范围。</p><h5 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h5><p>无序容器<code>unorderd_map</code>和<code>unordered_set</code>，在存储上组织为一组桶，每个桶保存0或多个元素。使用hash函数将元素映射到桶。因此，无序元素的性能依赖于hash函数的质量和桶的数量与大小。</p><p>适用于有序容器的操作也适用于无序容器，此外无序容器提供了一组管理桶的函数：</p><p><code>c.bucket_count()</code>：正在使用的桶的数目。</p><p><code>c.max_bucket_count()</code>：容器能容纳的最多的桶的数目。</p><p><code>c.bucket_size(n)</code>：第n个桶中有多少元素。</p><p><code>c.bucket(k)</code>：关键字为k的元素在哪个桶中。</p><p><code>local_iterator</code>：用来访问桶中元素的迭代器类型。</p><p><code>const_local_iterator</code>：迭代器的const版本。</p><p><code>c.begin(n)</code>、<code>c.end(n)</code>、<code>c.cbegin(n)</code>、<code>c.cend(n)</code>：桶n的对应迭代器。</p><p><code>c.load_factor()</code>：每个桶的平均元素数量，返回float值。</p><p><code>c.max_load_factor()</code>：c试图维护的平均桶大小，返回float值。c会在需要时添加新的桶，使load_factor &lt;= max_load_factor。</p><p><code>c.rehash(n)</code>：重组存储，使bucket_count &gt;= n且bucket_count &gt; size / max_load_factor。</p><p><code>c.reserve(n)</code>：重组存储，使c可以保存n个元素而不用rehash。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无序容器的使用</span></span><br><span class="line"><span class="function">T1 <span class="title">hash</span><span class="params">(args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(T2 a, T2 b)</span></span>;</span><br><span class="line"><span class="comment">// 由于模版参数接受的是类型，使用decltype取得函数的类型。</span></span><br><span class="line">unordered_map&lt;T2, <span class="keyword">decltype</span>(hash)*, <span class="keyword">decltype</span>(equal)*&gt; foo;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0x01 C++之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++变量初始化</title>
      <link href="/zh/blog/2021/07/19/0019-C++:Variable_initialization/"/>
      <url>/zh/blog/2021/07/19/0019-C++:Variable_initialization/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用列表初始化时发现记忆很模糊，写下来备忘顺便总结一下。</p></blockquote><span id="more"></span><h2 id="初始化的概念"><a href="#初始化的概念" class="headerlink" title="初始化的概念"></a>初始化的概念</h2><p>初始化是指<strong>创建变量时赋予其一个初始值</strong>。特别要注意C++中初始化与赋值的区别，赋值的含义是抹去原有的值后赋予一个新值。不可以将赋值和初始化混为一谈。</p><p>比如对于一个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Whatever</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Whatever</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> v1;</span><br><span class="line">    <span class="keyword">int</span> v2;</span><br><span class="line">    std::string key;</span><br><span class="line">    OtherClass value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>考虑其构造函数两种定义形式的区别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用初始值列表</span></span><br><span class="line">Whatever::<span class="built_in">Whatever</span>() : <span class="built_in">v1</span>(...), <span class="built_in">v2</span>(...), <span class="built_in">key</span>(...), <span class="built_in">value</span>(...) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构造函数内赋值</span></span><br><span class="line">Whatever::<span class="built_in">Whatever</span>() &#123;</span><br><span class="line">    v1 = ...;</span><br><span class="line">    v2 = ...;</span><br><span class="line">    key = ...;</span><br><span class="line">    value = ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方式的区别在于，只有使用了初始值列表的方式真正实现了初始化，而构造函数内赋值的做法等价于先<em>默认初始化</em>一个对象中的所有成员再分别对其中的成员赋值。由于我们创建一个对象后马上就会调用它的构造函数，这两种方法似乎并没有显著的区别。</p><p>考虑到初始化和赋值的过程，可以知道先初始化再赋值的开销至少是直接初始化的两倍。对于一个内置类型的成员而言这样的代价可以忽略不计，然而一个类类型成员的构造代价却有可能非常大。因此，定义构造函数时应尽量使用初始值列表的方式，这不单是为了节省这些性能，也是一个语义上的准确表达。</p><h2 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h2><p>定义一个变量而不显式指定初始值时，变量被默认初始化。默认初始化的规则如下</p><ul><li>类类型对象：由类的默认构造函数定义。</li><li>内置类型对象：<ul><li>全局对象：初值为0。</li><li>非全局对象：不初始化，其值为未定义的，取决于分配到的内存块上已存在的值。</li></ul></li></ul><p>试图默认初始化一个不允许默认初始化的类类型对象将导致编译错误。</p><h2 id="直接初始化"><a href="#直接初始化" class="headerlink" title="直接初始化"></a>直接初始化</h2><p>定义时显式地调用对象的构造函数称为直接初始化，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>注意，只有定义时调用构造函数才是初始化，通过构造函数修改已存在变量的值也是赋值操作。</p><h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>在C++11之前，可以对POD（Plain Old Data，即可以使用memcpy拷贝的类型）类型和内置数组进行列表初始化，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 列表初始化, x = 1, y = 2</span></span><br><span class="line">A a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// 列表初始化, x = 1, y默认构造</span></span><br><span class="line">A a = &#123;<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>C++11以后，这种初始化方式得到了普及，现在可以对任何对象使用列表初始化并且无需<code>=</code>号。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::string str&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>列表初始化有一个重要特性，内置类型不会进行隐式类型转换。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1.5</span>; <span class="comment">// a == 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">(<span class="number">1.5</span>)</span></span>;  <span class="comment">// b == 1</span></span><br><span class="line"><span class="keyword">int</span> c&#123;<span class="number">1.5</span>&#125;;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>列表初始化和初始化列表有关系吗？答案是大有关系。列表初始化就是根据定义了初始化列表的构造函数初始化对象的。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">A&#123;a, b&#125; == <span class="built_in">A</span>(a, b) <span class="comment">// .x == a, .y == b</span></span><br></pre></td></tr></table></figure><p>那么类似于数组形式的列表初始化是如何实现的呢？使用<code>std::initializer_list</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span>(initializer_list&lt;<span class="keyword">int</span>&gt; list) </span><br><span class="line">    : <span class="built_in">size</span>(list.<span class="built_in">size</span>()), <span class="built_in">head</span>(<span class="keyword">new</span> <span class="keyword">int</span>[size]) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : list) &#123;</span><br><span class="line">            *cur = i;</span><br><span class="line">            ++cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> *head;</span><br><span class="line">&#125;; <span class="comment">// 一个简单的数组， 可以接受任意数量的参数</span></span><br><span class="line">A&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; == <span class="built_in">A</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure><p>当同时存在接受参数的构造函数和接受<code>std::initializer_list</code>的构造函数时，列表初始化优先调用接受<code>std::initializer_list</code>的构造函数。</p><h2 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h2><p>使用<code>Type id = value</code>或<code>Type id(value) // value 为一个Type类型的变量</code>的形式定义的初始化称为拷贝初始化。其实质是使用另一个对象的值来构造对象，使用拷贝赋值运算符函数定义其行为。</p>]]></content>
      
      
      <categories>
          
          <category> 0x01 C++之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++三/五法则</title>
      <link href="/zh/blog/2021/07/18/0018-C++:The_rule_of_three_five/"/>
      <url>/zh/blog/2021/07/18/0018-C++:The_rule_of_three_five/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本以为三/五法则作为一个基础知识早已烂熟于心，未想纸上得来终是浅，还是在这个地方翻了次车。</p></blockquote><span id="more"></span><h2 id="什么是三-五法则"><a href="#什么是三-五法则" class="headerlink" title="什么是三/五法则"></a>什么是三/五法则</h2><ul><li>三法则：C++11之前，一个需要<code>析构函数</code>的类也需要<code>拷贝构造函数</code>和<code>拷贝赋值运算符</code>。这三个组件总是成套出现，因此叫三法则。</li><li>五法则：C++11以后，一个需要<code>析构函数</code>的类同时需要<code>拷贝构造函数</code>、<code>拷贝赋值运算符</code>和<code>移动构造函数</code>以及<code>移动赋值运算符</code>。成套出现的组件数量变成了五，因此叫五法则。</li></ul><p>对于这两个法则，虽然内容在添加移动语义后有一些变化，但核心思想都是一样的。即类的基础组件应该成套构成。因此合称为三/五法则。</p><h2 id="翻车实况"><a href="#翻车实况" class="headerlink" title="翻车实况"></a>翻车实况</h2><p>也许你会疑惑，这么浅显的地方怎么会翻车，看了这个翻车实况或许就会发现你也可能犯这样的错误。</p><p>起因是昨天写<a class="link"   href="https://blog.xilong.site/2021/07/18/0017-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" >二叉树的层序遍历<i class="fas fa-external-link-alt"></i></a>时，需要一个C++的实现，方便起见，我定义了一个非常简单的二叉链表结构来构造二叉树：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="built_in">Tree</span>() : <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">data</span>(<span class="number">0</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    Tree *left;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    Tree *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以及不可忽视的两点：</p><ol><li><p>我的遍历函数使用了<em><strong>常量引用传递</strong></em>的方式接收树</p></li><li><p>遍历函数内部用到了<code>std::queue</code>作为遍历队列。存储相关语句为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::queue&lt;Tree&gt; nodeQueue;</span></span><br><span class="line"><span class="comment">// cur = nodeQueue.front();</span></span><br><span class="line">nodeQueue.<span class="built_in">push</span>(T);</span><br><span class="line"><span class="keyword">if</span> (cur.left)  nodeQueue.<span class="built_in">push</span>(*cur.left);</span><br><span class="line"><span class="keyword">if</span> (cur.right) nodeQueue.<span class="built_in">push</span>(*cur.right);</span><br></pre></td></tr></table></figure></li></ol><p>函数签名：<code>void View(const Tree&amp; T);</code></p><p>同样是方便起见，我手动构造了一棵树用于测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tree *<span class="title">GetTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> T = <span class="keyword">new</span> Tree;</span><br><span class="line">    T-&gt;data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    T-&gt;left = <span class="keyword">new</span> Tree;</span><br><span class="line">    T-&gt;left-&gt;data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    T-&gt;right = <span class="keyword">new</span> Tree;</span><br><span class="line">    T-&gt;right-&gt;data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    T-&gt;right-&gt;left = <span class="keyword">new</span> Tree;</span><br><span class="line">    T-&gt;right-&gt;left-&gt;data = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    T-&gt;right-&gt;right = <span class="keyword">new</span> Tree;</span><br><span class="line">    T-&gt;right-&gt;right-&gt;data = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> T = <span class="built_in">GetTree</span>();</span><br><span class="line">    <span class="comment">// 正常情况下应该输出&quot;ABCDE&quot;</span></span><br><span class="line">    <span class="built_in">View</span>(*T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里没有<code>delete T</code>，内存是全部泄露的，不过这种简单程序反正有操作系统回收，可以先不用关心。</p><p>于是问题来了，在我用这个版本的程序完成算法的测试后，出于习惯给这个<code>Tree</code>加上了一个简单的析构函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="built_in">Tree</span>() : <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">data</span>(<span class="number">0</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Tree</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (left) <span class="keyword">delete</span> left;</span><br><span class="line">        <span class="keyword">if</span> (right) <span class="keyword">delete</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree *left;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    Tree *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并且在<code>main</code>函数内释放了内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> T = <span class="built_in">GetTree</span>();</span><br><span class="line">    <span class="built_in">View</span>(*T);</span><br><span class="line">    <span class="keyword">delete</span> T;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时运行程序就可以喜提一个<code>Segment Error</code>了。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>因为没有添加析构函数时并没有出现问题，所以总是怀疑自己对析构过程的理解有问题。难道析构函数不是自已理解的”死前抖擞精神，完成最后的任务，然后安详赴死“？对象在调用析构函数时最已经销毁了？不可能啊。</p><p>几经查阅后，发现我对析构过程的理解没有问题，对象在析构函数之后才被销毁。更离谱的是，我为了简化问题写的只存在树的构建的析构的程序运行起来完全没有出现问题。</p><p>于是我把目光投向了看起来安全的不能再安全的，接收<code>const Tree&amp;</code>类型参数的<code>View</code>函数。在出现问题的代码中将<code>View(*T);</code>注释掉，发现还真是这个函数的问题。</p><p>说来奇怪，还没有对问题做具体的分析，就直觉地想到改一下传参方式或许可以解决，于是我将<code>View</code>改成如下形式：</p><p>函数签名：<code>void View(const Tree *T)</code></p><p>存储语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::queue&lt;const Tree*&gt; nodeQueue;</span></span><br><span class="line"><span class="comment">// cur = nodeQueue.front();</span></span><br><span class="line"><span class="keyword">if</span> (T) nodeQueue.<span class="built_in">push</span>(T);</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;left)  nodeQueue.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) nodeQueue.<span class="built_in">push</span>(cur-&gt;right);</span><br></pre></td></tr></table></figure><p>然后果真没有问题了，这弄得我很疑惑。于是分析可能是<code>std::queue</code>相关的问题，但它也不会直接释放掉资源啊。一番思索，发现原因如下：</p><ul><li>对于<code>std::queue&lt;const Tree&gt;</code>，它在每一次<code>push(T)</code>时创建一个<code>T</code>的拷贝，并存储，由于<code>Tree</code>没有定义拷贝相关操作，会使用默认拷贝方式，即简单复制其中的指针。</li><li><code>std::queue</code>在<code>pop()</code>操作时会销毁临时对象。</li><li>当没有为<code>Tree</code>创建析构函数时，临时对象的销毁仅仅是简单销毁自身，因此没有出现问题。</li><li>而对于已经创建了析构函数的<code>Tree</code>，临时对象会递归地销毁其指针指向的子节点，此时再显式地<code>delete T</code>就会导致重复delete。从而引发<code>Segment Error</code>。</li></ul><p>因此，像上面那样使用指针传递的方式就解决了问题，这样临时对象的类型就变成了指针，从而不会对树本身产生影响。但这种方式本质上只是在逃避，并没有解决问题。</p><p>真正要解决这个问题，那还得是为<code>Tree</code>添加正确的拷贝构造函数、拷贝赋值运算符、移动构造函数和移动赋值运算符。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遵循三/五法则是一个类正常运行的基础，绝不能偷懒省略其中的组件。还好我以这样低的成本——一个测试算法用的临时程序——完成了三/五法则的试错。</p>]]></content>
      
      
      <categories>
          
          <category> 0x01 C++之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的层序遍历</title>
      <link href="/zh/blog/2021/07/18/0017-Binary_tree:Level_order_traversal/"/>
      <url>/zh/blog/2021/07/18/0017-Binary_tree:Level_order_traversal/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对之前的文章：<a class="link"   href="https://blog.xilong.site/2020/04/24/0004-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E9%9D%9E%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" >二叉树的存储结构及其非层序遍历<i class="fas fa-external-link-alt"></i></a>的一点小补充。</p></blockquote><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>使用一个队列来对每个节点进行<code>入队-加入子节点-访问-出队</code>的操作即可，非常简单。</p><p>伪码表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：待访问的二叉树Tree</span><br><span class="line">输出：对节点的层序访问</span><br><span class="line">View:</span><br><span class="line">  queue.push Tree</span><br><span class="line">  while !queue.empty:</span><br><span class="line">    if (Tree.left) queue.push Tree.left</span><br><span class="line">    if (Tree.right) queue.push Tree.right</span><br><span class="line">    Tree.show</span><br><span class="line">    queue.pop</span><br></pre></td></tr></table></figure><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单实现一个二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="built_in">Tree</span>() : <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">data</span>(<span class="number">0</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    Tree *left;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    Tree *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">View</span><span class="params">(<span class="keyword">const</span> Tree &amp;T)</span> </span>&#123;</span><br><span class="line">    queue&lt;Tree&gt; nodeQueue;</span><br><span class="line">    nodeQueue.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (!nodeQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = nodeQueue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (cur.left) nodeQueue.<span class="built_in">push</span>(*cur.left);</span><br><span class="line">        <span class="keyword">if</span> (cur.right) nodeQueue.<span class="built_in">push</span>(*cur.right);</span><br><span class="line">        nodeQueue.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; cur.data;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Haskell实现"><a href="#Haskell实现" class="headerlink" title="Haskell实现"></a>Haskell实现</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> = <span class="type">Empty</span> | <span class="type">Node</span> <span class="type">Tree</span> <span class="type">String</span> <span class="type">Tree</span></span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将树转变为层序遍历序列</span></span><br><span class="line"><span class="title">view</span> :: <span class="type">Tree</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">view</span> = view&#x27;.view&#x27;&#x27;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">    <span class="comment">-- 将一个树的列表转变为对应的值的列表</span></span><br><span class="line">    view&#x27; :: [<span class="type">Tree</span>] -&gt; <span class="type">String</span></span><br><span class="line">    view&#x27; [] = <span class="string">&quot;&quot;</span></span><br><span class="line">    view&#x27; ((<span class="type">Node</span> _ str _):xs) = str ++ view&#x27; xs</span><br><span class="line">    <span class="comment">-- 将一个树转变为其层序遍历的列表</span></span><br><span class="line">    view&#x27;&#x27; :: <span class="type">Tree</span> -&gt; [<span class="type">Tree</span>]</span><br><span class="line">    view&#x27;&#x27; <span class="type">Empty</span> = []</span><br><span class="line">    view&#x27;&#x27; t = extend [t] <span class="number">0</span></span><br><span class="line">        <span class="keyword">where</span></span><br><span class="line">        extend :: [<span class="type">Tree</span>] -&gt; <span class="type">Int</span> -&gt; [<span class="type">Tree</span>]</span><br><span class="line">        extend ts n = <span class="keyword">if</span>(n &gt;= length ts) <span class="keyword">then</span> ts</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">case</span> (ts!!n) <span class="keyword">of</span></span><br><span class="line">                (<span class="type">Node</span> left _ right) -&gt; extend (ts </span><br><span class="line">                    ++ (<span class="keyword">if</span> (left == <span class="type">Empty</span>) <span class="keyword">then</span> [] <span class="keyword">else</span> [left]) </span><br><span class="line">                    ++ (<span class="keyword">if</span> (right == <span class="type">Empty</span>) <span class="keyword">then</span> [] <span class="keyword">else</span> [right])) </span><br><span class="line">                    (n + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>Haskell学艺不精，写得挺丑，留待日后优化吧。</p>]]></content>
      
      
      <categories>
          
          <category> 0x00 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的Haskell（二）——ADT</title>
      <link href="/zh/blog/2021/07/17/0016-Re0:Haskell_02/"/>
      <url>/zh/blog/2021/07/17/0016-Re0:Haskell_02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是系列的第二篇，主题是ADT：代数数据类型。</p></blockquote><span id="more"></span><h2 id="前言：关于Haskell与数学基础"><a href="#前言：关于Haskell与数学基础" class="headerlink" title="前言：关于Haskell与数学基础"></a>前言：关于Haskell与数学基础</h2><p>网上冲浪时看见很多类似于“学好Haskell一定要学会抽象代数和范畴论”这类的言论，这一度动摇了我学习Haskell的信心，考虑着是不是先学习相关的数学理论。后来想了想，或许学好Haskell一定要学会这些，但在入门阶段并不需要过于在意其中的数学原理，先上手再说。</p><p>就像我们学习C++的过程中，操作系统、计算机组成和数据结构相关的知识是非常有帮助的。了解了整个计算机体系后，理解C++的涉及底层的概念会非常容易。但我们也不必因此在入门阶段就直接去学习整个计算机原理。</p><p>于是废话说完，开始这次的Haskell之旅。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>Haskell使用如下语法创建枚举（Enum）类型：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Thing</span> = <span class="type">Shoe</span></span></span><br><span class="line">           | <span class="type">Ship</span></span><br><span class="line">           | <span class="type">SealingWax</span></span><br><span class="line">           | <span class="type">Cabbage</span></span><br><span class="line">           | <span class="type">King</span></span><br><span class="line">  <span class="keyword">deriving</span> <span class="type">Show</span></span><br></pre></td></tr></table></figure><p>这段代码定义了一个名为<code>Thing</code>的类型，它有5个值构造器（data constructors），这些值构造器就是<code>Thing</code>可能拥有的值。</p><p><code>deriving Show</code>为<code>Thing</code>加载了显示功能，这使得它可以被当做字符串打印，这其中的细节之后再说。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用Thing</span></span><br><span class="line"><span class="comment">-- 作为变量</span></span><br><span class="line"><span class="title">shoe</span> :: <span class="type">Thing</span></span><br><span class="line"><span class="title">shoe</span> = <span class="type">Shoe</span></span><br><span class="line"><span class="comment">-- 作为列表类型</span></span><br><span class="line"><span class="title">listOfThings</span> :: [<span class="type">Thing</span>]</span><br><span class="line"><span class="title">listOfThings</span> = [<span class="type">Shoe</span>, <span class="type">Ship</span>, <span class="type">SealingWax</span>]</span><br><span class="line"><span class="comment">-- 作为函数参数</span></span><br><span class="line"><span class="title">isSmall</span> :: <span class="type">Thing</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isSmall</span> <span class="type">Shoe</span>       = <span class="type">True</span></span><br><span class="line"><span class="title">isSmall</span> <span class="type">Ship</span>       = <span class="type">False</span></span><br><span class="line"><span class="title">isSmall</span> <span class="type">SealingWax</span> = <span class="type">True</span></span><br><span class="line"><span class="title">isSmall</span> <span class="type">Cabbage</span>    = <span class="type">True</span></span><br><span class="line"><span class="title">isSmall</span> <span class="type">King</span>       = <span class="type">False</span></span><br></pre></td></tr></table></figure><p>可以看到枚举类型的用途和我们在其它语言中用到的enum很相似。</p><h2 id="不只是枚举"><a href="#不只是枚举" class="headerlink" title="不只是枚举"></a>不只是枚举</h2><p>其实在Haskell中，枚举类型只是一个ADT（Algebraic Data Types，代数数据类型）的特例。下面是一个不是枚举类型的ADT：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">FailableDouble</span> = <span class="type">Failure</span></span></span><br><span class="line">                    | <span class="type">OK</span> <span class="type">Double</span></span><br><span class="line">  <span class="keyword">deriving</span> <span class="type">Show</span></span><br></pre></td></tr></table></figure><p>这个<code>FailableDouble</code>类型有两个值构造器，第一个值构造器<code>Failure</code>不接受参数，所以它本身就是<code>FailableDouble</code>的值；而第二个值构造器<code>OK</code>接受一个<code>Double</code>类型的参数，因此它本身并不成为<code>FailableDouble</code>的值，需要加上一个<code>Double</code>才能做为值。比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ex01</span> = <span class="type">Failure</span></span><br><span class="line"><span class="title">ex02</span> = <span class="type">OK</span> <span class="number">3.4</span></span><br></pre></td></tr></table></figure><p>思考：<code>OK</code>的类型是什么？</p><p>它看起来像接收一个<code>Double</code>，返回一个<code>FailableDouble</code>的函数，用起来也像这样一个函数，那么我说，它就是一个<code>Double -&gt; FailableDouble</code>类型的函数。</p><p>既然值构造器的类型是函数，那么理所当然地，<strong>值构造器可以接受多个参数</strong>。由此可以创建一个这样的类型：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> <span class="type">String</span> <span class="type">Int</span> <span class="type">Thing</span></span></span><br><span class="line">  <span class="keyword">deriving</span> <span class="type">Show</span></span><br></pre></td></tr></table></figure><p>注意这里的两个<code>Person</code>是不同的，等号左侧的<code>Person</code>称为类型构造器，用于指代类型；而等号右侧的<code>Person</code>是一个与类型构造器同名的值构造器，用于生成一个具体的<code>Person</code>类型的值。比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">brent</span> :: <span class="type">Person</span>                      <span class="comment">-- 类型构造器，说明类型</span></span><br><span class="line"><span class="title">brent</span> = <span class="type">Person</span> <span class="string">&quot;Brent&quot;</span> <span class="number">31</span> <span class="type">SealingWax</span> <span class="comment">-- 值构造器，生成一个值</span></span><br></pre></td></tr></table></figure><p>这还导致了一个有趣的现象，就是你在类型声明中使用的永远是类型构造器，而在需要这个类型的值的地方使用的永远是值构造器。</p><h2 id="一般形式的ADT"><a href="#一般形式的ADT" class="headerlink" title="一般形式的ADT"></a>一般形式的ADT</h2><p>通常一个ADT有一个或多个值构造器，而每个值构造器接收一个或多个参数。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ADT</span> = <span class="type">Constr1</span> <span class="type">Type11</span> <span class="type">Type12</span></span></span><br><span class="line">         | <span class="type">Constr2</span> <span class="type">Type21</span></span><br><span class="line">         | <span class="type">Constr3</span> <span class="type">Type31</span> <span class="type">Type32</span> <span class="type">Type33</span></span><br><span class="line">         | <span class="type">Constr4</span></span><br><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment">声明了一个名为ADT且含有4个值构造器的ADT，这四个值构造器分别接受不同数量的不同类型参数。</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br></pre></td></tr></table></figure><p>注意：类型构造器与值构造器的标识符永远以大写字母开头，而变量（包括函数）永远以小写字母开头。</p><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>根本上，模式匹配就是通过找出值构造器来对值进行分解。比如说，要想对上一节定义的类型<code>ADT</code>中的值进行操作，我们只要这样写：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> (<span class="type">Constr1</span> a b)   = ...</span><br><span class="line"><span class="title">foo</span> (<span class="type">Constr2</span> a)     = ...</span><br><span class="line"><span class="title">foo</span> (<span class="type">Constr3</span> a b c) = ...</span><br><span class="line"><span class="title">foo</span> <span class="type">Constr4</span>         = ...</span><br></pre></td></tr></table></figure><p>注意这里使用a、b、c为值命名，以及接受参数的值构造器要包围在括号里。</p><p>这就是模式匹配的主要思想了，但还有一些值得注意的地方：</p><ol><li><p>下划线<code>_</code>可以匹配任何东西。</p></li><li><p>x@pat形式的模式可以在以pat匹配值的同时用x匹配整个值。例：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">baz</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">baz</span> p@(<span class="type">Person</span> n _ _) = <span class="string">&quot;The name field of (&quot;</span> ++ show p ++ <span class="string">&quot;) is &quot;</span> ++ n</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;- </span></span><br><span class="line"><span class="comment">运行：baz brent</span></span><br><span class="line"><span class="comment">结果：&quot;The name field of (Person \&quot;Brent\&quot; 31 SealingWax) is Brent&quot;</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>模式可以嵌套。例：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">checkFav</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">checkFav</span> (<span class="type">Person</span> n _ <span class="type">SealingWax</span>) = n ++ <span class="string">&quot;, you&#x27;re my kind of person!&quot;</span></span><br><span class="line"><span class="title">checkFav</span> (<span class="type">Person</span> n _ _)          = n ++ <span class="string">&quot;, you favorite thing is lame.&quot;</span></span><br></pre></td></tr></table></figure><p>注意这里的<code>Person</code>和<code>SealingWax</code>是嵌套的模式。</p></li></ol><p>注意，对于像<code>2</code>和<code>&#39;c&#39;</code>这样字面值，可以看做是一个不接受参数的值构造器。</p><h2 id="case表达式"><a href="#case表达式" class="headerlink" title="case表达式"></a>case表达式</h2><p>case表达式是Haskell中一个用于模式匹配的基础结构：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">case</span> exp <span class="keyword">of</span></span><br><span class="line">  pat1 -&gt; exp1</span><br><span class="line">  pat2 -&gt; exp2</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>其机制为使用exp从上而下地依次匹配模式，表达式的值为第一个匹配成功的模式对应的表达式的值。例：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">failureToZero&#x27;</span> :: <span class="type">FailableDouble</span> -&gt; <span class="type">Double</span></span><br><span class="line"><span class="title">failureToZero&#x27;</span> x = <span class="keyword">case</span> x <span class="keyword">of</span></span><br><span class="line">                    <span class="type">Failure</span> -&gt; <span class="number">0</span></span><br><span class="line">                    <span class="type">OK</span> d -&gt; d</span><br></pre></td></tr></table></figure><h2 id="递归数据结构"><a href="#递归数据结构" class="headerlink" title="递归数据结构"></a>递归数据结构</h2><p>数据结构可以是递归的，即自己可以是自己的组成部分。比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义一个`Int`类型的列表</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IntList</span> = <span class="type">Empty</span> | <span class="type">Cons</span> <span class="type">Int</span> <span class="type">IntList</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> = <span class="type">Leaf</span> <span class="type">Char</span></span></span><br><span class="line">          | <span class="type">Node</span> <span class="type">Tree</span> <span class="type">Int</span> <span class="type">Tree</span></span><br><span class="line">  <span class="keyword">deriving</span> <span class="type">Show</span></span><br><span class="line">  </span><br><span class="line"><span class="title">lst</span> :: <span class="type">IntList</span></span><br><span class="line"><span class="title">lst</span> = <span class="type">Cons</span> <span class="number">1</span> (<span class="type">Cons</span> <span class="number">2</span> <span class="type">Empty</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">tree</span> :: <span class="type">Tree</span></span><br><span class="line"><span class="title">tree</span> = <span class="type">Node</span> (<span class="type">Leaf</span> &#x27;x&#x27;) <span class="number">1</span> (<span class="type">Node</span> (<span class="type">Leaf</span> &#x27;y&#x27;) <span class="number">2</span> (<span class="type">Leaf</span> &#x27;z&#x27;))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0x03 从零开始的Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github之禁忌的双重污染</title>
      <link href="/zh/blog/2021/07/16/0015-Double_pollution_of_Github/"/>
      <url>/zh/blog/2021/07/16/0015-Double_pollution_of_Github/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Http被污染的时候，我没有说话，因为我用SSH。</p><p>SSH被污染的时候，我只好乖乖地去修改我的host文件了。</p></blockquote><span id="more"></span><h2 id="查询正确的IP地址"><a href="#查询正确的IP地址" class="headerlink" title="查询正确的IP地址"></a>查询正确的IP地址</h2><p>使用这个网站<a class="link"   href="https://www.ipaddress.com/" >ipaddress.com<i class="fas fa-external-link-alt"></i></a>进行查询，输入域名获得IP地址。</p><p>查询结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 注意，这个ip地址可能会改变，每次配置前最好重新查询</span><br><span class="line">github.com: 140.82.112.4</span><br><span class="line">global-ssh.fastly.net: 199.232.4.249</span><br></pre></td></tr></table></figure><h2 id="修改host文件"><a href="#修改host文件" class="headerlink" title="修改host文件"></a>修改host文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># /etc/hosts</span><br><span class="line"># 在末尾添加以下记录</span><br><span class="line"># github</span><br><span class="line">140.82.112.4 github.com</span><br><span class="line">140.82.112.4 raw.githubusercontent.com</span><br><span class="line">140.82.112.4 user-images.githubusercontent.com</span><br><span class="line">140.82.112.4 avatars2.githubusercontent.com</span><br><span class="line">140.82.112.4 avatars1.githubusercontent.com</span><br><span class="line"></span><br><span class="line"># ssh</span><br><span class="line">199.232.4.249 global-ssl.fastly.net</span><br><span class="line">199.232.4.249 github.global-ssl.fastly.net</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0x02 技术杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Great Wall </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用移动硬盘制作本地git仓库</title>
      <link href="/zh/blog/2021/06/27/0014-Make_a_local_git_repository/"/>
      <url>/zh/blog/2021/06/27/0014-Make_a_local_git_repository/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在一个普通的日子，突然想到用闲置的移动硬盘做一个本地git仓库。简单的理了理思路，确定了几个步骤：</p><ol><li>准备硬盘，比如分区与格式化。</li><li>自动挂载硬盘，实现即插即用。</li><li>使用硬盘托管代码。</li></ol><p>于是放了一首歌，戴上耳机，哼着小曲开始了这次折腾。</p></blockquote><span id="more"></span><h2 id="制备硬盘"><a href="#制备硬盘" class="headerlink" title="制备硬盘"></a>制备硬盘</h2><p>使用fdisk将这块硬盘上的分区全部删除，然后创建一个新的分区，具体步骤这里略过。</p><p>现在是时候格式化分区了，就决定是你了Ext4……等等，既然这个分区只是用来托管代码，为什么不试试没用过的文件系统呢？就决定是你了——Btrfs！</p><p>查阅了ArchWiki，Btrfs的介绍是这样的：</p><blockquote><p>Btrfs 是一种新型的写时复制 (CoW) Linux 文件系统，已经并入内核主线。Btrfs  在设计实现高级功能的同时，着重于容错、修复以及易于管理。它由 Oracle, Red Hat, Fujitsu, Intel, SUSE,  STRATO 等企业和开发者共同开发，Btrfs 以 GNU GPL 协议授权，同时也欢迎任何人的贡献。</p></blockquote><p>经过了解，发现几个比较感兴趣的特点：</p><ul><li>写时复制：任何写入操作都发生在空闲空间。与传统方式最显著的区别大概在于文件覆写时：传统方式直接在文件相应位置写入，而写时复制方式在空闲空间写入数据并通过修改原文件的元数据以使其相应位置的引用指向写入的位置，并在原地址引用数为0时释放其数据。</li><li>透明压缩：btrfs可以自动的尝试压缩文件，这样一方面减少了文件大小，另一方面显著延长了闪存介质的寿命。</li><li>SSD TRIM：btrfs可以从支持TRIM 命令的 SSD 驱动器中释放未使用的块。已释放的空间范围不会被马上丢弃，它们会被集中起来并在稍后由一个单独的工作线程进行 TRIM，这将能改善提交延迟，以提高SSD的性能。</li></ul><p>为了实现上述功能在挂载时需要添加两个参数：</p><p><code>compress=zstd</code>：使用zstd算法启用自动压缩。</p><p><code>discard=async</code>：使用SSD TRIM。</p><h2 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h2><p>首先简单实现一个通过UUID挂载分区的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /usr/<span class="built_in">local</span>/bin/mount_repo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载点</span></span><br><span class="line">readonly target_dir=&quot;/mnt/Repo&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过UUID获取分区名</span></span><br><span class="line">label=`lsblk -f | grep 5398cf0b-266e-4874-a8e7-1ac903013b48 | grep -o -E sd..`</span><br><span class="line"><span class="meta">#</span><span class="bash"> 分区名存在则挂载，否则尝试卸载挂载点</span></span><br><span class="line">if [ $&#123;label&#125; ]</span><br><span class="line">then</span><br><span class="line">    label=&quot;/dev/&quot;$&#123;label&#125;</span><br><span class="line">    echo $&#123;label&#125;</span><br><span class="line">    mkdir $&#123;target_dir&#125;</span><br><span class="line">    mount -o compress=zstd,discard=async $&#123;label&#125; $&#123;target_dir&#125;</span><br><span class="line">else</span><br><span class="line">    echo &quot;no device&quot;</span><br><span class="line">    umount $&#123;target_dir&#125;</span><br><span class="line">    rmdir $&#123;target_dir&#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>现在我们有了通过指定UUID挂载分区的脚本了。问题是如何才能让硬盘插入时自动挂载呢？几经查询，发现了udev。</p><h3 id="使用udev"><a href="#使用udev" class="headerlink" title="使用udev"></a>使用udev</h3><p>ArchWiki对udev的介绍如下：</p><blockquote><p>udev 是 Linux 内核的设备管理器。总的来说，它取代了 devfs 和 hotplug，负责管理 <code>/dev</code> 中的设备节点。同时，udev 也处理所有用户空间发生的硬件添加、删除事件，以及某些特定设备所需的固件加载。</p><p>与传统的顺序加载相比，udev 通过并行加载内核模块提供了潜在的性能优势。异步加载模块的方式也有一个天生的缺点：无法保证每次加载模块的顺序，如果机器具有多个块设备，那么它们的设备节点可能随机变化。例如如果有两个硬盘，<code>/dev/sda</code> 可能会随机变成<code>/dev/sdb</code>。</p></blockquote><p>当一个设备被添加或是移除时，udev会从kernel得知这个事件。然后遍历规则文件目录（默认在/etc/udev/rules.d）中的规则文件寻找匹配的规则，有就按规则处理，没有就作默认处理。</p><p>也就是说，我们可以通过编写规则文件的方式让udev在加载硬盘时进行挂载处理。</p><h4 id="udev规则简介"><a href="#udev规则简介" class="headerlink" title="udev规则简介"></a>udev规则简介</h4><p>udev规则文件中的一行就是一条规则，一条规则包括了匹配部分和动作部分，各部分通过逗号<code>,</code>分隔。具有如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond1,cond2,cond3,...,action1, action2, action3</span><br></pre></td></tr></table></figure><p>可以使用换行符<code>\</code>将一条规则分成几行编写。比如，对于以下规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KERNEL==&quot;video[0-9]*&quot; \</span><br><span class="line">  , SUBSYSTEM==&quot;video4linux&quot; \</span><br><span class="line">  , SUBSYSTEMS==&quot;usb&quot; \</span><br><span class="line">  , ATTRS&#123;idVendor&#125;==&quot;05a9&quot; \</span><br><span class="line">  , ATTRS&#123;idProduct&#125;==&quot;4519&quot; \</span><br><span class="line">  , SYMLINK+=&quot;video-cam1&quot;</span><br></pre></td></tr></table></figure><ul><li><code>KERNEL</code>是设备的卷标，这条规则使用了一个正则表达式对其进行匹配。</li><li><code>SUBSYSTEM</code>表示设备的类型</li><li><code>ATTRS&#123;sth.&#125;</code>获取设备的某个属性，属性名写在大括号中。</li><li><code>SYMLINK</code>是对该设备的软链接，使用+=对设备创建一个软链接。使用+=而不是=是因为不想覆盖掉默认操作。</li></ul><h4 id="编写自动挂载规则"><a href="#编写自动挂载规则" class="headerlink" title="编写自动挂载规则"></a>编写自动挂载规则</h4><p>根据这个例子，摸着石头过河，编写一个使用脚本自动挂载硬盘的规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">KERNEL==&quot;sd[a-z][0-9]&quot; \</span><br><span class="line">  , ACTION==&quot;remove&quot; \</span><br><span class="line">  , ATTRS&#123;idVendor&#125;==&quot;08e4&quot; \</span><br><span class="line">  , ATTRS&#123;idProduct&#125;==&quot;01e8&quot; \</span><br><span class="line">  , RUN+=&quot;/usr/local/bin/mount_repo&quot; </span><br><span class="line"></span><br><span class="line">KERNEL==&quot;sd[a-z][0-9]&quot; \</span><br><span class="line">  , ACTION==&quot;add&quot; \</span><br><span class="line">  , ATTRS&#123;idVendor&#125;==&quot;08e4&quot; \</span><br><span class="line">  , ATTRS&#123;idProduct&#125;==&quot;01e8&quot; \</span><br><span class="line">  , RUN+=&quot;/usr/local/bin/mount_repo&quot;</span><br></pre></td></tr></table></figure><p>使用<code>udevadm control --reload</code>重新加载规则。</p><p>到这里，非常开心地，我们掉进坑里了。这条规则可以运行，但mount命令会出错，导致并不能如预期那样工作。</p><p>然后才看见ArchWiki上这条警告：</p><blockquote><p><strong>警告：</strong> 要挂载可移动设备，请<strong>不要</strong>通过在 udev 规则中调用 <code>mount</code> 命令的方法。对 FUSE 文件系统将会导致 <code>Transport endpoint not connected</code> 错误。应代之以 <a class="link"   href="https://wiki.archlinux.org/title/Udisks_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" >udisks<i class="fas fa-external-link-alt"></i></a> 以正确处理自动挂载。或者把挂载动作放在 udev 规则内部：</p><p>将 <code>/usr/lib/systemd/system/systemd-udevd.service</code> 复制到 <code>/etc/systemd/system/systemd-udevd.service</code>，将 <code>MountFlags=slave</code> 替换为 <code>MountFlags=shared</code>。<a class="link"   href="https://unix.stackexchange.com/a/154318" >（来源）<i class="fas fa-external-link-alt"></i></a> </p><p>Keep in mind though that udev is not intended to invoke long-running processes.</p></blockquote><p>试图更改systemd-udevd.service，发现没效果。几经辗转，发现使用systemd可以解决这个问题。不再需要折腾systemd-udevd.service了。</p><p>首先创建一个service，repo.service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Mount Repository Device on /mnt/Repo</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">RemainAfterExit=true</span><br><span class="line">ExecStart=/usr/local/bin/mount_repo</span><br><span class="line">ExecStop=/usr/local/bin/mount_repo</span><br></pre></td></tr></table></figure><p>使用<code>systemctl daemon-reload</code>重新加载服务。</p><p>然后将规则文件改写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">KERNEL==&quot;sd[a-z][0-9]&quot; \</span><br><span class="line">  , ACTION==&quot;remove&quot; \</span><br><span class="line">  , ATTRS&#123;idVendor&#125;==&quot;08e4&quot; \</span><br><span class="line">  , ATTRS&#123;idProduct&#125;==&quot;01e8&quot; \</span><br><span class="line">  , RUN+=&quot;/bin/systemctl stop repo.service&quot; </span><br><span class="line"></span><br><span class="line">KERNEL==&quot;sd[a-z][0-9]&quot; \</span><br><span class="line">  , ACTION==&quot;add&quot; \</span><br><span class="line">  , ATTRS&#123;idVendor&#125;==&quot;08e4&quot; \</span><br><span class="line">  , ATTRS&#123;idProduct&#125;==&quot;01e8&quot; \</span><br><span class="line">  , RUN+=&quot;/bin/systemctl start repo.service&quot;</span><br></pre></td></tr></table></figure><p>使用<code>udevadm control --reload</code>重新加载规则。</p><p>到这里，自动挂载就可以正常工作了。</p><h2 id="在硬盘上创建仓库"><a href="#在硬盘上创建仓库" class="headerlink" title="在硬盘上创建仓库"></a>在硬盘上创建仓库</h2><p>在使用<code>git --bare init</code>创建一个远程仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /mnt/Repo</span><br><span class="line">mkdir test.git</span><br><span class="line">cd test.git</span><br><span class="line">git --bare init</span><br></pre></td></tr></table></figure><p>为本地git仓库添加这个远程仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/someprojects</span><br><span class="line">git remote add Repo /mnt/Repo/test.git</span><br><span class="line">git push remote master</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这次的折腾算是记录一下与udev的初次接触。使用linux的过程中总能用到以为永远不会碰的工具，这也是linux的魅力所在吧。</p>]]></content>
      
      
      <categories>
          
          <category> 0x02 技术杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的Haskell（一）——Haskell基础</title>
      <link href="/zh/blog/2021/06/10/0013-Re0:Haskell_01/"/>
      <url>/zh/blog/2021/06/10/0013-Re0:Haskell_01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对Haskell一直挺感兴趣，也学习了一段时间。奈何IO太离谱，做不出实际的东西，导致学了忘忘了学痛苦万分。于是只好信奉好记性不如烂笔头，写几篇笔记记录下来。</p><p>这是第一篇，主题是Haskell的介绍和基础语法。</p></blockquote><span id="more"></span><h2 id="给其它语言学习者的忠告"><a href="#给其它语言学习者的忠告" class="headerlink" title="给其它语言学习者的忠告"></a>给其它语言学习者的忠告</h2><p>如果你之前学习了一大票主流语言，比如C、C++、JAVA、Python、Shell、JS、PHP、汇编等等。我的建议是：<strong>忘记它们</strong>。</p><p>之前为C++选手写过一篇入门Python的文章，本来也想写一篇基于C++基础入门Haskell的文章。但一上手发现，使用C++的思维还不如完全失忆更好接受Haskell。</p><p>这就牵扯到了编程范式的问题。上述一大票语言，不管多么千差万别，大体上的运行方式就是：从某一条语句开始，按顺序一条一条的往下执行。这就是所谓的命令式编程：告诉计算机它要做什么。</p><p>而Haskell和这些语言不一样，它没有一个固定的语句执行顺序，甚至于，你无法改变一个变量的值（我更倾向于将Haskell中的变量理解成没有参数的函数，也就是说，根本没有变量，<strong>一切都是函数</strong>）。你的程序里满是无所谓先后的函数定义，你要做的事情是使用一个函数描述出你要解决的问题。也就是函数式编程：告诉计算机问题是什么。</p><p>因为这一个How和What的区别，在座的各位步骤流程大师的很多经验失去了用武之地。既然这样，不如索性给它忘了，从零开始推开新世界的大门。</p><h2 id="什么是Haskell"><a href="#什么是Haskell" class="headerlink" title="什么是Haskell"></a>什么是Haskell</h2><p>Haskell是一门惰性求值、纯函数式的静态强类型编程语言。</p><h3 id="函数式："><a href="#函数式：" class="headerlink" title="函数式："></a>函数式：</h3><p>对于函数式并没有明确的定义，但它通常意味着：</p><ul><li>函数是“一等公民”，就是说，函数可以在任何需要一个值的地方作为值来使用。具体点说就是你可以把函数直接作为另一个函数的参数进行传递，而不用使用类似于函数指针或std::function之类的东西把它包起来。</li><li>程序围绕着“计算表达式”而不是“执行指令”来运行。</li></ul><p>学习Haskell花费时间最多的地方就在于这种从命令式到函数式的思维转换。</p><h3 id="纯："><a href="#纯：" class="headerlink" title="纯："></a>纯：</h3><p><em>“让函数式的归函数式，纯的归纯。”——《藏狐箴言》。</em></p><p>并不是所有函数式语言都是纯函数式，一个纯的语言意味着：</p><ul><li>没有改变，任何值都是不可变的。</li><li>表达式永远没有副作用，比如改变了某个变量的值或在屏幕上显示消息或发射一枚核弹。</li><li>使用相同的输入调用一个函数总能得到相同的输出。</li></ul><p>相信大家看到这已经懵了，这不是啥也干不了了吗？这语言什么用？rnm，退钱！</p><p>其实大可不必，面包还是会有的，只要亿点点思维转变，比如：</p><ul><li>等价代换：你永远可以使用一个等价的东西替换另一个东西，就像你还是一个炼金术士的时候那样。</li><li>并行：在没有副作用的世界，并行计算表达式会很轻松。</li><li>更少的头痛（？）：简单堆积，随意改动，各种行为作用会使程序非常难Debug和原因定位。</li></ul><h3 id="惰性求值："><a href="#惰性求值：" class="headerlink" title="惰性求值："></a>惰性求值：</h3><p>在Haskell中，一个表达式的值只有在真正被需要的时候才被计算出来（就像你只有在马上考试的时候才开始学习一样）。这种特性将会随着学习的深入加深理解。这里举几个浅显的小例子：</p><ul><li>可以简单的使用函数定义一个控制结构。</li><li>让使用无限数据的结构成为可能。</li><li>开启了一种更有创造性的编程风格（wholemeal programming直译为全麦编程，一种全局思考的编程风格）。</li><li>但它也带来了一个负面影响：非常难以计算时空复杂度。</li></ul><h3 id="静态强类型："><a href="#静态强类型：" class="headerlink" title="静态强类型："></a>静态强类型：</h3><p>Haskell中所有表达式都有一个类型，并且会在编译期提供类型检查。并且，Haskell中不允许隐式类型转换。</p><blockquote><p>静态/动态类型是指在程序执行过程中变量的类型是否允许改变。</p><p>弱/强类型是指程序是否允许隐式类型转换。</p></blockquote><h2 id="三个主题"><a href="#三个主题" class="headerlink" title="三个主题"></a>三个主题</h2><p>在这个系列的学习中，会重点学习三个主题：</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>Haskell的严格的类型系统带来了以下好处：</p><ul><li><p>（被迫）更清晰的思考和表达程序结构。</p><p>一个函数的定义往往从思考并写下它的类型开始。</p></li><li><p>程序具有类似文档的形式。</p><p>每个函数的类型定义可以让使用者清楚地明白这个函数接受什么输出什么。</p></li><li><p>将运行期错误提前到编译期</p><p>更早发现错误的好处不言而谕。</p></li></ul><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>编程世界中有一句经常出现的话：“不要重复”，也叫抽象原则。意思是代码中的任何东西都不该在多处出现，所有的算法、数据段等内容都只该在一个确定的地方出现一次。比如相同的代码可以用函数封装起来供其它代码使用。</p><p>Haskell非常擅长抽象：像多态参数，高级函数和类型类这样的特性都是为了与重复斗争而加入的。</p><h3 id="全麦编程"><a href="#全麦编程" class="headerlink" title="全麦编程"></a>全麦编程</h3><p>这词太离谱，总之就是在更整体的层面去思考问题。比如思考对一整个列表的操作，而不是列表里的一个个元素。开发一个解集而不是某个特定的解。想像一整个图，而不是某条路径。</p><p>在工程中体现为，先解决一个更普遍的问题，然后思考如何将普遍问题变换为一个特殊的问题。</p><p>举个例子，在C++或Java中，以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int acc = 0;</span><br><span class="line">for (int i = 0; i &lt; lst.length; ++i) &#123;</span><br><span class="line">acc = acc + 3 * lst[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的目的其实就是：将lst中的所有元素乘以3，再计算它们的总和。</p><p>在Haskell中，可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum (map (3*) lst)</span><br></pre></td></tr></table></figure><p>Haskell需要我们将思维转变成一种更加高屋建瓴的方式，而这种思维方式可以帮助我们写出更便于理解的代码。比如，在C++中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义出两个基础函数，如果大量使用的话，这样看似繁琐的写法是值得的。因为它提供了更强大的抽象。</span></span><br><span class="line"><span class="comment">// 简单起见，暂不实现泛型的map和sum。</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">map</span><span class="params">(std::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>&amp;)&gt; func, std::vector&lt;<span class="keyword">int</span>&gt; &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : n) &#123;</span><br><span class="line">        <span class="built_in">func</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : n) &#123;</span><br><span class="line">        total += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 使用上面的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> acc = <span class="built_in">sum</span>(<span class="built_in">map</span>([](<span class="keyword">int</span> &amp;a)&#123;a += <span class="number">3</span>;&#125;, lst));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文档化的Haskell"><a href="#文档化的Haskell" class="headerlink" title="文档化的Haskell"></a>文档化的Haskell</h2><p>Haskell中支持一种以文档为主的文件格式<code>.lhs</code>，在这种格式下，以<code>&gt; </code>和一个空格开头的才被看做代码。这种文件格式可以更方便的写出大篇幅算法的解释等，毕竟没有人希望一个文件的主体全是注释。</p><h2 id="声明与变量"><a href="#声明与变量" class="headerlink" title="声明与变量"></a>声明与变量</h2><p>观察以下代码：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">x</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">x</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单行注释以两个横线开头</span></span><br><span class="line"><span class="comment">&#123;- 多行注释以两个</span></span><br><span class="line"><span class="comment">括号-横线对包覆 -&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码声明了一个Int类型的变量x（::后面用于定义类型说明），并且将其值声明为3。此后x的值不能被改变。也不能对x进行重定义。</p><p>不难看出=号在Haskell中的含义与在其它语言中的不同。它并不是赋值运算符（Haskell中无值可赋），而是用于定义。<code>x = 4</code>不应理解成将x的值置为4，应该理解为x被定义为4。</p><p>考虑下面定义：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">y</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">y</span> = y + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>多少人初学编程，无法理解这种等于自身+1的定义。后来终于将自己的思维扭转，只可惜历史是个圈。这个定义不再是y的值加1了，而是将y定义为y + 1。这是一个无限值，但由于Haskell的惰性求值特性，不使用它时并不会导致异常情况。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>Haskell提供了一些耳熟能详的类型<code>Int</code>、<code>Char</code>、<code>Bool</code>、<code>Float</code>、<code>Double</code>与<code>String</code>，注意类型首字母要大写，以及几个注意事项。</p><ul><li><code>Int</code>大概相当于C++的int类型，长度取决于运行代码的机器。</li><li><code>Char</code>是Unicode编码字符。</li><li><code>Bool</code>的值为<code>True</code>和<code>False</code>，首字母依然要大写。</li><li><code>String</code>实际上是List的语法糖。</li></ul><p>Haskell也提供了无限大小的整形<code>Integer</code>，需要注意<code>Integer</code>与<code>Int</code>是不同的类型，不可混用。</p><p>注意Haskell中标识符使用小驼峰命名法。</p><h2 id="GHCi"><a href="#GHCi" class="headerlink" title="GHCi"></a>GHCi</h2><p>GHCi是Haskell的解释器，提供一个Haskell语言的解释运行环境，基本用法如下：</p><ul><li><code>:l</code>加载Haskell文件</li><li><code>:r</code>重新加载已加载文件</li><li><code>:q</code>退出GHCi</li><li><code>:?</code>打印帮助信息</li></ul><p>在GHCi中，可以很方便的测试简单代码。</p><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p>可以在GHCi中进行一些简单运算的尝试：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 四则</span></span><br><span class="line"><span class="title">ex01</span> = <span class="number">3</span> + <span class="number">2</span></span><br><span class="line"><span class="title">ex02</span> = <span class="number">19</span> - <span class="number">27</span></span><br><span class="line"><span class="title">ex03</span> = <span class="number">2.35</span> * <span class="number">8.6</span></span><br><span class="line"><span class="title">ex04</span> = <span class="number">8.7</span> / <span class="number">3.1</span></span><br><span class="line"><span class="comment">-- 取模、乘方</span></span><br><span class="line"><span class="title">ex05</span> = mod <span class="number">19</span> <span class="number">3</span></span><br><span class="line"><span class="title">ex06</span> = <span class="number">19</span> `mod` <span class="number">3</span></span><br><span class="line"><span class="title">ex07</span> = <span class="number">7</span> ^ <span class="number">222</span></span><br><span class="line"><span class="comment">-- 负数</span></span><br><span class="line"><span class="title">ex08</span> = (<span class="number">-3</span>) * (<span class="number">-7</span>)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>Haskell在缺省类型说明时可以自动地推导类型。</li><li>所有运算符号本质都是函数。这些函数有的是中缀函数而有的是前缀函数，这是在定义时决定的。<ul><li>默认情况下Haskell中的函数都是前缀函数。</li><li>前缀函数可以通过反引号当做中缀函数使用（ex06中的mod）。</li><li>函数调用不需要使用括号（函数调用符）。</li></ul></li><li>出现负数时要使用括号括起来，因为Haskell中没有函数调用符，负号与减号存在二义性（Haskell中为数不多的丑陋语法之一）。</li></ul><p>Haskell中不存在隐式类型转换，需要时必须使用显式类型转换，比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将整型(Int, Integer)转换为任意其它类型时</span></span><br><span class="line"><span class="title">fromIntegral</span> n</span><br><span class="line"><span class="comment">-- 将浮点型转换为整型时，根据截断方式使用</span></span><br><span class="line"><span class="title">round</span> d</span><br><span class="line"><span class="title">floor</span> d</span><br><span class="line"><span class="title">ceiling</span> d</span><br></pre></td></tr></table></figure><p><code>/</code>运算符无法作用于整型，只能作用于符点类型。整除函数为<code>div</code>，是一个前缀函数。</p><h2 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h2><p>与或非运算分别为：<code>&amp;&amp;</code>、<code>||</code>、<code>not</code>。注意非运算不再是！号了。</p><p>比较运算有：<code>==</code>、<code>/=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>。同样注意不等于不再是!=而是<code>/=</code>。</p><p>Haskell中也有<code>if condition then sth else sth</code>的表达式。但if表达式不是if语句，最大的区别在于if表达式不可省略else后的部分。</p><p>对于一个c++函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="comment">// modify x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其意义为满足一定条件时，返回对x进行一些操作后的值，否则输出x本身。</p><p>而对于Haskell函数，需要这样写：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> n = <span class="keyword">if</span> condition <span class="keyword">then</span> modify n <span class="keyword">else</span> n</span><br></pre></td></tr></table></figure><p>这样上述写法才在语义上等效，其中的关键思路是：Haskell中的表达式总是需要一个结果，省略掉else将导致程序无法产生结果。</p><p>这也是Haskell与命令式语言不同之处的体现：并非逐步执行，而是计算表达式。</p><p>不过Haskell中并不常用到if表达式，更多时候使用的是模式匹配和一种被称为<em>守卫（guards）</em>的机制。</p><h2 id="定义基础函数"><a href="#定义基础函数" class="headerlink" title="定义基础函数"></a>定义基础函数</h2><p>一个函数可以这样定义</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">suntorial</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">sumtorial</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="title">sumtorial</span> n = n + sumtorial (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>其中的语法：</p><ul><li><code>sumtorial :: Integer -&gt; Integer</code>说明了函数的类型，接收一个<code>Integer</code>作为参数，返回一个<code>Integer</code></li><li>其后可以跟随多个从句，运行时使用参数从最上方定义的从句开始逐条匹配，并返回第一条匹配成功的从句定义的计算结果。这个过程就是模式匹配，比如说：<ul><li>计算<code>sumtorial 0</code>，首先使用参数0与第一个从句的参数：0比较，匹配成功，返回第一个从句的值：0。</li><li>计算<code>sumtorial 3</code>，首先使用参数3与第一个从句的参数：0比较，匹配失败，再与第二个从句的参数n比较，n是一个变量，可以接受任何值，匹配成功，返回第二个从句的值：<code>3 + sumtorial (3 - 1)</code>。<ul><li>由于Haskell是惰性求值的，只有用到这个结果时才会将表达式展开作下一步运算，这里暂且不管。</li></ul></li></ul></li></ul><p>也可以使用布尔表达式来筛选参数，也就是守卫机制：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">hailstone</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">hailstone</span> n</span><br><span class="line">  | n `mod` <span class="number">2</span> == <span class="number">0</span> = n `div` <span class="number">2</span></span><br><span class="line">  | otherwise      = <span class="number">3</span> * n + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>守卫通过从句中的缩进（Haskell使用相同的缩进层级来划分代码块）和<code>|</code>来定义，从上而下进行判定，返回第一个满足条件的结果。<code>otherwise</code>表示无条件接收。</p><p>如果没有从句可以匹配变量，程序将报错退出。</p><p>一个细节，守卫是从句的下级机制，也就是说每个从句都可以拥有守卫：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">foo</span> <span class="number">0</span> = <span class="number">16</span></span><br><span class="line"><span class="title">foo</span> <span class="number">1</span></span><br><span class="line">  | <span class="string">&quot;Haskell&quot;</span> &gt; <span class="string">&quot;C++&quot;</span> = <span class="number">3</span></span><br><span class="line">  | otherwise = <span class="number">4</span></span><br><span class="line"><span class="title">foo</span> n</span><br><span class="line">  | n &lt; <span class="number">0</span> = <span class="number">0</span></span><br><span class="line">  | n `mod` <span class="number">17</span> == <span class="number">2</span> = <span class="number">-43</span></span><br><span class="line">  | otherwise       = n + <span class="number">3</span></span><br><span class="line"><span class="comment">-- = 号并不需要对齐，这里只是出于美观对齐的</span></span><br></pre></td></tr></table></figure><p>这个例子也没啥意义，就是给看看怎么混合使用。</p><p>下面的程序是完全正确的，但有些啰嗦，考虑下问题在哪：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">isEven</span> :: <span class="type">Integer</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isEven</span> n</span><br><span class="line">  n `mod` <span class="number">2</span> == <span class="number">0</span> = <span class="type">True</span></span><br><span class="line">  otherwise      = <span class="type">False</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 其实真正有效的部分只有n `mod` 2 == 0，所以可以写成以下形式</span></span><br><span class="line"><span class="comment">-- 函数命名使用单引号是合法的</span></span><br><span class="line"><span class="title">isEven&#x27;</span> :: <span class="type">Integer</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isEven&#x27;</span> = n `mod` <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="序对"><a href="#序对" class="headerlink" title="序对"></a>序对</h2><p>可以使用序对（Pair）将两个东西组合起来，比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">p</span> :: (<span class="type">Int</span>, <span class="type">Char</span>)</span><br><span class="line"><span class="title">p</span> = (<span class="number">3</span>, &#x27;x&#x27;)</span><br></pre></td></tr></table></figure><p>注意：<code>(x, y)</code>这种语法既可以表示序对类型也可以表示序对的值。</p><p>可以使用模式匹配将序对中的值提取出来：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sumPair</span> :: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">sumPair</span> (x, y) = x + y</span><br></pre></td></tr></table></figure><p>Haskell中含有三元组和多元组，但很少使用，因为有更好的方法，这个方法容我日后再说。</p><h2 id="接受多个参数的函数"><a href="#接受多个参数的函数" class="headerlink" title="接受多个参数的函数"></a>接受多个参数的函数</h2><p>要让函数接受多个参数，只要在类型声明时使用更多的-&gt;就可以了：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">f</span> x y z = x + y + z</span><br><span class="line"></span><br><span class="line"><span class="title">useF</span> = f <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>在多个-&gt;组成的串中，前几项依序表示参数，最后一项表示返回类型。你可能会疑惑为什么使用这样一个似乎很容易混淆的形式，而不是类似于<code>f :: Int Int Int -&gt; Int</code>这样的形式。这背后是一个很优雅的语言特性，但这个特性也得留待后议。</p><p>注意前缀函数的运算优先级比中缀函数要高，所以以下写法是错误的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> <span class="number">3</span> n + <span class="number">1</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p>因为它实际上会被解析成：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(f <span class="number">3</span> n) + (<span class="number">1</span> <span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>正确的写法是加上括号：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> <span class="number">3</span> (n + <span class="number">1</span>) <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表（List）是Haskell中最基本的类型之一，使用<code>[]</code>表示，其中元素以<code>,</code>分隔：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">nums</span> :: [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">nums</span>   = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>之前提到过<code>String</code>是List的语法糖, 实际上<code>String</code>类型就是<code>[Char]</code>类型，比如:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">hello1</span> :: [<span class="type">Char</span>]</span><br><span class="line"><span class="title">hello1</span> = [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class="line"></span><br><span class="line"><span class="title">hello2</span> :: <span class="type">String</span></span><br><span class="line"><span class="title">hello2</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- helloSame 为 True</span></span><br><span class="line"><span class="title">helloSame</span> = hello1 == hello2</span><br></pre></td></tr></table></figure><h3 id="构建列表"><a href="#构建列表" class="headerlink" title="构建列表"></a>构建列表</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 最简单的列表就是空列表了</span></span><br><span class="line"><span class="title">emptyList</span> = []</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用构建运算符(:)将元素连接成列表, :运算符左边是一个元素，而右边是一个列表。</span></span><br><span class="line"><span class="title">ex18</span> = <span class="number">1</span> : []</span><br><span class="line"><span class="comment">-- :运算符符合右结合律，以便连接多个元素时可以省略括号。</span></span><br><span class="line"><span class="title">ex19</span> = <span class="number">3</span> : (<span class="number">1</span> : [])</span><br><span class="line"><span class="title">ex20</span> = <span class="number">2</span> : <span class="number">3</span> : <span class="number">4</span> : []</span><br><span class="line"></span><br><span class="line"><span class="comment">--[e1, e2, e3]实际上是e1 : e2 : e3 : []的语法糖</span></span><br><span class="line"><span class="title">ex21</span> = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] == <span class="number">2</span> : <span class="number">3</span> : <span class="number">4</span> : []</span><br><span class="line"></span><br><span class="line"><span class="comment">--[e1, e2..en]的写法可以根据前两个元素自动展开列表（等差数列），省略第二个元素的情况下差值为1</span></span><br><span class="line"><span class="comment">-- 1, 2, 3 ... 100</span></span><br><span class="line"><span class="title">range1</span> = [<span class="number">1</span> .. <span class="number">100</span>]</span><br><span class="line"><span class="comment">-- 2, 4, 6 ... 100</span></span><br><span class="line"><span class="title">range2</span> = [<span class="number">2</span>,<span class="number">4</span> .. <span class="number">100</span>]</span><br><span class="line"><span class="comment">-- a, b, c, d ... z</span></span><br><span class="line"><span class="title">range3</span> = [&#x27;a&#x27; .. &#x27;z&#x27;]</span><br><span class="line"><span class="comment">-- 10, 9 ... 1</span></span><br><span class="line"><span class="title">range4</span> = [<span class="number">10</span>, <span class="number">9</span> .. <span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 无限列表1,2,3...</span></span><br><span class="line"><span class="title">range5</span> = [<span class="number">1</span>, <span class="number">2</span> ..]</span><br><span class="line"><span class="comment">-- 使用浮点类型时要小心精度问题带来的异常情况</span></span><br><span class="line"><span class="comment">-- 实际生成[0.1， 0.3， 0.5， 0.7， 0.89999999， 1.09999999]</span></span><br><span class="line"><span class="title">range6</span> = [<span class="number">0.1</span>, <span class="number">0.3</span> .. <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表生成式[expr | elem1&lt;-[range1], elem2&lt;-[range2]..., condition1, condition2...]</span></span><br><span class="line"><span class="comment">-- 看似复杂，其实记住：表达式，表达式中的变量怎么来的，变量的约束条件（条件需全部满足，即与关系）。</span></span><br><span class="line"><span class="comment">-- 很类似数学中集合的表示</span></span><br><span class="line"><span class="title">list</span> = [x * y | x&lt;-[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], y&lt;-[<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], x &gt; y, y &gt; <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用函数生成列表, hailstone作为守卫机制的例子定义过了，可以翻回去看</span></span><br><span class="line"><span class="title">hailstoneSeq</span> :: <span class="type">Integer</span> -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">hailstoneSeq</span> <span class="number">1</span> = [<span class="number">1</span>]</span><br><span class="line"><span class="title">hailstoneSeq</span> n = n : hailstoneSeq (hailstone n)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="操作列表"><a href="#操作列表" class="headerlink" title="操作列表"></a>操作列表</h3><p>列表的基本操作如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用++运算符拼接两个列表</span></span><br><span class="line"><span class="comment">-- [1，2，3，4，5，6]</span></span><br><span class="line"><span class="title">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ++ [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用!!运算符取出列表中某个元素，类似数组下标，从0开始计数</span></span><br><span class="line"><span class="comment">-- n = 2</span></span><br><span class="line"><span class="title">n</span> = list!!<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="处理列表的函数"><a href="#处理列表的函数" class="headerlink" title="处理列表的函数"></a>处理列表的函数</h2><p>可以使用模式匹配来处理列表：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">intListLength</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">intListLength</span> []  = <span class="number">0</span></span><br><span class="line"><span class="title">intListLength</span> (x:xs) = <span class="number">1</span> + intListLength xs</span><br><span class="line"><span class="comment">-- 对于仅仅用来表示模式而不实际使用的变量，如上例中x，可以使用下划线_占位</span></span><br><span class="line"><span class="title">intListLength</span> (_:xs) = <span class="number">1</span> + intListLength xs</span><br><span class="line"></span><br><span class="line"><span class="title">sumEveryTwo</span> :: [<span class="type">Integer</span>] -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">sumEveryTwo</span> [] = []</span><br><span class="line"><span class="title">sumEveryTwo</span> (x : []) = [x]</span><br><span class="line"><span class="title">sumEveryTwo</span> (x : y : zs) = (x + y) : sunEveryTow zs</span><br></pre></td></tr></table></figure><h2 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h2><p>在Haskell中要尽可能地使用简单的函数组合成复杂的功能，比如要求hailstone数的数量，可以这样编写：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">hailstoneLen</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">hailstoneLen</span> n = intListLength (hailstoneSeq n) - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在这个函数中通过之前的例子定义的函数组合起来达成目的，其实这些函数本身也是由简单的函数组合成的，这样层层抽象将使得我们的心智负担更小。</p><h2 id="关于错误信息"><a href="#关于错误信息" class="headerlink" title="关于错误信息"></a>关于错误信息</h2><p>不要害怕错误信息，它可以很好地帮助我们找出并改正代码中的错误。比如,在GHCi中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; &#x27;x&#x27; ++ &quot;foo&quot;</span><br></pre></td></tr></table></figure><p>将导致以下报错:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;interactive&gt;:1:1:</span><br><span class="line">  Coundn&#x27;t match expected type &#x27;[a0]&#x27; with actual type &#x27;Char&#x27;</span><br><span class="line">  In the first argument of &#x27;(++)&#x27;, namely &#x27;x&#x27;</span><br><span class="line">  In the expression: &#x27;x&#x27; ++ &quot;foo&quot;</span><br><span class="line">  In an equation for &#x27;it&#x27; : it = &#x27;x&#x27; ++ &quot;foo&quot;</span><br></pre></td></tr></table></figure><p>乍一看头都大了，怎么这么长一串报错。实际上耐心看下去就会发现，错误信息包括了出错原因与地点，还层层递进的显示了出错的语法，是非常友好的。</p>]]></content>
      
      
      <categories>
          
          <category> 0x03 从零开始的Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HMAC-SHA256算法解析与实现</title>
      <link href="/zh/blog/2021/05/29/0012-HMAC-SHA256_Algorithm/"/>
      <url>/zh/blog/2021/05/29/0012-HMAC-SHA256_Algorithm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对HMAC-SHA256算法作的整理。</p></blockquote><span id="more"></span><h2 id="HMAC算法"><a href="#HMAC算法" class="headerlink" title="HMAC算法"></a>HMAC算法</h2><p>HMAC是Hash-based Message Authentication Code的缩写，意为基于哈希运算的消息认证码。基诞生目的是为了确保网络中报文的完整性以及信息来源的身份验证。其中有几个关键组成部分：</p><ul><li>哈希函数(Hash)：用以将任意长度的消息映射成为定长的哈希值。</li><li>密钥(key)：与原始消息组合后通过哈希函数，以起到身份验证功能。</li><li>原始消息(message)：将被处理的消息。</li><li>ipad：值为00110110(0x36)的循环，长度为Hash函数的分组长度。</li><li>opad：值为01011100(0x5c)的循环，长度为Hash函数的分组长度。</li></ul><p>HMAC算法描述为：</p><ol><li>对key值进行填充，形成padded-key，填充方法如下：<ol><li>若key的长度小于Hash函数的分组长度，在其后用0填充至Hash函数分组长度。</li><li>若key的长度大于Hash函数的分组长度，使用Hash(key)生成padded-key。</li></ol></li><li>将生成的padded-key分别与ipad/opad进行XOR运算，得到ipad-key和opan-key。</li><li>将ipad-key与message首尾相接（ipad-key在message前），进行Hash(ipad-key+message)运算，得到hash1。</li><li>将得到的opad-key与hash1首尾相接，进行Hash(opad-key+hash1)运算，就得到了HMAC值。</li></ol><p>伪码描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">input: key, message, Hash</span><br><span class="line">output:hmac</span><br><span class="line"></span><br><span class="line">chunk_size = Hash.chunk_size</span><br><span class="line">ipad(chunk_size, 0x36)</span><br><span class="line">opad(chunk_size, 0x5c)</span><br><span class="line"></span><br><span class="line">padded_key = if (key.size &lt;= chunk_size) </span><br><span class="line"> then key + pading(chunk_size - key.size, 0) </span><br><span class="line"> else Hash(key)</span><br><span class="line"> </span><br><span class="line">ipad_key = XOR(padded_key, ipad)</span><br><span class="line">opad_key = XOR(padded_key, opad)</span><br><span class="line"></span><br><span class="line">hash1 = Hash(ipad_key + message)</span><br><span class="line">hmac = Hash(opad_key + hash1)</span><br></pre></td></tr></table></figure><h2 id="SHA256-算法"><a href="#SHA256-算法" class="headerlink" title="SHA256 算法"></a>SHA256 算法</h2><p>SHA是Secure Hash Algorithm的缩写，是一个由美国国家安全局研发的算法族。这些算法大体结构相似，但在性能，数值范围与安全性上存在差别。SHA256算法是其中较为广为人知的一个算法，接受一个最大长度为(2^64 - 1)bit的消息，输出一个256bit长的哈希值。SHA256算法非常安全，目前还没有对SHA256算法的成功碰撞记录。</p><p>这个算法有几个关键组成部分：</p><ul><li><p>8个哈希初值：对自然界中前8个质数的平方根小数部分取前32个bit取得。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a</span><br><span class="line">,0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19</span><br></pre></td></tr></table></figure></li><li><p>64个常数：对自然界中前64个质数的立方根小数部分取前32个bit取得。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b</span><br><span class="line">,0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01</span><br><span class="line">,0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7</span><br><span class="line">,0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc</span><br><span class="line">,0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152</span><br><span class="line">,0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147</span><br><span class="line">,0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc</span><br><span class="line">,0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85</span><br><span class="line">,0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819</span><br><span class="line">,0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08</span><br><span class="line">,0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f</span><br><span class="line">,0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208</span><br><span class="line">,0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2</span><br></pre></td></tr></table></figure></li><li><p>原始消息(message)：将被处理的消息。</p></li><li><p>分段长度(chunk_size)：512bit</p></li><li><p>运算字数(word_count)：64</p></li><li><p>函数CROR(x, n) = x循环右移n位</p></li><li><p>函数S0(x) = CROR(x, 7) ^ CROR(x, 18) ^ (x &gt;&gt; 3)</p></li><li><p>函数S1(x) = CROR(x, 17) ^ CROR(x, 19) ^ (x &gt;&gt; 10)</p></li><li><p>函数EP0(x) = CROR(x, 2) ^ CROR(x, 13) ^ CROR(x, 22)</p></li><li><p>函数EP1(x) = CROR(x, 6) ^ CROR(x, 11) ^ CROR(x, 25)</p></li><li><p>函数CH(x, y, z) = (x &amp; y) ^ ((~x) &amp; z)</p></li><li><p>函数MAJ(x, y, z) = ((x &amp; y) ^ (x &amp; z) ^ (y &amp; z))</p></li></ul><p>算法描述如下：</p><ol><li><p>对message进行预处理：</p><ol><li><p>在message后填充1位1，然后填充若干位0，直到message的长度(bit)对512取模等于448（message.size % chunk_size = 448）。</p><ul><li>不管message本来长度是多少，都要先填充1位1。也就是说即使message的长度对512取模已经等于448了，还是要填充1位1，之后再填充511位0使其长度重新符合要求。</li><li>为什么是448？因为下一步要填充一个64bit的数，448+64等于分段长度512。</li></ul></li><li><p>使用一个64bit长的无符号整型数以大端字节序在message后填充原始message的长度。</p><ul><li><p>字节序，对于长度超过1字节的数据，在内存中的存储有两种顺序：</p><ol><li>低地址存储低位字节，高地址存储高位字节，称为大端字节序。</li><li>低地址存储高位字节，高地址存储低信字节，称为小端字节序。</li></ol><p>例如，对于0x1234，若使用内存地址0x01, 0x02存储这两个字节，表现为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 大端序</span><br><span class="line">0x01: 0x12</span><br><span class="line">0x02: 0x34</span><br><span class="line"></span><br><span class="line">// 小端序</span><br><span class="line">0x01: 0x34</span><br><span class="line">0x02: 0x12</span><br></pre></td></tr></table></figure><p>值得一提的是，对无论大端序还是小端序，对0x1234取地址都将得到0x01。</p></li></ul></li></ol></li><li><p>使用一个长度为8的数组H[]保存8个哈希初值。</p></li><li><p>使用一个长度为64的数组k[]保存64个常数。</p></li><li><p>将预处理后的message分割为若干长度为chunk_size的chunk。</p></li><li><p>依序对每个chunk进行下列处理：</p><ol><li><p>建立一个大小为word_count(64)的数组w[]</p></li><li><p>将chunk分割为16个长度为32bit的word，存储在w[0]-w[15]中。</p><ul><li>注意将每一个word转换为机器字节序，否则位运算会出问题。</li></ul></li><li><p>对i从16到63进行循环：</p><ul><li>w[i] = w[i - 16] + S0(w[i - 15]) + w[i - 7] + S1(w[i - 2])</li></ul></li><li><p>使用创建H[]的拷贝h[]</p></li><li><p>对i从0到63进行循环，根据w[]和k[]计算h[]中的hash值：</p><ul><li><p>t1 = h[7] + EP1(h[4]) + CH(h[4], h[5], h[6]) + k[i] + w[i]</p></li><li><p>t2 = EP0(h[0]) + MAJ(h[0], h[1], h[2])</p></li><li><p>对i从7到1循环：</p><ul><li>if (i == 4) then h[i] = h[i - 1] + t1 else h[i] = h[i - 1]</li></ul></li><li><p>h[0] = t1 + t2</p></li></ul></li><li><p>更改H[]供下一个chunk使用：</p><ul><li>H[] += h[]</li></ul></li></ol></li><li><p>将最终得到的H[]按大端字节序首尾相接，即形成最终的256bit哈希值。</p></li></ol><p>伪码描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">input: message</span><br><span class="line">output: hash</span><br><span class="line"></span><br><span class="line">H[8] = &#123;0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a</span><br><span class="line">       ,0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19&#125;</span><br><span class="line">       </span><br><span class="line">k[64] = &#123;0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b</span><br><span class="line">        ,0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01</span><br><span class="line">        ,0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7</span><br><span class="line">        ,0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc</span><br><span class="line">        ,0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152</span><br><span class="line">        ,0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147</span><br><span class="line">        ,0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc</span><br><span class="line">        ,0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85</span><br><span class="line">        ,0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819</span><br><span class="line">        ,0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08</span><br><span class="line">        ,0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f</span><br><span class="line">        ,0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208</span><br><span class="line">        ,0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2&#125;</span><br><span class="line">        </span><br><span class="line">// 实际上处理以字节为单位，而不是bit</span><br><span class="line">chunk_size = 64;</span><br><span class="line">word_count = 64;</span><br><span class="line"></span><br><span class="line">CROR(x, n) = x循环右移n位</span><br><span class="line">S0(x) = CROR(x, 7) ^ CROR(x, 18) ^ (x &gt;&gt; 3)</span><br><span class="line">S1(x) = CROR(x, 17) ^ CROR(x, 19) ^ (x &gt;&gt; 10)</span><br><span class="line">EP(x) = CROR(x, 2) ^ CROR(x, 13) ^ CROR(x, 22)</span><br><span class="line">EP1(x) = CROR(x, 6) ^ CROR(x, 11) ^ CROR(x, 25)</span><br><span class="line">CH(x, y, z) = (x &amp; y) ^ ((~x) &amp; z)</span><br><span class="line">MAJ(x, y, z) = ((x &amp; y) ^ (x &amp; z) ^ (y &amp; z))</span><br><span class="line"></span><br><span class="line">// 预处理部分</span><br><span class="line">unit_byte = 64</span><br><span class="line">target_size = 56</span><br><span class="line">// 第一个填充字节，值为10000000</span><br><span class="line">first_append = 0x80</span><br><span class="line"></span><br><span class="line">// 大小信息以bit为单位</span><br><span class="line">length = message.size * 8</span><br><span class="line"></span><br><span class="line">need_size = taget_byte - (messaage.size % chunk_size)</span><br><span class="line">need_size += if (need_size &lt;= 0) then chunk_size else 0;</span><br><span class="line"></span><br><span class="line">// zero构造一个长度为need_size - 1字节的串，big_endian保证返回一个数的大端序格式</span><br><span class="line">message += first_append + zero(need_size - 1) + big_endian(length)</span><br><span class="line"></span><br><span class="line">// 分块并计算hash值</span><br><span class="line">chunk_count = message.size / chunk_size</span><br><span class="line">for i in (0, chunk_count):</span><br><span class="line">// divide将chunk分解为16个机器字节序的word</span><br><span class="line">w[word_count] = divide(chunk[i])</span><br><span class="line">// 生成剩下的word</span><br><span class="line">for i in (16, word_count):</span><br><span class="line">w[i] = w[i - 16] + S0(w[i - 15]) + w[i - 7] + S1(w[i - 2])</span><br><span class="line">h = H</span><br><span class="line">for i in (0, word_count):</span><br><span class="line">t1 = h[7] + EP1(h[4]) + CH(h[4], h[5], h[6]) + k[i] + w[i]</span><br><span class="line">t2 = EP0(h[0]) + MAJ(h[0], h[1], h[2])</span><br><span class="line">for i in (7, 0):</span><br><span class="line">h[i] = h[i - 1]</span><br><span class="line">if (i == 4):</span><br><span class="line">h[i] += t1</span><br><span class="line">h[0] = t1 + t2</span><br><span class="line">    for i in (0, 8):</span><br><span class="line">        H[i] += h[i]</span><br><span class="line"></span><br><span class="line">// 生成hash值，将H中每个值以大端格式组合</span><br><span class="line">hash = big_endian_combine(H)</span><br></pre></td></tr></table></figure><h2 id="HMAC-SHA256算法实现"><a href="#HMAC-SHA256算法实现" class="headerlink" title="HMAC_SHA256算法实现"></a>HMAC_SHA256算法实现</h2><p>HMAC_SHA256算法就是将SHA256算法作为Hash函数的HMAC算法。简单组合就可得到。</p><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><p>理解了上述内容后使用C++实现出来还是很简单的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment"> * 一个HMAC和SHA256算法的跨平台实现</span></span><br><span class="line"><span class="comment"> * ******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::array;</span><br><span class="line"><span class="keyword">using</span> std::function;</span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::<span class="keyword">size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment"> * 字节序相关运算</span></span><br><span class="line"><span class="comment"> * ******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判定机器字节序，大端返回true，小端返回false</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">big_endian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> test = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> first = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(&amp;test);</span><br><span class="line">    <span class="keyword">return</span> first == <span class="number">0x12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对字节序进行转换</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">order_switch</span><span class="params">(<span class="keyword">const</span> T &amp;input)</span> </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">output</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">constexpr</span> std::<span class="keyword">size_t</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(input);</span><br><span class="line">    <span class="keyword">uint8_t</span> *data = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(&amp;output);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        data[i] = input &gt;&gt; ((size - i - <span class="number">1</span>) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取一个数的大端表示，在大端机器上直接返回，小端机器上进行转换。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">local2big</span><span class="params">(<span class="keyword">const</span> T &amp;input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">big_endian</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">order_switch</span>(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取一个大端序数的机器表示，实际上与local2big等效。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">big2local</span><span class="params">(<span class="keyword">const</span> T &amp;input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">local2big</span>(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************</span></span><br><span class="line"><span class="comment"> * 以字节方式查看变量</span></span><br><span class="line"><span class="comment"> * *****************************/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_byte</span><span class="params">(<span class="keyword">const</span> T &amp;input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> arr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(&amp;input);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(input); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2x &quot;</span>, arr[i]);</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment"> * SHA256算法实现</span></span><br><span class="line"><span class="comment"> * ******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Packet = std::string;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Packet特化字节查看模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_byte</span><span class="params">(<span class="keyword">const</span> Packet &amp;packet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; packet.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2x &quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(packet[i]));</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8个初始哈希值</span></span><br><span class="line"><span class="keyword">const</span> array&lt;<span class="keyword">uint32_t</span>, 8&gt; h_init =</span><br><span class="line">    &#123;<span class="number">0x6a09e667</span>, <span class="number">0xbb67ae85</span>, <span class="number">0x3c6ef372</span>, <span class="number">0xa54ff53a</span></span><br><span class="line">    ,<span class="number">0x510e527f</span>, <span class="number">0x9b05688c</span>, <span class="number">0x1f83d9ab</span>, <span class="number">0x5be0cd19</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 64个常数</span></span><br><span class="line"><span class="keyword">const</span> array&lt;<span class="keyword">uint32_t</span>, 64&gt; k =</span><br><span class="line">    &#123;<span class="number">0x428a2f98</span>, <span class="number">0x71374491</span>, <span class="number">0xb5c0fbcf</span>, <span class="number">0xe9b5dba5</span>, <span class="number">0x3956c25b</span></span><br><span class="line">    ,<span class="number">0x59f111f1</span>, <span class="number">0x923f82a4</span>, <span class="number">0xab1c5ed5</span>, <span class="number">0xd807aa98</span>, <span class="number">0x12835b01</span></span><br><span class="line">    ,<span class="number">0x243185be</span>, <span class="number">0x550c7dc3</span>, <span class="number">0x72be5d74</span>, <span class="number">0x80deb1fe</span>, <span class="number">0x9bdc06a7</span></span><br><span class="line">    ,<span class="number">0xc19bf174</span>, <span class="number">0xe49b69c1</span>, <span class="number">0xefbe4786</span>, <span class="number">0x0fc19dc6</span>, <span class="number">0x240ca1cc</span></span><br><span class="line">    ,<span class="number">0x2de92c6f</span>, <span class="number">0x4a7484aa</span>, <span class="number">0x5cb0a9dc</span>, <span class="number">0x76f988da</span>, <span class="number">0x983e5152</span></span><br><span class="line">    ,<span class="number">0xa831c66d</span>, <span class="number">0xb00327c8</span>, <span class="number">0xbf597fc7</span>, <span class="number">0xc6e00bf3</span>, <span class="number">0xd5a79147</span></span><br><span class="line">    ,<span class="number">0x06ca6351</span>, <span class="number">0x14292967</span>, <span class="number">0x27b70a85</span>, <span class="number">0x2e1b2138</span>, <span class="number">0x4d2c6dfc</span></span><br><span class="line">    ,<span class="number">0x53380d13</span>, <span class="number">0x650a7354</span>, <span class="number">0x766a0abb</span>, <span class="number">0x81c2c92e</span>, <span class="number">0x92722c85</span></span><br><span class="line">    ,<span class="number">0xa2bfe8a1</span>, <span class="number">0xa81a664b</span>, <span class="number">0xc24b8b70</span>, <span class="number">0xc76c51a3</span>, <span class="number">0xd192e819</span></span><br><span class="line">    ,<span class="number">0xd6990624</span>, <span class="number">0xf40e3585</span>, <span class="number">0x106aa070</span>, <span class="number">0x19a4c116</span>, <span class="number">0x1e376c08</span></span><br><span class="line">    ,<span class="number">0x2748774c</span>, <span class="number">0x34b0bcb5</span>, <span class="number">0x391c0cb3</span>, <span class="number">0x4ed8aa4a</span>, <span class="number">0x5b9cca4f</span></span><br><span class="line">    ,<span class="number">0x682e6ff3</span>, <span class="number">0x748f82ee</span>, <span class="number">0x78a5636f</span>, <span class="number">0x84c87814</span>, <span class="number">0x8cc70208</span></span><br><span class="line">    ,<span class="number">0x90befffa</span>, <span class="number">0xa4506ceb</span>, <span class="number">0xbef9a3f7</span>, <span class="number">0xc67178f2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环右移</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">CROR</span><span class="params">(<span class="keyword">uint32_t</span> input, <span class="keyword">size_t</span> bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((input &gt;&gt; bits) | (input &lt;&lt; (<span class="number">32</span> - bits)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sha256中需要的一些运算</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">S0</span><span class="params">(<span class="keyword">uint32_t</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CROR</span>(x, <span class="number">7</span>) ^ <span class="built_in">CROR</span>(x, <span class="number">18</span>) ^ (x &gt;&gt; <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">S1</span><span class="params">(<span class="keyword">uint32_t</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CROR</span>(x, <span class="number">17</span>) ^ <span class="built_in">CROR</span>(x, <span class="number">19</span>) ^ (x &gt;&gt; <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">EP0</span><span class="params">(<span class="keyword">uint32_t</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CROR</span>(x, <span class="number">2</span>) ^ <span class="built_in">CROR</span>(x, <span class="number">13</span>) ^ <span class="built_in">CROR</span>(x, <span class="number">22</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">EP1</span><span class="params">(<span class="keyword">uint32_t</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CROR</span>(x, <span class="number">6</span>) ^ <span class="built_in">CROR</span>(x, <span class="number">11</span>) ^ <span class="built_in">CROR</span>(x, <span class="number">25</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">CH</span><span class="params">(<span class="keyword">uint32_t</span> x, <span class="keyword">uint32_t</span> y, <span class="keyword">uint32_t</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((x &amp; y) ^ ((~x) &amp; z));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">MAJ</span><span class="params">(<span class="keyword">uint32_t</span> x, <span class="keyword">uint32_t</span> y, <span class="keyword">uint32_t</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x &amp; y) ^ (x &amp; z) ^ (y &amp; z));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Packet <span class="title">sha256</span><span class="params">(<span class="keyword">const</span> Packet &amp;message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> msg = message;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">size_t</span> chunk_size = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">size_t</span> target_size = <span class="number">56</span>;</span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    msg.<span class="built_in">push_back</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">while</span> (msg.<span class="built_in">size</span>() % chunk_size != target_size) &#123;</span><br><span class="line">        msg.<span class="built_in">push_back</span>(<span class="number">0x00</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint64_t</span> length = <span class="built_in">local2big</span>(message.<span class="built_in">size</span>() * <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        msg.<span class="built_in">push_back</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(&amp;length)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分块并计算hash</span></span><br><span class="line">    <span class="keyword">auto</span> chunk_count = msg.<span class="built_in">size</span>() / chunk_size;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">size_t</span> word_count = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">auto</span> H = h_init;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; chunk_count; ++i) &#123;</span><br><span class="line">        <span class="comment">// 初始化word数组</span></span><br><span class="line">        array&lt;<span class="keyword">uint32_t</span>, word_count&gt; w;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">size_t</span> word_size = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">size_t</span> word_per_chunk = chunk_size / word_size;</span><br><span class="line">        <span class="comment">// 从Packet中分割出原始word</span></span><br><span class="line">        <span class="keyword">size_t</span> pos = i * chunk_size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; word_per_chunk; ++j) &#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> value = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint32_t</span>*&gt;(msg.<span class="built_in">c_str</span>() </span><br><span class="line">                + pos + word_size * j);</span><br><span class="line">            w[j] = <span class="built_in">big2local</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据原始word计算剩余word</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = word_per_chunk; j &lt; word_count; ++j) &#123;</span><br><span class="line">            w[j] = w[j - <span class="number">16</span>] + <span class="built_in">S0</span>(w[j - <span class="number">15</span>]) + w[j - <span class="number">7</span>] + <span class="built_in">S1</span>(w[j - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化hash值</span></span><br><span class="line">        <span class="keyword">auto</span> h = H;</span><br><span class="line">        <span class="comment">// 根据word值计算hash值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; word_count; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t1 = h[<span class="number">7</span>] + <span class="built_in">EP1</span>(h[<span class="number">4</span>]) + <span class="built_in">CH</span>(h[<span class="number">4</span>], h[<span class="number">5</span>], h[<span class="number">6</span>]) + k[i] + w[i];</span><br><span class="line">            <span class="keyword">auto</span> t2 = <span class="built_in">EP0</span>(h[<span class="number">0</span>]) + <span class="built_in">MAJ</span>(h[<span class="number">0</span>], h[<span class="number">1</span>], h[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">7</span>; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">                h[j] = h[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">4</span>) &#123;</span><br><span class="line">                    h[j] += t1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h[<span class="number">0</span>] = t1 + t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新hash值供下一个chunk使用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; h.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            H[i] += h[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拼接H得到结果</span></span><br><span class="line">    Packet result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : H) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> value = <span class="built_in">local2big</span>(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(&amp;value)[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment"> * HMAC算法实现</span></span><br><span class="line"><span class="comment"> * ******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Hash = pair&lt;<span class="keyword">size_t</span>, function&lt;<span class="built_in">Packet</span>(<span class="keyword">const</span> Packet&amp;)&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function">Packet <span class="title">hmac</span><span class="params">(<span class="keyword">const</span> Packet &amp;message , <span class="keyword">const</span> Packet &amp;key, <span class="keyword">const</span> Hash &amp;hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> chunk_size = hash.first;</span><br><span class="line">    <span class="function"><span class="keyword">uint8_t</span> <span class="title">ipad</span><span class="params">(<span class="number">0x36</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">uint8_t</span> <span class="title">opad</span><span class="params">(<span class="number">0x5C</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填充key</span></span><br><span class="line">    <span class="keyword">auto</span> padded_key = key;</span><br><span class="line">    <span class="keyword">if</span> (padded_key.<span class="built_in">size</span>() &gt; chunk_size) &#123;</span><br><span class="line">        padded_key = hash.<span class="built_in">second</span>(padded_key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(padded_key.<span class="built_in">size</span>() &lt; chunk_size) &#123;</span><br><span class="line">            padded_key.<span class="built_in">push_back</span>(<span class="number">0x00</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用异或运算生成ipad_key和opad_key</span></span><br><span class="line">    <span class="keyword">auto</span> XOR = [](<span class="keyword">const</span> Packet &amp;packet, <span class="keyword">uint8_t</span> pad) &#123;</span><br><span class="line">        <span class="keyword">auto</span> result = packet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : result) &#123;</span><br><span class="line">            c ^= pad;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> ipad_key = <span class="built_in">XOR</span>(padded_key, ipad);</span><br><span class="line">    <span class="keyword">auto</span> opad_key = <span class="built_in">XOR</span>(padded_key, opad);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用hash算法得到结果</span></span><br><span class="line">    <span class="keyword">return</span> hash.<span class="built_in">second</span>(opad_key + hash.<span class="built_in">second</span>(ipad_key + message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0x00 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++随机数的使用</title>
      <link href="/zh/blog/2021/05/17/0011-C++:random_number_mechanism/"/>
      <url>/zh/blog/2021/05/17/0011-C++:random_number_mechanism/</url>
      
        <content type="html"><![CDATA[<blockquote><p>整理一下STL中random库和cstdlib中随机数机制的用法区别。</p></blockquote><span id="more"></span><h2 id="cstdlib中的随机数用法"><a href="#cstdlib中的随机数用法" class="headerlink" title="cstdlib中的随机数用法"></a>cstdlib中的随机数用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">rand</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序使用系统当前时间作随机数种子，然后使用rand()生成10个随机数。</p><h2 id="STL中的随机数用法"><a href="#STL中的随机数用法" class="headerlink" title="STL中的随机数用法"></a>STL中的随机数用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">default_random_engine <span class="title">e</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">e</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序也是使用系统当前时间作随机数种子，然后使用e()生成10个随机数。</p><p><del>好了，以上就是小编带来的关于如何在c++中使用随机数的全部内容了，你学会了吗？（逃</del></p><h2 id="为什么要使用STL的随机数"><a href="#为什么要使用STL的随机数" class="headerlink" title="为什么要使用STL的随机数"></a>为什么要使用STL的随机数</h2><p>答：用法丰富，使用方便。直接上例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    default_random_engine e;</span><br><span class="line">    <span class="comment">// 设置种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    e.<span class="built_in">seed</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 生成一个范围内的整数</span></span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">rand</span>() % (max - min) + min;</span><br><span class="line">    <span class="function">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; <span class="title">u</span><span class="params">(min, max)</span></span>;</span><br><span class="line">    <span class="built_in">u</span>(e);</span><br><span class="line">    <span class="comment">// 生成随机实数，STL的方法精度高于使用rand() / double的方式生成的实数</span></span><br><span class="line">    <span class="function">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">u</span><span class="params">(min, max)</span></span>;</span><br><span class="line">    <span class="built_in">u</span>(e);</span><br><span class="line">    <span class="comment">// 生成随机布尔, 注意这个描述器不是模板</span></span><br><span class="line">    bernoulli_distribution b;</span><br><span class="line">    <span class="built_in">b</span>(e);</span><br><span class="line">    <span class="comment">// 生成不均匀分布的随机数, 均值4， 标准差1.5</span></span><br><span class="line">    normal_distribution&lt;&gt; <span class="built_in">n</span>(<span class="number">4</span>, <span class="number">1.5</span>);</span><br><span class="line">    <span class="built_in">n</span>(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信大家已经看出来标准库的方便之处了。</p><h2 id="一个非常常见的问题"><a href="#一个非常常见的问题" class="headerlink" title="一个非常常见的问题"></a>一个非常常见的问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">rand</span>();</span><br><span class="line">        default_random_engine e;</span><br><span class="line">        <span class="built_in">e</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式会生成一样的数字，原因是随机数种子被设置时会重置随机数生成器的状态（Engine e初始化时同样设置了默认种子）。应避免在生成随机数时设置种子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    default_random_engine e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">rand</span>();</span><br><span class="line">        <span class="built_in">e</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就没问题了。</p>]]></content>
      
      
      <categories>
          
          <category> 0x01 C++之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深拷贝与浅拷贝</title>
      <link href="/zh/blog/2021/05/15/0010-Python:Deep_copy_and_shallow_copy/"/>
      <url>/zh/blog/2021/05/15/0010-Python:Deep_copy_and_shallow_copy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：自从上次略略学习了一些python基础就没怎么用过python了，这次遇到了深浅拷贝问题，在此记录。</p></blockquote><span id="more"></span><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>考虑下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list1 = []</span><br><span class="line">list2 = list1</span><br><span class="line">list3 = list2</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (some condition):</span><br><span class="line">    list1 = some value</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (some condition):</span><br><span class="line">        list2 = some value</span><br><span class="line">    <span class="keyword">if</span> (f(list3) &lt; f(list2)):</span><br><span class="line">        list3 = list2</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(list3)</span><br></pre></td></tr></table></figure><p>这段代码试图在一些复杂运算中取出最优结果，并将其保存在list3中。由于平时基本是使用C++写程序，我设想它等效于以下C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; list1;</span><br><span class="line">vector&lt;T&gt; list2 = list1;</span><br><span class="line">vector&lt;T&gt; list3 = list1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (some condition) &#123;</span><br><span class="line">    list1 = some value;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (some condition) &#123;</span><br><span class="line">        list2 = some value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(list3) &lt; <span class="built_in">f</span>(list2)) &#123;</span><br><span class="line">        list3 = list2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//void print(const vector&lt;T&gt;&amp;), 打印vector中所有元素</span></span><br><span class="line"><span class="built_in">print</span>(list3)</span><br></pre></td></tr></table></figure><p>作为一个与C++相爱相杀近两年的人，我很确信这段代码能完成任务，事实上它的确能。但python代码却总是出错，于是我试图在list3唯一可能被修改的地方打印出它的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (f(list3) &lt; f(list2)):</span><br><span class="line">    list3 = list2</span><br><span class="line">    <span class="built_in">print</span>(list3)</span><br><span class="line">...</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;final:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(list3)</span><br></pre></td></tr></table></figure><p>令人匪夷所思的事情出现了，输出结果居然是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[aaaaaaaaa]</span><br><span class="line">[bbbbbbbbb]</span><br><span class="line">[ccccccccc]</span><br><span class="line">....</span><br><span class="line">[xxxxxxxxx]</span><br><span class="line">final:</span><br><span class="line">[yyyyyyyyy]</span><br></pre></td></tr></table></figure><p>最后一次赋值后的值居然跟最后输出的值不一样？！几经周折了解到，Python中存在深拷贝与浅拷贝的问题。</p><h2 id="什么是深拷贝与浅拷贝"><a href="#什么是深拷贝与浅拷贝" class="headerlink" title="什么是深拷贝与浅拷贝"></a>什么是深拷贝与浅拷贝</h2><p>简单说，深拷贝就是新建一块内存空间，并将原内存空间中的数据拷贝到新的内存空间中。而浅拷贝不创建内存空间，只令对象引用已存在的内存空间。类比C++的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T *a = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">T *b;</span><br><span class="line">b = a; <span class="comment">// 浅拷贝</span></span><br><span class="line">b = <span class="keyword">new</span> <span class="built_in">T</span>(*a); <span class="comment">// 深拷贝</span></span><br></pre></td></tr></table></figure><p>这里需要注意，不存在指针的语言中（如Python, Java）引用的含义和C++是不同的，更接近于C++中的指针。C++中的引用只是变量的别名，是不可以更改指向的变量的。而Python中的引用更像是一个自动的指针，可以取值也可以改变所指，并且无需显式指定操作，由语言情景决定改执行哪种操作。</p><h2 id="Python的对象机制"><a href="#Python的对象机制" class="headerlink" title="Python的对象机制"></a>Python的对象机制</h2><p>由于python中不存在指针和引用，也就无法像C++那样自由选择值传递或传引用传递。为了避免操作大对象时的巨大开销，python的应对方法是——一切皆引用。即，每个变量实际上都是引用类型，赋值（=）号通常并不新建对象，而是让变量的引用指向指定的地址。</p><p>也就是说，上面的程序中list1，list2和list3实际上是同一个对象的不同引用，验证如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = []</span><br><span class="line">list2 = list1</span><br><span class="line">list3 = list1</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(list1), <span class="string">&quot; &quot;</span> ,<span class="built_in">id</span>(list2), <span class="string">&quot; &quot;</span>, <span class="built_in">id</span>（list3)</span><br></pre></td></tr></table></figure><p>可以看出它们的地址相同，即为同一个对象。那么理所应当地，我们通过哪一个引用改变变量的值都会更改这唯一的地址空间。</p><p>这里你可能对一切皆引用这个说法有所质疑，并提出如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = a</span><br><span class="line">b = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(a, <span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(b, <span class="built_in">id</span>(b))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 139656604350896</span><br><span class="line">3 139656604350832</span><br></pre></td></tr></table></figure><p>这输出似乎与一切皆引用有出入，因为更改b的值既没有影响a的值，a和b的地址也不一样。这里的核心是：语句<code>b = 3</code>的语义真的是更改b的值吗？我们对这个例子稍作改动：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a), <span class="string">&quot; &quot;</span>, <span class="built_in">id</span>(b))</span><br><span class="line">b = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b), <span class="string">&quot; &quot;</span>, <span class="built_in">id</span>(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">140143427922352   140143427922352</span><br><span class="line">140143427922288   140143427922288</span><br></pre></td></tr></table></figure><p>没错，常量3也是一个引用。只不过无法改变它的指向。这里一个事实已经呼之欲出，赋值运算符（=）只改变引用的指向。即只能用作浅拷贝。</p><h2 id="如何进行深拷贝"><a href="#如何进行深拷贝" class="headerlink" title="如何进行深拷贝"></a>如何进行深拷贝</h2><p>那么如何进行深拷贝呢？对一个列表，我们可能会想要使用切片创建新的内存空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list2 = list1[:]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(list1), <span class="string">&quot; &quot;</span>, <span class="built_in">id</span>(list2))</span><br></pre></td></tr></table></figure><p>这里可以看出list2已经拥有了新的内存空间。但这种方法在处理多层列表的时候，会出现问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]]</span><br><span class="line">list2 = list1[:]</span><br><span class="line">list1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(list2[<span class="number">0</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>list2的值还是被list1的修改改动了，这是因为list2虽然和list1没有指向同一块地址空间。但其中第一个元素却指向了同一块地址空间。</p><p>因此，<strong>深拷贝唯一指定方法：copy.deepcopy()</strong></p>]]></content>
      
      
      <categories>
          
          <category> 0x02 技术杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Archiso构建高度定制化的PE启动盘</title>
      <link href="/zh/blog/2021/05/14/0009-ArchISO/"/>
      <url>/zh/blog/2021/05/14/0009-ArchISO/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直想要一个自己的PE启动盘，以便使用一个小小的U盘将自己的开发环境带到任何地方。折腾了两天，终于制作了一个粗糙的镜像。在此作一个记录。</p><p>镜像地址：<a class="link"   href="https://github.com/VincentJan/VrchPE" >https://github.com/VincentJan/VrchPE<i class="fas fa-external-link-alt"></i></a></p></blockquote><span id="more"></span><h2 id="开始之前的一些废话"><a href="#开始之前的一些废话" class="headerlink" title="开始之前的一些废话"></a>开始之前的一些废话</h2><p>很久之前其实尝试过将系统装在移动硬盘上，做成一个移动系统。但是由于当时相关知识约等于0，竟然把引导分区装在了另一个硬盘上。这次最早的尝试毫无疑问地失败了。</p><p>后来在学习了一些相关知识后又进行了一次尝试，发现在别的电脑上无法启动图形界面。本来只是简单的显卡驱动问题，一开始的失败经历让我直接放弃。当然最主要的原因还是觉得移动系统没什么用处。</p><p>直到前两天实验课上需要在linux上装一些古董软件，直接触发了我的系统洁癖。当时想着有没有什么办法能让系统在干完一些脏活后恢复成原来的样子。于是就有了这次折腾经历。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>需要一台能联网的Arch Linux电脑和一个用作启动盘的U盘。现在的U盘应该很少16G以下的了，不用考虑容量问题。但最好是USB3.0协议的，操作的时候能快一些。</p><p>安装archiso软件包：<code>pacman -S archiso</code></p><p>创建一个目录用来构建镜像：<code>mkdir Vrch</code>并把/usr/share/archiso/configs/baseline中的文件复制到目录中。</p><p><em>也可以使用/usr/share/archiso/configs/releng中的文件，差别在于baseline提供了一个最小可启动镜像配置，而releng提供最近的安装镜像配置</em></p><p>具体说明：<a class="link"   href="https://wiki.archlinux.org/title/Archiso#Prepare_a_custom_profile" >Archiso#prepare_custom_profile-ArchWiki<i class="fas fa-external-link-alt"></i></a></p><h2 id="配置镜像文件"><a href="#配置镜像文件" class="headerlink" title="配置镜像文件"></a>配置镜像文件</h2><h3 id="选择软件包"><a href="#选择软件包" class="headerlink" title="选择软件包"></a>选择软件包</h3><p>编辑Vrch/packages.x86_64，把想要安装的包名加进去就可以了。</p><p>如果想要使用无线网卡等设备，添加<code>linux-firmware</code>包。</p><p>如果需要图形界面，除了<code>xorg</code>以外，还要注意显卡驱动以及<code>xorg-xinit</code>。</p><p>显卡驱动参考：<a class="link"   href="https://wiki.archlinux.org/title/Xorg#Input_devices" >Xorg#input_devices-ArchWiki<i class="fas fa-external-link-alt"></i></a></p><h3 id="向镜像添加文件"><a href="#向镜像添加文件" class="headerlink" title="向镜像添加文件"></a>向镜像添加文件</h3><p>将Vrch/airootfs看做系统根目录，其中的一切文件都会被复制到镜像系统的相应位置。</p><p>我们可以在这里添加各种配置文件，以及systemd服务自启动所需的软连接。</p><p>需要注意，文件权限是不会被原样复制的。若需更改某文件的权限，可以编辑Vrch/prefiledef.sh中相关位置。</p><h2 id="生成镜像文件"><a href="#生成镜像文件" class="headerlink" title="生成镜像文件"></a>生成镜像文件</h2><p>在Vrch目录中运行:<code>mkarchiso -v .</code>，漫长的等待后，会出现一个work目录与一个out目录。其中work目录是构建进程中产生的工作目录，out目录中存放最终产生的iso文件。</p><p>work与out目录的位置可以通过命令参数选择。</p><h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><p>这部分平平无奇，插入U盘，在Vrch目录下运行:<code>dd if=out/isoname.iso of=/dev/sdx bs=4M</code></p><p>isoname为生成的镜像名称，sdx为U盘的名称。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://wiki.archlinux.org/title/Archiso" >Archiso_ArchWiki<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      <categories>
          
          <category> 0x02 技术杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Haskell解决四柱汉诺塔问题</title>
      <link href="/zh/blog/2021/01/27/0008-Haskell:Four_Pillar_Tower_of_Hanoi/"/>
      <url>/zh/blog/2021/01/27/0008-Haskell:Four_Pillar_Tower_of_Hanoi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>初学Haskell，在做 <a class="link"   href="https://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf" >CIS 194 HomeWork1<i class="fas fa-external-link-alt"></i></a>时遇到的四柱汉渃塔最优解问题。过程中对递归与函数式编程产生了许多新的理解，在此做一下记录。</p></blockquote><span id="more"></span><h2 id="回顾：汉诺塔是什么？"><a href="#回顾：汉诺塔是什么？" class="headerlink" title="回顾：汉诺塔是什么？"></a>回顾：汉诺塔是什么？</h2><blockquote><p>The Towers of Hanoi is a classic puzzle with a solution that can be described recursively. Disks of different sizes are stacked on three pegs; the goal is to get from a starting configuration with all disks stacked on the first peg to an ending configuration with all disks stacked on the last peg, as shown in Figure 1. </p><img src="https://img.xilong.site/20210415/image-20210127013232812.png" alt="image-20210127013232812" style="zoom:33%;" /><p>​    Figure 1: The Towers of Hanoi<br>The only rules are<br>• you may only move one disk at a time, and<br>• a larger disk may never be stacked on top of a smaller one.<br>For example, as the first move all you can do is move the topmost, smallest disk onto a different peg, since only one disk may be moved at a time. </p><img src="https://img.xilong.site/20210415/image-20210127013307704.png" alt="image-20210127013307704" style="zoom:50%;" /><p>​    Figure 2: A valid first move.<br>From this point, it is illegal to move to the configuration shown in Figure 3, because you are not allowed to put the green disk on top of the smaller blue one. </p><img src="https://img.xilong.site/20210415/image-20210127013331098.png" alt="image-20210127013331098" style="zoom:50%;" /><p>​    Figure 3: An illegal configuration.<br>To move n discs (stacked in increasing size) from peg a to peg b using peg c as temporary storage, </p><ol><li>move n − 1 discs from a to c using b as temporary storage </li><li>move the top disc from a to b </li><li>move n − 1 discs from c to b using a as temporary storage. </li></ol></blockquote><p>这东西相信大家都非常熟悉了，不多缀言。下面进入第一个问题，使用Haskell求解汉诺塔。</p><h2 id="Haskell求解汉诺塔"><a href="#Haskell求解汉诺塔" class="headerlink" title="Haskell求解汉诺塔"></a>Haskell求解汉诺塔</h2><blockquote><p>Given the number of discs and names for the three pegs, hanoi should return a list of moves to be performed to move the stack of discs from the first peg to the second.</p></blockquote><p>先上代码：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Peg</span> = <span class="type">String</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Move</span> = (<span class="type">Peg</span>, <span class="type">Peg</span>)</span></span><br><span class="line"><span class="comment">-- hanoi numOfDiscs-&gt;originPeg-&gt;targetPeg-&gt;otherPeg-&gt;moves</span></span><br><span class="line"><span class="title">hanoi</span> :: <span class="type">Integer</span>-&gt;<span class="type">Peg</span>-&gt;<span class="type">Peg</span>-&gt;<span class="type">Peg</span>-&gt;[<span class="type">Move</span>]</span><br><span class="line"><span class="title">hanoi</span> <span class="number">0</span> a b c = []</span><br><span class="line"><span class="title">hanoi</span> n a b c = hanoi (n - <span class="number">1</span>) a c b ++ [(a, b)] ++ hanoi (n - <span class="number">1</span>) c b a</span><br></pre></td></tr></table></figure><p>这几行程序没费什么力，使我深深地体会到了Haskell的简洁与优雅，这种写法实在是太漂亮了。这里用了很简单的一个思路，hanoi n a b c表示由a柱，经c柱移动n个盘子到b柱。</p><p><code>hanoi n a b c = hanoi (n - 1) a c b ++ [(a, b)] ++ hanoi (n - 1) c b a</code></p><p>这句代码表达先把上层 n - 1个盘子由a柱移动到c柱，再把最底层盘子直接移动到b柱，最后把c柱上的盘子也移动到b柱。Haskell这种写法在简洁与表达力上实在是令我惊叹。</p><h2 id="再来一根：四柱汉诺塔问题"><a href="#再来一根：四柱汉诺塔问题" class="headerlink" title="再来一根：四柱汉诺塔问题"></a>再来一根：四柱汉诺塔问题</h2><p>顾名思义，四柱汉诺塔就是在三柱汉诺塔的基础上再加一根柱子。同样是求将一根柱子上的盘子全部移动到另一根上的过程序列。</p><p>解四柱汉诺塔的基本思路是由a柱，经过b柱、d柱的辅助，将一部分盘子移动到c柱。</p><p>由于所有先移出去的盘子一定比剩下任一的盘子小，在移动剩下的盘子时就无法再借助c柱了，问题变成两个三柱汉诺塔问题：</p><ol><li>由a柱经过b柱的辅助将除最下层盘子外的盘子移动到d柱；</li><li>将最下层盘子移动到b柱；</li><li>由d柱经过a柱的辅助将盘子移动到b柱</li></ol><p>现在的状态是，a柱、d柱上没有盘子，c柱上有一开始移动出去的盘子，b柱上有剩下的盘子。由于c柱上的盘子都小于b柱上的盘子，故而在移动时可以借助b柱。则由c柱经过a柱、d柱的辅助将盘子移动到b柱上，即完成了将所有盘子由a柱移动到b柱的过程。</p><p>那么应该怎么把盘子分成两份呢？这里简单起见，将盘子平分成两分。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">hanoiPlus</span> :: <span class="type">Integer</span>-&gt;<span class="type">Peg</span>-&gt;<span class="type">Peg</span>-&gt;<span class="type">Peg</span>-&gt;<span class="type">Peg</span>-&gt;[<span class="type">Move</span>]</span><br><span class="line"><span class="title">hanoiPlus</span> <span class="number">0</span> _ _ _ _ = []</span><br><span class="line"><span class="title">hanoiPlus</span> n a b c d = hanoiPlus (left - k) a c b d</span><br><span class="line">            ++ hanoi k a d b</span><br><span class="line">            ++ [(a, b)]</span><br><span class="line">            ++ hanoi k d b a</span><br><span class="line">            ++ hanoiPlus (left - k) c b a d</span><br><span class="line">    <span class="keyword">where</span>   </span><br><span class="line">        left = n - <span class="number">1</span></span><br><span class="line">        k = n `div` <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="你的时间非常值钱：四柱汉诺塔最优解"><a href="#你的时间非常值钱：四柱汉诺塔最优解" class="headerlink" title="你的时间非常值钱：四柱汉诺塔最优解"></a>你的时间非常值钱：四柱汉诺塔最优解</h2><p>平分是无法达到最优效率的，因为3柱移动比4柱移动耗时，要达到最优效率，需要加一个分割函数。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">hanoiPlus</span> :: <span class="type">Integer</span>-&gt;<span class="type">Peg</span>-&gt;<span class="type">Peg</span>-&gt;<span class="type">Peg</span>-&gt;<span class="type">Peg</span>-&gt;[<span class="type">Move</span>]</span><br><span class="line"><span class="title">hanoiPlus</span> <span class="number">0</span> _ _ _ _ = []</span><br><span class="line"><span class="title">hanoiPlus</span> n a b c d = hanoiPlus (left - k) a c b d</span><br><span class="line">            ++ hanoi k a d b</span><br><span class="line">            ++ [(a, b)]</span><br><span class="line">            ++ hanoi k d b a</span><br><span class="line">            ++ hanoiPlus (left - k) c b a d</span><br><span class="line">    <span class="keyword">where</span>   </span><br><span class="line">        left = n - <span class="number">1</span></span><br><span class="line">        k = minimalDivide n</span><br><span class="line"></span><br><span class="line"><span class="title">minimalDivide</span> :: <span class="type">Integer</span>-&gt;<span class="type">Integer</span></span><br><span class="line"><span class="title">minimalDivide</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="title">minimalDivide</span> n = head (minimalDivideList n)</span><br><span class="line"></span><br><span class="line"><span class="title">minimalDivideList</span> :: <span class="type">Integer</span>-&gt;[<span class="type">Integer</span>]</span><br><span class="line"><span class="title">minimalDivideList</span> <span class="number">0</span> = []</span><br><span class="line"><span class="title">minimalDivideList</span> n = minimalDivideList&#x27; [<span class="number">1</span>,<span class="number">2.</span>.n] []</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        minimalDivideList&#x27; :: [<span class="type">Integer</span>]-&gt;[<span class="type">Integer</span>]-&gt;[<span class="type">Integer</span>]</span><br><span class="line">        minimalDivideList&#x27; (x:xs) [] = minimalDivideList&#x27; xs (<span class="number">0</span>:[])</span><br><span class="line">        minimalDivideList&#x27; [] ys = ys</span><br><span class="line">        minimalDivideList&#x27; (x:xs) (y:ys) = minimalDivideList&#x27; xs ((cur):(y:ys))</span><br><span class="line">            <span class="keyword">where</span></span><br><span class="line">                cur = <span class="keyword">if</span> x - y &lt;= <span class="number">1</span> || (hanoiPlus&#x27; x y) &lt;= (hanoiPlus&#x27; x (y + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">then</span> y <span class="keyword">else</span> y + <span class="number">1</span></span><br><span class="line">                hanoiPlus&#x27; :: <span class="type">Integer</span>-&gt;<span class="type">Integer</span>-&gt;<span class="type">Integer</span></span><br><span class="line">                hanoiPlus&#x27; <span class="number">0</span> _ = <span class="number">0</span></span><br><span class="line">                hanoiPlus&#x27; n&#x27; divide = </span><br><span class="line">                    <span class="number">2</span> * (hanoiPlus&#x27; left&#x27; divide&#x27;)</span><br><span class="line">                    + (<span class="number">2</span>^divide - <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">where</span> </span><br><span class="line">                        left&#x27; = n&#x27; - divide - <span class="number">1</span></span><br><span class="line">                        divide&#x27; = <span class="keyword">if</span> left&#x27; == <span class="number">0</span> <span class="keyword">then</span> <span class="number">0</span> </span><br><span class="line">                        <span class="keyword">else</span> (reverse (y:ys))!!fromInteger(left&#x27; - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0x03 从零开始的Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NC15553题解</title>
      <link href="/zh/blog/2020/10/11/0007-NC15553/"/>
      <url>/zh/blog/2020/10/11/0007-NC15553/</url>
      
        <content type="html"><![CDATA[<blockquote><p>NC15553 数学考试，对理解前缀和与枚举很有好处。<br>题目链接：<a class="link"   href="https://ac.nowcoder.com/acm/problem/15553" >NC15553 数学考试——牛客网<i class="fas fa-external-link-alt"></i></a></p></blockquote><span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>今天qwb要参加一个数学考试，这套试卷一共有n道题，每道题qwb能获得的分数为ai，qwb并不打算把这些题全做完，<br> 他想选总共2k道题来做，并且期望他能获得的分数尽可能的大，他准备选2个不连续的长度为k的区间,<br> 即[L,L+1,L+2,….,L+k-1]，[R,R+1,R+2,…,R+k-1]（R &gt;= L+k）。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行一个整数T（T&lt;=10）,代表有T组数据</span><br><span class="line">接下来一行两个整数n,k,(1&lt;=n&lt;=200,000),(1&lt;=k,2k &lt;= n)</span><br><span class="line">接下来一行n个整数a1,a2,...,an，（-100,000&lt;=ai&lt;=100,000）</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个整数，qwb能获得的最大分数</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6 3</span><br><span class="line">1 1 1 1 1 1</span><br><span class="line">8 2</span><br><span class="line">-1 0 2 -1 -1 2 3 -1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先需要解决的是如何确定一个区间。一个区间显然可以用[左端点, 右端点]这样的数对来确定，而本题中区间的长度是给定的，因此只要用左端点与右端点中的一个点就能确定一个区间，这里我们选用左端点。</p><p>然后考虑暴力解法，这题如果用暴力来做，需要O(n^2)的复杂度遍历每种可能的区间组合。以及O(k)的复杂度计算每个区间的和。则总的时间复杂度为O(kn^2)，最坏情况下kn^2 = 4 x 10^15，显然无法在可接受的时间内完成运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//main</span><br><span class="line">//暴力枚举区间组合，求解最大值</span><br><span class="line">for(i : n - k)</span><br><span class="line">&#123;</span><br><span class="line">for(j = i + k : n - k)</span><br><span class="line">&#123;</span><br><span class="line">//Sum为求和函数</span><br><span class="line">maxCount = max(maxCount, Sum(i) + Sum(j))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//Sum(i)</span><br><span class="line">&#123;</span><br><span class="line">count = 0</span><br><span class="line">for(i : i + k)</span><br><span class="line">&#123;</span><br><span class="line">count += a[i]</span><br><span class="line">&#125;</span><br><span class="line">return count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看见区间的和可以想到前缀和，通过维护一个前缀和来将每个区间的和的计算时间复杂度降为O(1)，这样整个问题的时间复杂度就降为了枚举的O(n^2)，最坏情况下n^2 = 4 x 10^10，仍然无法在可接受的时间内完成运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//main</span><br><span class="line">//暴力枚举区间组合，求解最大值</span><br><span class="line">for(i : n - k)</span><br><span class="line">&#123;</span><br><span class="line">for(j = i + k : n - k)</span><br><span class="line">&#123;</span><br><span class="line">//sum为维护的区间和</span><br><span class="line">maxCount = max(maxCount, sum[i] + sum[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们规定j一定大于i，由此观察遍历过程</p><p><img src="https://img.xilong.site/20201011/image-20201011145807948.png" alt="image-20201011145807948"></p><p>两次遍历中有很多重合部分，对于寻找最大值而言是没有必要的。因为若前进一步后的i’ &lt; i，则它们分别加上同一个数后大小关系不变。而变化后i仍在有效取值范围内，因此，维护一个maxi的值即可省略对灰色部分的遍历。</p><p><img src="https://img.xilong.site/20201011/image-20201011151108260.png" alt="image-20201011151108260"></p><p>对于j’以后的值无需判断，因为max’定不小于max且j’后的值max和max’都可取用，所以不可能存在max + jx &gt; max’ + jx（jx在j’之后）。</p><p><img src="https://img.xilong.site/20201011/image-20201011152355021.png" alt="image-20201011152355021"></p><p>因此我们仅需考虑这一部分，其中对于step2，max’ + j’即是这一步的最大值，将其与上一步的最大值比较来更新maxCount，再将step2看做step1对其进行相同操作，最后即可求出maxCount的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">maxi = sum[0];</span><br><span class="line">maxCount = maxi + sum[k];</span><br><span class="line">for(i : n - k)</span><br><span class="line">&#123;</span><br><span class="line">maxi = max(maxi, sum[i]);</span><br><span class="line">maxCount = max(maxCount, maxi + sum[i + k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，满足题目要求。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll infinity = <span class="number">3e10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="comment">//输入时即维护前缀和</span></span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">sum</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        cin &gt;&gt; sum[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; sum[i];</span><br><span class="line">            sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跟据前缀和求出每个区间的和</span></span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">kSum</span><span class="params">(n + <span class="number">1</span> - k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        kSum[<span class="number">0</span>] = sum[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt; n + <span class="number">1</span> - k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            kSum[i] = sum[i - <span class="number">1</span> + k] - sum[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举求最大值</span></span><br><span class="line">        ll curMax = infinity * <span class="number">-1</span>;</span><br><span class="line">        ll count = infinity * <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt;= n - <span class="number">2</span> * k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            curMax = <span class="built_in">max</span>(curMax, kSum[i]);</span><br><span class="line">            count = <span class="built_in">max</span>(count, curMax + kSum[i + k]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0x00 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux平台下C++库的生成与使用</title>
      <link href="/zh/blog/2020/06/07/0006-Creating_and_using_library_in_linux/"/>
      <url>/zh/blog/2020/06/07/0006-Creating_and_using_library_in_linux/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习C++也有一段时间了，却一直不太了解库相关的知识，今天得空学习了一些基础用法，在此记录。</p><p>内容包含：</p><p>1.什么是库(library)？静态库与动态库的区别与优缺点</p><p>3.静态库的生成与使用</p><p>4.动态库的生成与使用</p></blockquote><span id="more"></span><h2 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h2><h3 id="编译连接：从源码到程序"><a href="#编译连接：从源码到程序" class="headerlink" title="编译连接：从源码到程序"></a>编译连接：从源码到程序</h3><p><img src="https://img.xilong.site/20200607/image-20200607222237087.png" alt="image-20200607222237087"></p><p>上图展示了C++程序的生成过程。可以看到库文件和目标代码一起被处理，可见库文件与目标代码之间应该具有某种联系。</p><h3 id="库：目标文件的打包"><a href="#库：目标文件的打包" class="headerlink" title="库：目标文件的打包"></a>库：目标文件的打包</h3><p>事实上，库文件就是将一些目标文件打包而成的文件。这些文件往往与作为接口的头文件一起提供给程序使用。程序在使用库文件时不需要对文件中实现的内容进行重复编译，可以提高开发效率。</p><p>库又分为静态库与动态库。</p><h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><p>静态库在Linix系统中通常以.a作为后缀，而在Windows中以.lib作为后缀。</p><p>静态库在链接过程中将自身拷贝到最终的可执行文件中，因此可执行文件运行时并不需要该库参与。即使用静态库生成的文件是独立的，并不依赖于它所使用的静态库。这无疑为软件的分发提供了很大的方便。</p><p>另一方面，这样的使用方式令生成程序所需时间大大增加，同时大幅增加了可执行文件的体积。且每当库发生改动时就要重新生成整个程序。不利于开发。</p><h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><p>动态库在Linux系统中通常以.so作为后缀，在Windows中以.dll作为后缀。</p><p>动态库在链接过程中不把自身拷贝到可执行文件中，而是写入一些重定位和符号表信息。这样生成的可执行文件运行时必需要有库的存在，否则无法运行。这给分发软件造成了一些目标机器环境配置的麻烦。</p><p>然而，动态库大大缩减了链接所需时间和可执行程序的体积，在接口没有改动时即使改动了库文件也无需重新生成可执行文件，实现了增量修改。给开发带来了很大的便利。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>静态链接的可执行文件可以独立运行，而动态链接不可以。</li><li>静态链接的可执行文件体积通常大于动态链接。</li><li>静态链接的链接速度小于动态链接</li><li>静态链接的可执行文件运行效率略高于动态链接</li><li>库文件发生改动时，静态链接生成的可执行文件必需重新生成，而动态链接不用。</li></ol><h2 id="静态库的生成与使用"><a href="#静态库的生成与使用" class="headerlink" title="静态库的生成与使用"></a>静态库的生成与使用</h2><h3 id="编写静态库源码并生成目标代码"><a href="#编写静态库源码并生成目标代码" class="headerlink" title="编写静态库源码并生成目标代码"></a>编写静态库源码并生成目标代码</h3><p>创建静态库文件夹static，并新建静态库源代码./static/test.cc</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./static/test.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Say_Hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello Static Library!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译源码，生成目标文件test.o</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c ./static/test.cpp -o ./static/test.o</span><br></pre></td></tr></table></figure><h3 id="将目标代码打包成库文件"><a href="#将目标代码打包成库文件" class="headerlink" title="将目标代码打包成库文件"></a>将目标代码打包成库文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 库通常以libxxx.a命名</span></span><br><span class="line">ar -rcs ./static/libtest.a ./static/test.o</span><br></pre></td></tr></table></figure><h3 id="为使用者提供接口"><a href="#为使用者提供接口" class="headerlink" title="为使用者提供接口"></a>为使用者提供接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./static/test.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Say_Hello</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h3><p>创建main.cc</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./main.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./static/test.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Say_Hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成并运行可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -L指定库所在路径，-l指定库名称无需lib与后缀</span></span><br><span class="line">g++ -o main main.cc -L./static -ltest</span><br><span class="line">./main</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Static Library!</span><br></pre></td></tr></table></figure><h2 id="动态库的生成与使用"><a href="#动态库的生成与使用" class="headerlink" title="动态库的生成与使用"></a>动态库的生成与使用</h2><h3 id="编写动态库源码并生成目标代码"><a href="#编写动态库源码并生成目标代码" class="headerlink" title="编写动态库源码并生成目标代码"></a>编写动态库源码并生成目标代码</h3><p>创建静态库文件夹dynamic，并新建静态库源代码./dynamic/test.cc</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./dynamic/test.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Say_Hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello Dynamic Library!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态库通常以libxxx.so命名</span></span><br><span class="line">g++ ./dynamic/test.cc -fPIC -shared -o libtest.so</span><br></pre></td></tr></table></figure><h3 id="为使用者提供接口-1"><a href="#为使用者提供接口-1" class="headerlink" title="为使用者提供接口"></a>为使用者提供接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./dynamic/test.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Say_Hello</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="使用动态库"><a href="#使用动态库" class="headerlink" title="使用动态库"></a>使用动态库</h3><p>创建main.cc</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./main.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./dynamic/test.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Say_Hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成并运行可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -L指定库所在路径，-l指定库名称</span></span><br><span class="line">g++ -o main main.cc -L./dynamic -ltest</span><br><span class="line">./main</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main: error while loading shared libraries: libtest.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>找不到<code>libtest.so</code>，这是因为linux是通过<code>/etc/ld.so.config</code>文件中的路径搜寻动态库的。解决方法：</p><ol><li>把<code>libtest.so</code>所在的路径添加进<code>/etc/ld.so.config</code>，再运行<code>idconfig</code>更新目录，程序就可以正常运行了。</li><li>把<code>libtest.so</code>复制到<code>/usr/lib</code>，再运行程序。</li><li>改变坏境变量<code>export LD_LIBRARY_PATH=./dynamic</code>，再运行程序。</li></ol><p>由于这个程序仅作实验用，故不推荐用前两种方式改动系统设置。此处用方法3:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=./dynamic</span><br><span class="line">./main</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Dynamic Library!</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>库是将源码打包而形成的，以链接进其它程序的方式进行使用的文件形式。分为静态库和动态库。静态库具有链接慢，空间成本高，不易更新的缺点，优点是能够生成独立的可执行文件。动态库易于更新扩展，链接快，空间成本低，但生成的文件必需依赖库运行。</p>]]></content>
      
      
      <categories>
          
          <category> 0x01 C++之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于C++的Python3入门笔记</title>
      <link href="/zh/blog/2020/06/07/0005-Python3:Getting_started_base_on_C++/"/>
      <url>/zh/blog/2020/06/07/0005-Python3:Getting_started_base_on_C++/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：虽然Python与C++有众多区别，但基本上同属命令式语言（甚至Python的解释器是C++实现的），因此在不求深入学习Python时记住一些基础语法差异即可大概使用。</p></blockquote><span id="more"></span><h2 id="基本区别"><a href="#基本区别" class="headerlink" title="基本区别"></a>基本区别</h2><p>python中以缩进（4个空格）而不是花括号区分代码块。</p><p>python中以换行而不是分号区分语句</p><p>python中不需要main函数，从代码第一行开始执行</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行注释：井号+空格</span></span><br><span class="line"><span class="comment"># 多行注释本质上是野生三引号字符串</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">多行注释1:三个单引号</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">多行注释2:三个双引号</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p>python是动态类型语言，定义变量时无需指定类型，且程序运行过程中可改变类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">f = <span class="number">2.3</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;string&#x27;</span></span><br><span class="line">f = <span class="string">&#x27;change to string&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="string">&#x27;Hello&quot;&quot;Wo\&#x27;\&#x27;rld&#x27;</span> <span class="comment"># Hello&quot;&quot;Wo&#x27;&#x27;rld</span></span><br><span class="line"><span class="comment"># 双引号</span></span><br><span class="line"><span class="string">&quot;Hello&#x27;&#x27;Wo\&quot;\&quot;rld&quot;</span> <span class="comment">#Hello&#x27;&#x27;Wo&quot;&quot;rld</span></span><br><span class="line"><span class="comment"># 单双引号唯一的区别是其中包含哪种引号时需要转义</span></span><br><span class="line"><span class="comment"># 三引号包含单双引号都不用转义，可作注释用</span></span><br></pre></td></tr></table></figure><p>格式化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 占位符</span></span><br><span class="line"><span class="string">&#x27;Hello,%s %d %.2f, %02d&#x27;</span> % (<span class="string">&#x27;World!&#x27;</span>, <span class="number">123</span>, <span class="number">3.14159</span>, <span class="number">1</span>) <span class="comment"># Hello,World! 123 3.14 01</span></span><br><span class="line"><span class="comment"># format(),用&#123;0&#125;&#123;1&#125;...当占位符</span></span><br><span class="line"><span class="string">&#x27;Hello,&#123;0&#125;:&#123;1:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;World!&#x27;</span>, <span class="number">3.14159</span>) <span class="comment"># Hello,World:3.1</span></span><br></pre></td></tr></table></figure><h3 id="list、tuple和dict、set"><a href="#list、tuple和dict、set" class="headerlink" title="list、tuple和dict、set"></a>list、tuple和dict、set</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># []、()、&#123;&#125;、([])</span></span><br><span class="line"><span class="comment"># list用[]定义, 可变长，可变元素值，可用下标位序取值</span></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># tuple用()定义，不可变长，不可变元素值，可用下标位序取值</span></span><br><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">t1 = (<span class="number">1</span>, ) <span class="comment"># 若无逗号则为整数1</span></span><br><span class="line"><span class="comment"># dict用&#123;&#125;定义， 类似c++的map; set用([])定义，类似set</span></span><br><span class="line">d = &#123;a:<span class="number">1</span>, <span class="number">2</span>:b, <span class="number">3</span>:c&#125; <span class="comment"># d[a] = 1, d[2] = b, d[3] = c</span></span><br><span class="line">s = ([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment"># set自动去重，s = &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ol><li>list<ol><li>l.append(): push_back</li><li>l.pop():pop_back</li><li>l.pop(i):erase(i)</li><li>l.insert(pos, vue)</li></ol></li><li>dict<ol><li>‘keyvalue’ in d //d中是否存在key值为‘keyvalue’</li><li>d.get(‘keyvalue’, -1) //无’keyvalue’时返回-1，没有第二个参数则无返回值</li><li>d.pop(‘keyvalue’) //删除keyvalue</li></ol></li><li>set<ol><li>add(key)</li><li>remove(key)</li></ol></li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>算术运算符：+    -    *    /    %    **(幂)    //(整除)</li><li>比较运算符：==    !=    &gt;    &lt;    &gt;=   &lt;=</li><li>赋值运算符：=    算术=</li><li>位运算符：&amp;    |    ^    ~    &lt;&lt;    &gt;&gt;</li><li>逻辑运算符：and    or    not</li><li>成员运算符：in    not in</li><li>身份运算符：is    is not //判断两对象地址是否相同</li></ul><h2 id="分支与循环"><a href="#分支与循环" class="headerlink" title="分支与循环"></a>分支与循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if-else语句</span></span><br><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 占位用关键字，不执行任何操作</span></span><br><span class="line"><span class="keyword">elif</span> condition:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 范围for</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> l:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 可用range(10)生成0-9的列表</span></span><br><span class="line"><span class="comment"># while</span></span><br><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">    psss</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Dont_Do_Anything</span>(<span class="params">x, y</span>)</span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">x</span>, <span class="title">y</span></span></span><br><span class="line"><span class="function">#隐式返回一个元组</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">Default_Function</span>(<span class="params">x, y=<span class="number">2</span></span>)</span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">x</span>**<span class="title">y</span>;</span></span><br><span class="line"><span class="function">#默认参数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">Add_End</span>(<span class="params">L</span>)</span></span><br><span class="line"><span class="function"><span class="title">L</span>.<span class="title">append</span>(<span class="params"><span class="string">&#x27;End&#x27;</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">L</span></span></span><br><span class="line"><span class="function">#多次调用会出现&#123;<span class="title">End</span>, <span class="title">End</span>, <span class="title">End</span>&#125;，原因：参数并非临时变量，故而改进</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">Add_End_Fixed</span>(<span class="params">L=<span class="literal">None</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">L</span> <span class="title">is</span> <span class="title">None</span>:</span></span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">&#x27;End&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Calc</span>(<span class="params">*numbers</span>)</span></span><br><span class="line"><span class="function"><span class="title">sum</span> = 0</span></span><br><span class="line"><span class="function"><span class="title">for</span> <span class="title">x</span> <span class="title">in</span> <span class="title">numbers</span>:</span></span><br><span class="line">        <span class="built_in">sum</span> += x</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"><span class="comment">#可变数量参数，隐式生成一个tuple, 已有list或tuple可直接前加*传入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age, **kw</span>)</span></span><br><span class="line"><span class="function"><span class="title">if</span> &#x27;<span class="title">key</span>&#x27; <span class="title">in</span> <span class="title">kw</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字参数，调用时连关键字一同写入，如person(&#x27;Jack&#x27;, 23, city=&#x27;Heaven&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, *, city, age</span>)</span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">person</span>(<span class="params">name, *age, city</span>)</span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br><span class="line"><span class="function"># 命名关键字参数，跟在可变数量参数或一个空*参数后，只能传入指定关键字</span></span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Class</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, score</span>):</span> <span class="comment"># 前后各2下划线，类内任何函数首参数都为self</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = score <span class="comment">#前置2下划线则私有，仍可通过._My_Class__score访问</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Get_Name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line">    Sex = <span class="string">&#x27;Male&#x27;</span></span><br><span class="line"><span class="comment"># 括号内表示父类，object是python中的根基类；__init__()相当于构造函数</span></span><br><span class="line"><span class="comment"># 构造函数外的属性相当于static成员</span></span><br><span class="line"></span><br><span class="line">mc = MyClass(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">70</span>)</span><br><span class="line">mc.age = <span class="number">10</span></span><br><span class="line"><span class="comment"># 通过构造函数来实例化类对象，可以给对象添加属性</span></span><br><span class="line"><span class="comment"># 使用del mc.age删除属性</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mumei</span>(<span class="params">My_Class</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Get_Name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.__score)</span><br><span class="line"><span class="comment"># 子类通过定义同名函数来重载基类函数</span></span><br><span class="line"><span class="comment"># 用函数isinstance(a, type)判断对象的类型是否为type， 使用type(a)得到对象类型</span></span><br><span class="line"><span class="comment"># 使用dir(a)获得对象的所有属性和方法</span></span><br><span class="line"><span class="comment"># 使用hasattr(obj, &#x27;sth&#x27;)判断是否有属性sth</span></span><br><span class="line"><span class="comment"># 使用getattr(obj, &#x27;sth&#x27;)取属性地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Name</span>(<span class="params">MC</span>):</span></span><br><span class="line">    MC.Get_Name()</span><br><span class="line">    </span><br><span class="line">mumei = Mumei(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">Name(mc)</span><br><span class="line">Name(mumei)</span><br><span class="line"><span class="comment"># 对基类和子类通用</span></span><br><span class="line"></span><br><span class="line">other = Other_Class(<span class="string">&#x27;Jerry&#x27;</span>)</span><br><span class="line">Name(other)</span><br><span class="line"><span class="comment"># 任何有Get_Name的对象都可调用</span></span><br></pre></td></tr></table></figure><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>取一个list或tuple的部分元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">L[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 取&#123;1, 2&#125;即下标范围[0,2)的元素</span></span><br><span class="line">L[:<span class="number">2</span>] <span class="comment"># 第一个参数为0时可省略</span></span><br><span class="line">L[-<span class="number">1</span>] <span class="comment"># 取倒数第一个元素</span></span><br><span class="line">L[-<span class="number">2</span>:-<span class="number">1</span>] <span class="comment"># 取倒数两个元素</span></span><br><span class="line">L[-<span class="number">2</span>:] <span class="comment">#-1可省略</span></span><br></pre></td></tr></table></figure><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><p>用[express]生成一个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)] <span class="comment"># 1x1,2x2...10x10</span></span><br><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>] <span class="comment"># 2x2,4x4...10x10</span></span><br><span class="line">[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;DEF&#x27;</span>] <span class="comment"># ABC与DEF的全排列</span></span><br><span class="line"><span class="comment"># 当if出现在for后面时，不可带else</span></span><br><span class="line"><span class="comment"># 当if出现在fot前面时，必须带else</span></span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器仅存储一个生成方法而不是具体对象，有肋于节省空间。</p><p>方法1: 用(express)生成一个生成器(generator)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><p>方法2: 用函数来生成一个生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出斐波那契数列的函数如下</span></span><br><span class="line"><span class="comment"># a, b = b, a + b =&gt; a, b = (b, a + b) =&gt; a = b  b = a + b(a与b的值同时改变)</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把上述函数改成generator, 仅需将print(b)换成yield b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line"></span><br><span class="line">f = fib(<span class="number">6</span>)</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0x02 技术杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的存储结构及其非层序遍历</title>
      <link href="/zh/blog/2020/04/24/0004-Binary_tree/"/>
      <url>/zh/blog/2020/04/24/0004-Binary_tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p>二叉树是我接触的第一个非线性数据结构。在对它进行操作前，如何对其进行构建与遍历很自然地成为了首先要关心的问题。</p><p>这篇文章总结了：</p><ol><li>二叉树的五个性质</li><li>如何存储一个二叉树</li><li>二叉树的先序、中序和后序遍历及其非递归实现</li><li>以及通过二叉树中序序列+先序/后序序列构建二叉树的方法</li><li>如何计算一对先序序列和后序序列可能表示的二叉树个数。</li></ol></blockquote><span id="more"></span><h2 id="二叉树的五个性质"><a href="#二叉树的五个性质" class="headerlink" title="二叉树的五个性质"></a>二叉树的五个性质</h2><ol><li><p>二叉树的第i层上至多有2^(i - 1)个结点</p></li><li><p>深度为k的二叉树至多有2^k - 1个结点</p></li><li><p>对任何一棵二叉树T, 其终端结点数 = 度为2的结点数 + 1</p></li><li><p>具有n个结点的完全二叉树深度为：log2(n) + 1</p><p> 满二叉树：每一层结点数都为最大</p><p> 完全二叉树：每一结点按层的编号都与对应的满二叉树一一对应</p><p> <img src="https://img.xilong.site/20200424/image-20200422231103355.png" alt="image-20200422231103355"></p><p> <em>a.满二叉树    b.完全二叉树</em></p></li><li><p>对一颗有n个结点的完全二叉树，将其结点按层序编号i，有</p><ol><li><p>i=1，则该结点为根结点，无双亲</p></li><li><p>2i&gt;n，则结点i无左孩子，否则其左孩子是2i</p></li><li><p>2i + 1 &gt; n则结点无右孩子，否则其右孩子是2i + 1</p></li></ol></li></ol><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="1. 顺序存储结构"></a>1. 顺序存储结构</h3><p>将完全二叉树上序号为i的结点存在数组中标号为i - 1的地址中，如非完全二叉树，则空出来的地址留空。此时子结点用性质5即可得到。</p><p><img src="https://img.xilong.site/20200424/image-20200422233319114.png" alt="image-20200422233319114"></p><p>上面三个二叉树的存储结构分别为：</p><p><img src="https://img.xilong.site/20200424/image-20200422233546201.png" alt="image-20200422233546201"></p><p><em>(用0表示结点不存在)</em></p><p>可以看出，当二叉树不是完全二叉树时，这种结构非常浪费存储空间。因此仅适合用作完全二叉树的存储。</p><h3 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="2. 链式存储结构"></a>2. 链式存储结构</h3><p>二叉树用链表来存储是非常自然的，常见的有二叉链表和三叉链表。</p><h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>二叉链表的组织形式：</p><p><img src="https://img.xilong.site/20200424/image-20200422234628192.png" alt="image-20200422234628192"></p><p><img src="https://img.xilong.site/20200424/image-20200422234844999.png" alt="image-20200422234844999"></p><h4 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h4><p>三叉链表在二叉链表的基础上添加了指向父结点的指针，与二叉链表大同小异。</p><p>三叉链表的组织形式：</p><p><img src="https://img.xilong.site/20200424/image-20200422235517745.png" alt="image-20200422235517745"></p><p><img src="https://img.xilong.site/20200424/image-20200422235734363.png" alt="image-20200422235734363"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Node *leftChild;</span><br><span class="line">    Node *rightChild;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125; *BinTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateBinTree</span><span class="params">(BinTree &amp;tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree = <span class="keyword">new</span> Node&#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error While Create BinTree!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertChild</span><span class="params">(Node *aim, <span class="keyword">bool</span> left)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *newNode = <span class="keyword">new</span> Node&#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(newNode == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error While Add Note!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left)</span><br><span class="line">    &#123;</span><br><span class="line">        aim-&gt;leftChild = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        aim-&gt;rightChild = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteChild</span><span class="params">(Node *aim, <span class="keyword">bool</span> left)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(aim == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    Node *preDel = (left) ? aim-&gt;left : aim-&gt;right;</span><br><span class="line">    <span class="keyword">if</span>(preDel != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(preDel-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DeleteChild</span>(preDel, left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(preDel-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DeleteChild</span>(preDel, right);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">delete</span> preDel;</span><br><span class="line">        preDel = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left)</span><br><span class="line">    &#123;</span><br><span class="line">        aim-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        aim-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Visit</span><span class="params">(Bintree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; T-&gt;data &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>要遍历二叉树，可将二叉树分为三个部分，左子树(L)、根(D)、右子树(R)，并依次访问每个部分。若规定左子树一定先于右子树访问，则共有三种情况：DLR、LDR、LRD。分别称为前（先）序遍历、中序遍历和后序遍历。</p><p>这三种遍历的算法是递归描述的，如下：</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>若二叉树为空，则空操作，否则</p><ol><li>访问根结点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol><h4 id="算法的递归实现"><a href="#算法的递归实现" class="headerlink" title="算法的递归实现"></a>算法的递归实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DLR</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Visit</span>(T) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">DLR</span>(T-&gt;left) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">DLR</span>(T-&gt;right) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>若二叉树为空，则空操作，否则</p><ol><li>中序遍历左子树</li><li>访问根结点</li><li>中序遍历右子树</li></ol><h4 id="算法的递归实现-1"><a href="#算法的递归实现-1" class="headerlink" title="算法的递归实现"></a>算法的递归实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LDR</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">LDR</span>(T-&gt;left) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Visit</span>(T) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">LDR</span>(T-&gt;right) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><p>若二叉树为空，则空操作，否则</p><ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根结点</li></ol><h4 id="算法的递归实现-2"><a href="#算法的递归实现-2" class="headerlink" title="算法的递归实现"></a>算法的递归实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LRD</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">LRD</span>(T-&gt;left) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">LRD</span>(T-&gt;right) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Visit</span>(T) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种遍历的非递归实现"><a href="#三种遍历的非递归实现" class="headerlink" title="三种遍历的非递归实现"></a>三种遍历的非递归实现</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>由上面的描述可以看出用递归实现三种遍历是非常简洁自然的，然而在大部分情况下递归实现的性能开销大于非递归实现（函数反复调用以及系统堆栈带来的），因此在非常需要考虑性能时可以使用算法的非递归实现（算法的递归几乎都可以转化成非递归实现）。</p><p>为了实现非递归遍历，先来看看遍历过程中发生了什么。</p><p>在遍历过程中，每个结点有三次访问机会，即指针从父结点指向自身，从左孩子退回，从右孩子退回。这里我们不妨规定没有左/右孩子的结点仍能获得空指针退回的访问机会（即将空指针看做一个无法进入的孩子结点）。</p><p><img src="https://img.xilong.site/20200424/image-20200423090748670.png" alt="image-20200423090748670"></p><p>由于我们规定了左子树一定在右子树之前遍历，整个树的遍历顺序就如上图所示(a-&gt;b)。我们在每个结点的左侧、下侧和右侧分别设定一个触发点，并将它们在遍历路径中出现的顺序记录下来。</p><p>对于左触发点：ABDECFG</p><p>对于下触发点：DBEAFCG</p><p>对于右触发点：DEBFGCA</p><p>可以看出，它们分别是这个二叉树的前序序列、中序序列和后序序列。因此，实现正确的遍历顺序，并在合适的时机访问结点，就可以实现非递归地遍历二叉树。</p><h4 id="前序遍历和中序遍历"><a href="#前序遍历和中序遍历" class="headerlink" title="前序遍历和中序遍历"></a>前序遍历和中序遍历</h4><p>前序遍历和中序遍历的实现相对后序遍历简单，描述为：</p><ol><li>向左一路前进，若下一结点为空则退栈，否则将其压入栈中。</li><li>若指针是左子树退回，则进入右子树。若指针是右子树退回，则表示当前层遍历结束，继续退一层。这也意味着进入右子树时可以将当前结点直接退栈。</li><li>栈为空时，遍历完成。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LDR</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个存储遍历信息的栈和一个用来遍历树的指针</span></span><br><span class="line">    stack&lt;Node*&gt; S;</span><br><span class="line">    Node *cur = T;</span><br><span class="line">    <span class="comment">//每访问一个结点就将结点出栈，因此以栈非空作为循环条件</span></span><br><span class="line">    <span class="comment">//最后出栈的必是一个叶子结点，因此指针的值在结束时必为nullptr</span></span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>() || cur != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//指针非空时一路向左走并将沿途结点压入栈中</span></span><br><span class="line">        <span class="comment">//指针为空则表示走到了当前路径的尽头，将最后入栈的结点出栈并令指针指向该结点的右子树</span></span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            S.<span class="built_in">push</span>(cur);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; cur-&gt;data; 前序时在此输出。</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = S.<span class="built_in">top</span>();</span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; cur-&gt;data; <span class="comment">//中序时在此输出。</span></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：一路向左，非空则进。遇空出栈，右子代之。</p><h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>在前面的代码中我们实际上省略了对指针是由左子树退回还是右子树退回的判断，直接在指针进入右子树时将当前结点出栈。对于前序遍历和中序遍历而言这样做并没有影响，因为它们的访问操作都在指针进入右子树之前。但是对于后序遍历显然是不行的，这里对上述算法进行改进：</p><ol><li>指针非空时向左前进到底，若指针非空则压入栈中，初始化一个指针保存最近出栈的结点。</li><li>指针为空时令指针指向栈顶，进行判定，若指针的右子树存在且没有遍历过则进入右子树，否则输出指针所指元素并退栈。同时将指针置零以免将已退栈的元素重新入栈。</li><li>栈为空时，遍历完成。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LRD</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;Node*&gt; S;</span><br><span class="line">    Node *cur = T;</span><br><span class="line">    <span class="comment">//存储最后退栈的元素</span></span><br><span class="line">    Node *lastPop = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>() || cur != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//非空时向左前进到底</span></span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; cur-&gt;data; 仍然可用于前序遍历</span></span><br><span class="line">            S.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = S.<span class="built_in">top</span>();</span><br><span class="line">            <span class="comment">//判定当前结点是否存在右子树以及右子树是否遍历过</span></span><br><span class="line">            <span class="comment">//此处是否存在的判定是必要的，否则当lastPop非空而当前结点又不存在右子树时，</span></span><br><span class="line">            <span class="comment">//将导致指针不断尝试进入不存在的右子树引发死循环</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right != lastPop)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; cur-&gt;data; 中序遍历输出根结点</span></span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//右子树不存在或已遍历过，输出根结点并退栈</span></span><br><span class="line">                S.<span class="built_in">pop</span>();</span><br><span class="line">                cout &lt;&lt; cour-&gt;data;</span><br><span class="line">                <span class="comment">//if(cur-&gt;right == nullptr) cout &lt;&lt; cur-&gt;data; 中序遍历输出叶子结点</span></span><br><span class="line">                <span class="comment">//令lastPop指向最后退栈结点，将cur指针置0以免下一轮循环将已退栈的结点重新入栈</span></span><br><span class="line">                lastPop = cur;</span><br><span class="line">                cur = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：一路向左，非空则进，遇空判定，有右则进，无右则出，不忘置零。</p><h3 id="图解后序遍历的非递归算法"><a href="#图解后序遍历的非递归算法" class="headerlink" title="图解后序遍历的非递归算法"></a>图解后序遍历的非递归算法</h3><p><img src="https://img.xilong.site/20200424/LRD.gif" alt="LRD"></p><p>精力有限，只好挑一个难度最大的做图解。</p><h2 id="通过中序序列-前序-后序序列构建二叉树"><a href="#通过中序序列-前序-后序序列构建二叉树" class="headerlink" title="通过中序序列+前序/后序序列构建二叉树"></a>通过中序序列+前序/后序序列构建二叉树</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul><li><p>前序序列中任一子树以根结点-左子树-右子树的结构排列。</p></li><li><p>中序序列中任一子树以左子树-根结点-右子树的结构排列。</p></li><li><p>后序序列中任一子树以左子树-右子树-根结点的结构排列。</p></li></ul><p>根据以上性质，可以得到算法：</p><ol><li>从前/后序序列中取首/尾元素，确定树的根结点</li><li>在中序序列中搜索根结点，确定左子树和右子树</li><li>对左子树和右子树分别重复这个过程，直到不可再分</li></ol><h4 id="图解：以前序-中序构建为例"><a href="#图解：以前序-中序构建为例" class="headerlink" title="图解：以前序-中序构建为例"></a>图解：以前序-中序构建为例</h4><p><img src="https://os.xilong.site/root/image/20200424/image-20200424000842475.png" alt="image-20200424000842475"></p><p><img src="https://img.xilong.site/20200424/Build.jpg" alt="build"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>前序-中序构建二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据前序-中序序列构建二叉树，代码是通过递归实现的</span></span><br><span class="line"><span class="comment">//SI是string::iterator类型，函数的四个参数分别指向</span></span><br><span class="line"><span class="comment">//前序序列p的首元素和尾后元素，中序序列m的首元素和尾后元素</span></span><br><span class="line"><span class="function">BinTree <span class="title">Pre_Mid_Build</span><span class="params">(SI p_begin, SI p_end, SI m_begin, SI m_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用前序序列的首元素初始化一个仅有根结点的树</span></span><br><span class="line">    Node *boot = <span class="keyword">new</span> Node&#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, *p_begin&#125;;</span><br><span class="line">    <span class="comment">//左子树的前序序列首元素地址为当前前序序列的首元素地址+1</span></span><br><span class="line">    <span class="comment">//中序序列的首元素地址和当前中序序列相同</span></span><br><span class="line">    <span class="keyword">auto</span> left_p_begin = p_begin + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//左子树中序序列的尾后地址为根结点在当前中序序列中出现的位置</span></span><br><span class="line">    <span class="comment">//搜索当前中序序列求出，并求出左子树的长度</span></span><br><span class="line">    <span class="keyword">auto</span> left_m_end = m_begin;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*left_m_end != *p_begin)</span><br><span class="line">    &#123;</span><br><span class="line">        ++left_m_end;</span><br><span class="line">        ++num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用左子树的长度求出左子树前序序列的尾后迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> left_p_end = left_p_begin + num;</span><br><span class="line">    <span class="comment">//若左子树存在，递归构建左子树</span></span><br><span class="line">    <span class="keyword">if</span>(m_begin != left_m_end) </span><br><span class="line">    &#123;</span><br><span class="line">        boot-&gt;left = <span class="built_in">Pre_Mid_Build</span>(left_p_begin, left_p_end, m_begin, left_m_end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右子树的迭代器比较方便取得</span></span><br><span class="line">    <span class="keyword">auto</span> right_p_begin = left_p_end;</span><br><span class="line">    <span class="keyword">auto</span> right_m_begin = left_m_end + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//若右子树存在，递归构建右子树</span></span><br><span class="line">    <span class="keyword">if</span>(right_m_begin != m_end)</span><br><span class="line">    &#123;</span><br><span class="line">        boot-&gt;right = <span class="built_in">Pre_Mid_Build</span>(right_p_begin, p_end, right_m_begin, m_end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序-后序构建二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码与前序-中序大同小异，不再写注释</span></span><br><span class="line"><span class="function">BinTree <span class="title">Post_Mid_Build</span> <span class="params">(SI p_begin, SI p_end, SI m_begin, SI m_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *boot = <span class="keyword">new</span> Node&#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, *(p_end - <span class="number">1</span>)&#125;;</span><br><span class="line">    <span class="keyword">auto</span> left_m_end = m_begin;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*left_m_end != *(p_end - <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ++left_m_end;</span><br><span class="line">        ++num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> left_p_end = p_begin + num;</span><br><span class="line">    <span class="keyword">if</span>(m_begin != left_m_end) </span><br><span class="line">    &#123;</span><br><span class="line">        boot-&gt;left = <span class="built_in">Post_Mid_Build</span> (p_begin, left_p_end, m_begin, left_m_end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> right_p_begin = left_p_end;</span><br><span class="line">    <span class="keyword">auto</span> right_p_end = p_end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> right_m_begin = left_m_end + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(right_m_begin != m_end)</span><br><span class="line">    &#123;</span><br><span class="line">        boot-&gt;right = <span class="built_in">Post_Mid_Build</span> (right_p_begin, right_p_end, right_m_begin, m_end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算一对先序序列和后序序列可能表示的二叉树个数"><a href="#计算一对先序序列和后序序列可能表示的二叉树个数" class="headerlink" title="计算一对先序序列和后序序列可能表示的二叉树个数"></a>计算一对先序序列和后序序列可能表示的二叉树个数</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><ul><li><p>前序序列中任一子树以根结点-左子树-右子树的结构排列。</p></li><li><p>后序序列中任一子树以左子树-右子树-根结点的结构排列。</p></li></ul><p>可能混淆的情况有：根（左/右）+（左/右）根。</p><p>可以知道，前序序列与后序序列中任何有两个子树的树都是确定的。而每一对仅一个子树的树将有两种可能结构。</p><p>因此只要求出序列对中有多少对无法确定的子树即可，很容易发现这样的树对以AB &amp; BA的方式存在。只要搜索两个序列即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为要用到位运算， 使用无符号类型</span></span><br><span class="line"><span class="keyword">using</span> UL = <span class="keyword">unsigned</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string pre, post;</span><br><span class="line">    cin &gt;&gt; pre &gt;&gt; post;</span><br><span class="line">    <span class="comment">//搜索并计数</span></span><br><span class="line">    UL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(UL i = <span class="number">0</span>; i &lt; pre.<span class="built_in">length</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(UL j = <span class="number">1</span>; j &lt; post.<span class="built_in">length</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[i] == post[j] &amp;&amp; pre[i + <span class="number">1</span>] == post[j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                ++sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    UL base = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//位运算计算2的次幂方便且快速，注意括号</span></span><br><span class="line">    cout &lt;&lt; (base&lt;&lt;sum) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0x00 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch Linux安装与配置</title>
      <link href="/zh/blog/2020/03/20/0003-Arch_linux_configuration/"/>
      <url>/zh/blog/2020/03/20/0003-Arch_linux_configuration/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Arch Linux是GNU/Linux的众多发行版中相对小众的一个。相对Ubuntu等更加广为人知的发行版，Arch对新手并不是很友好。这篇文章旨在从零开始，一步一步帮助读者完成Arch Linux的安装与配置。</p></blockquote><span id="more"></span><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><h3 id="检查你的硬件"><a href="#检查你的硬件" class="headerlink" title="检查你的硬件"></a>检查你的硬件</h3><p>在安装Arch Linux之前，请先确认你的硬件是否支持Linux，通常显卡与网卡比较容易出现问题。这篇文章将以硬件完全兼容作为前提，如果你的硬件不被支持可以尝试更换硬件。</p><p>这里给出本文所用机器的配置以供参考。</p><table><thead><tr><th>硬件名称</th><th>型号</th></tr></thead><tbody><tr><td>处理器</td><td>Intel Core i5-8250U</td></tr><tr><td>独立显卡</td><td>AMD ATI Radeon 550</td></tr><tr><td>集成显卡</td><td>Intel UHD Graphics 620</td></tr><tr><td>网卡</td><td>Intel 9260AC</td></tr></tbody></table><h3 id="为什么选择Arch-Linux"><a href="#为什么选择Arch-Linux" class="headerlink" title="为什么选择Arch Linux"></a>为什么选择Arch Linux</h3><p><a class="link"   href="https://wiki.archlinux.org/index.php/Arch_Linux" >点击进入官方介绍页面<i class="fas fa-external-link-alt"></i></a></p><p>对我而言Arch Linux相效于其它发行版有以下几点优点：</p><ol><li><p>极简的安装：安装完成后的Arch Linux仅有一百余个软件包，作为对比，Ubuntu通常有上千个包。</p></li><li><p>高度可定制化：事实上几乎任何GNU/Linux发行版都高度支持个性化定制，但Arch Linux相较其它发行版要更加方便。</p></li><li><p>最好用的包管理器：pacman几乎是公认的最好用的包管理器，也许还有其它不比它差的包管理器，但你很难找到一个比它更好的。</p></li><li><p>滚动更新：Arch Linux采用滚动更新机制，这意味着只要安装一次就可以一直使用最新版本的系统而不用重装。</p></li><li><p>最丰富的软件包：Arch Linux允许用户在AUR中发布自已的软件，这使得Arch Linux在软件包数量上远远领先其它发行版。</p></li></ol><p>另一方面，这些优点也意味着Arch Linux无法长时间停留在某一版本，安装更繁琐，且可能不如其它发行版稳定。用作个人桌面通常不用担心这些问题。</p><h2 id="安装：基本系统的搭建"><a href="#安装：基本系统的搭建" class="headerlink" title="安装：基本系统的搭建"></a>安装：基本系统的搭建</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>首先需要下载Arch Linux的镜像文件，建议从国内的镜像源下载，比如：<a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/" >清华大学开源软件镜像站<i class="fas fa-external-link-alt"></i></a>。</p><p>安装过程可能会随时产生变化，为防止步骤过期对读者造成误导，这里不再赘述，参看<a class="link"   href="https://wiki.archlinux.org/index.php/Installation_guide" >ArchWiki<i class="fas fa-external-link-alt"></i></a>即可。</p><h3 id="对wiki的一些补充"><a href="#对wiki的一些补充" class="headerlink" title="对wiki的一些补充"></a>对wiki的一些补充</h3><ol><li><p>EFI分区的格式是FAT32，使用<code>mkfs.fat -F32 /dev/sdxx</code>创建。</p></li><li><p>一些常用功能并未包含在core组中，需单独安装。如:</p></li></ol><ul><li>网络管理工具(NetworkManager)</li><li>sudo</li><li>vim</li></ul><ol start="3"><li><p>若系统以BIOS模式启动，分区时记得为GRUB提前分配一个1M大小的分区，参照<a class="link"   href="https://wiki.archlinux.org/index.php/GRUB" >GRUB-ArchWiki<i class="fas fa-external-link-alt"></i></a>。</p></li><li><p>安装系统时建议直接安装linux-lts:</p><p> 即<code>pacstrap /mnt base linux linux-firmware</code>这步换成<code>pacstrap /mnt base linux-lts linux-firmware</code></p></li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>参照<a class="link"   href="https://wiki.archlinux.org/index.php/General_recommendations" >General recommendations-ArchWiki<i class="fas fa-external-link-alt"></i></a>，完成用户、网络等设置，并安装xorg服务。</p><h3 id="yay"><a href="#yay" class="headerlink" title="yay"></a>yay</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li>安装<code>base-devel</code>、<code>git</code>、<code>go</code></li><li>执行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://aur.archlinux.org/yay.git</span><br><span class="line"><span class="built_in">cd</span> yay</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol><li>安装包: <code>yay -S &lt;package name&gt;</code></li><li>搜索包: <code>yay -Ss &lt;package name&gt;</code></li></ol><p>详见man page: <code>man yay</code></p><h3 id="zsh-amp-amp-oh-my-zsh"><a href="#zsh-amp-amp-oh-my-zsh" class="headerlink" title="zsh &amp;&amp; oh-my-zsh"></a>zsh &amp;&amp; oh-my-zsh</h3><ol><li><p>安装：<code>yay -S zsh oh-my-zsh-git</code></p></li><li><p>切换默认终端：<code>chsh -s /bin/zsh</code></p></li><li><p>配置可参考<a class="link"   href="https://wiki.archlinux.org/index.php/Zsh" >zsh-ArchWiki<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/ohmyzsh/ohmyzsh" >oh-my-zsh<i class="fas fa-external-link-alt"></i></a></p><ol><li><p>复制配置文件：<code>cp /usr/share/oh-my-zsh/zshrc ~/.zshrc</code></p></li><li><p>更改主题：<code>vim .zshrc</code>, 将<code>ZSH_THEME</code>的值改为<code>&quot;agnoster&quot;</code>或其它主题名称</p></li><li><p>安装powerline字体：<code>yay -S powerline-fonts-git</code></p></li></ol><p> 此时还看不出效果，显示powerline字体需要图形界面。</p></li></ol><h3 id="梯子"><a href="#梯子" class="headerlink" title="梯子"></a>梯子</h3><h4 id="Trojan"><a href="#Trojan" class="headerlink" title="Trojan"></a>Trojan</h4><ol><li><p>安装<code>sudo pacman -S trojan</code></p></li><li><p>编辑配置文件/etc/trojan/config.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;run_type&quot;</span>: <span class="string">&quot;client&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;local_addr&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;local_port&quot;</span>: <span class="number">1080</span>,</span><br><span class="line"> <span class="attr">&quot;remote_addr&quot;</span>: <span class="string">&quot;your addr&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;remote_port&quot;</span>: your addr port,</span><br><span class="line"> <span class="attr">&quot;password&quot;</span>: [</span><br><span class="line">     <span class="string">&quot;your password&quot;</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">&quot;log_level&quot;</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">&quot;ssl&quot;</span>: &#123;</span><br><span class="line">     <span class="attr">&quot;verify&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">     <span class="attr">&quot;verify_hostname&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">     <span class="attr">&quot;cert&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">     <span class="attr">&quot;cipher&quot;</span>: <span class="string">&quot;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:AES128-SHA:AES256-SHA:DES-CBC3-SHA&quot;</span>,</span><br><span class="line">     <span class="attr">&quot;cipher_tls13&quot;</span>: <span class="string">&quot;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&quot;</span>,</span><br><span class="line">     <span class="attr">&quot;sni&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">     <span class="attr">&quot;alpn&quot;</span>: [</span><br><span class="line">         <span class="string">&quot;h2&quot;</span>,</span><br><span class="line">         <span class="string">&quot;http/1.1&quot;</span></span><br><span class="line">     ],</span><br><span class="line">     <span class="attr">&quot;reuse_session&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">     <span class="attr">&quot;session_ticket&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">     <span class="attr">&quot;curves&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">&quot;tcp&quot;</span>: &#123;</span><br><span class="line">     <span class="attr">&quot;no_delay&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">     <span class="attr">&quot;keep_alive&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">     <span class="attr">&quot;reuse_port&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">     <span class="attr">&quot;fast_open&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">     <span class="attr">&quot;fast_open_qlen&quot;</span>: <span class="number">20</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;<span class="comment">//通常来说除了上面三个值以外不必修改</span></span><br></pre></td></tr></table></figure><ol start="3"><li>启动服务<code>sudo systemctl start trojan.service</code></li><li>开机自启<code>sudo systemctl enable trojan.service</code></li></ol></li></ol><p>参照<a href="(https://wiki.archlinux.org/index.php/Shadowsocks">ShadowSocks - ArchWiki</a></p><h4 id="Privoxy"><a href="#Privoxy" class="headerlink" title="Privoxy"></a>Privoxy</h4><ol><li><p>安装<code>sudo pacman -S privoxy</code></p></li><li><p>编辑配置文件/etc/privoxy/config</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//只列出需要修改的值</span><br><span class="line">listem-address  127.0.0.1:8118</span><br><span class="line">forward-socks5  /  127.0.0.1:1080 .</span><br></pre></td></tr></table></figure><ul><li>注意第二行末尾的点</li></ul></li><li><p>启动服务<code>sudo systemctl start privoxy.service</code></p></li><li><p>开机自启<code>sudo systemctl enable privoxy.service</code></p></li></ol><p>参照<a class="link"   href="https://wiki.archlinux.org/index.php/Privoxy" >Privoxy - ArchWiki<i class="fas fa-external-link-alt"></i></a></p><h4 id="配置命令行模式的代理"><a href="#配置命令行模式的代理" class="headerlink" title="配置命令行模式的代理"></a>配置命令行模式的代理</h4><p>将以下内容添加进终端的配置文件.bashrc或.zshrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">proxy_off</span></span>()&#123;</span><br><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br><span class="line"><span class="built_in">unset</span> ftp_proxy</span><br><span class="line"><span class="built_in">unset</span> rsync_proxy</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;proxy off&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> proxy_on&#123;</span><br><span class="line"><span class="built_in">export</span> no_proxy=<span class="string">&quot;localhost,127.0.0.1,localaddress,.localdomain.com&quot;</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:8118&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:8118&quot;</span></span><br><span class="line"><span class="built_in">export</span> ftp_proxy=<span class="string">&quot;http://127.0.0.1:8118&quot;</span></span><br><span class="line"><span class="built_in">export</span> rsync_proxy=<span class="string">&quot;http://127.0.0.1:8118&quot;</span></span><br><span class="line"><span class="built_in">export</span> HTTP_PROXY=<span class="string">&quot;http://127.0.0.1:8118&quot;</span></span><br><span class="line"><span class="built_in">export</span> HTTPS_PROXY=<span class="string">&quot;http://127.0.0.1:8118&quot;</span></span><br><span class="line"><span class="built_in">export</span> FTP_PROXY=<span class="string">&quot;http://127.0.0.1:8118&quot;</span></span><br><span class="line"><span class="built_in">export</span> RSYNC_PROXY=<span class="string">&quot;http://127.0.0.1:8118&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;proxy on&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新登录就可以使用<code>proxy_on</code>/<code>proxy_off</code>来开启/关闭代理了</p><p>如果在进入图形界面之前开启了代理，那么进入图形界面后即为全局代理；反之，则默认不走代理，需要为应用单独配置。</p><h3 id="进军图形界面"><a href="#进军图形界面" class="headerlink" title="进军图形界面"></a>进军图形界面</h3><h4 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h4><ul><li><p>安装xorg-xinit，并将配置文件复制到主目录：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S xorg-xinit</span><br><span class="line">cp /etc/X11/xinit/xinitrc ~/.xinitrc</span><br></pre></td></tr></table></figure><p>  完成下面任一环境的配置后，使用<code>startx</code>进入图形界面</p><p>  <em><strong>不要用sudo来执行startx!</strong></em></p></li><li><p>安装一些字体</p><ul><li>基础</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S ttf-dejavu ttf-liberation wqy-microhei wqy--zenhei</span><br></pre></td></tr></table></figure><ul><li>等宽</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S ttf-monaco ttf-jetbrains-mono</span><br></pre></td></tr></table></figure><ul><li>图形</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S ttf-font-awesome</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>安装输入法</p><ol><li><p>安装fcitx<code>sudo pacman -S fcitx fcitx-im</code></p></li><li><p>安装所用的输入法，例如：</p><ol><li>sun拼音:<code>sudo pacman -S fcitx-sunpinyin</code></li><li>Google拼音:<code>sudo pacman -S fcitx-googlepinyin</code></li><li>搜狗输入法:<code>yay -S fcitx-sougoupinyin</code></li><li>五笔等:<code>sudo pacman -S fcitx-table-extra</code></li></ol></li><li><p>添加环境变量，在主目录新建一个文件~/.pam_environment，并加入以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure></li></ol><p>参照<a class="link"   href="https://wiki.archlinux.org/index.php/Fcitx" >Fcitx - ArchWiki<i class="fas fa-external-link-alt"></i></a></p></li></ul><h4 id="i3-gaps"><a href="#i3-gaps" class="headerlink" title="i3-gaps"></a>i3-gaps</h4><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><ol><li><p>安装i3gaps: <code>yay -S i3-gaps</code></p></li><li><p>添加<code>exec i3</code>到.xinitrc文件的末尾</p></li><li><p>安装polybar:<code>yay -S polybar</code></p><ul><li>特别注意polybar使用的字体是fontawesome:<code>ttf-font-awesome</code></li></ul></li></ol><p>如果没有安装其它桌面环境，还需要以下基础工具：</p><ol><li>终端摸拟器:<code>sudo pacman -S xfce4-terminal</code></li><li>剪贴板:<code>sudo pacman -S xfce4-clipman-plugin</code></li><li>截图工具:<code>sudo pacman -S xfce4-screenshooter</code></li><li>文件管理器:<code>sudo pacman -S thunar</code></li><li>回收站:<code>sudo pacman -S gvfs</code></li><li>压缩文件管理:<code>sudo pacman -S file-roller</code></li><li>锁屏:<code>yay -S i3lock-color</code></li><li>壁纸显示:<code>sudo pacman -S feh</code></li><li>桌面信息:<code>sudo pacman -S conky</code></li></ol><h5 id="附配置文件与官方文档"><a href="#附配置文件与官方文档" class="headerlink" title="附配置文件与官方文档"></a>附配置文件与官方文档</h5><p><a class="link"   href="https://github.com/XilongYang/Arch-i3_configfile" >XilongYang/Arch-i3_configfile<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://i3wm.org/docs/userguide.html" >i3 User’s Guide<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/polybar/polybar/wiki" >polybar wiki<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      <categories>
          
          <category> 0x02 技术杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的声明与定义</title>
      <link href="/zh/blog/2020/02/26/0002-C++:Declaration_and_definition/"/>
      <url>/zh/blog/2020/02/26/0002-C++:Declaration_and_definition/</url>
      
        <content type="html"><![CDATA[<blockquote><p>偶然间看见一个声明:</p><p>struct tm <em>(</em>(<em>Pfunc)[3])(int(</em>)(int, int), float(*[])(float));<br>一时间感到云里雾里。为了弄懂此类复杂的声明学习一些相关的知识，在此总结。</p></blockquote><span id="more"></span><h2 id="声明与定义的区别"><a href="#声明与定义的区别" class="headerlink" title="声明与定义的区别"></a>声明与定义的区别</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><strong>对于C++中的声明，比较通用的描述为：一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名一个变量并指定该变量为与基本数据类型有关的某种类型。</strong></p><p><em>声明语句：  基本数据类型  声明符1&lt;, 声明符2, 声明符3 …&gt;</em></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b = <span class="number">2</span>; </span><br><span class="line"><span class="comment">//int为基本数据类型， a,b为一个含有2个声明符的声明符列表，a与b都是声明符，分别声明（并定义）了名称为a, b的int型变量， 并把2赋值给b。</span></span><br></pre></td></tr></table></figure><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>可以看出，这条语句在声明了a, b的同时定义了它们。这里引出了声明和定义的关系：</p><p><strong>声明使得名字为程序所知，而定义负责建立名字与实体间的关系。</strong>声明规定了变量的类型与名字，而定义在此基础上为变量分配存储空间，还可能为其赋一个初始值。</p><h2 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h2><p>extern关键字常用于表示一个变量已在其它文件中定义。</p><ul><li>如果要<strong>声明一个变量而不定义它</strong>，则在声明语句前加上extern</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a; <span class="comment">//声明int型变量a，但未定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b = <span class="number">2</span>; <span class="comment">//声明并定义int型变量b，并为其赋初始值2</span></span><br></pre></td></tr></table></figure><p>​     <em><strong>任何显式初始化的声明即成为定义</strong></em><em>。即使一个声明符已用extern标记，对其进行初始化仍会导致定义行为。</em></p><ul><li><p>对于<strong>多文件</strong>程序，若要在多个文件中使用<strong>同一个变量</strong>，则必须在<strong>所有</strong>使用该变量的文件中<strong>声明</strong>它，但仅可在<strong>一个</strong>文件中<strong>定义</strong>该变量。</p></li><li><p><strong>不可在函数体内部初始化</strong>一个含有extern标记的变量。</p></li></ul><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p><strong>复合类型指基于其它类型定义的类型 。</strong></p><h3 id="1-引用"><a href="#1-引用" class="headerlink" title="1.引用"></a>1.引用</h3><p>引用即对象的别名，通过将声明符写成&amp;d的形式定义引用类型，其中d是变量名。</p><p>引用<strong>并非对象，不占用内存空间</strong>，仅作为一个已存在对象的别名。因此引用<strong>必须初始化，且不能再绑定到其它对象上。</strong></p><p>引用<strong>类型要与它所绑定的对象严格匹配</strong>，且<strong>仅能绑定在对象上</strong>，而不能绑定在字面值或表达式的计算结果上。该规则有两个例外：</p><ol><li>对const的引用初始值可为任一能转换为引用的类型的对象、字面值或表达式结果。</li><li>基类的引用或指针可绑定到派生类对象上。</li></ol><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r;<span class="comment">//X, 引用必须初始化</span></span><br><span class="line"><span class="keyword">int</span> &amp;ri = i;</span><br><span class="line"><span class="keyword">double</span> &amp;rdi = i;<span class="comment">//X, 引用类型不匹配</span></span><br><span class="line"><span class="keyword">double</span> &amp;rd = <span class="number">3.14</span>;<span class="comment">//X, 非const引用必须绑定到对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> &amp;crdi = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> &amp;crd = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><h3 id="2-指针"><a href="#2-指针" class="headerlink" title="2.指针"></a>2.指针</h3><p>指针存放对象的地址，通过将声明符写成*d的形式定义，其中d是变量名。由于指针存放的并非对象，而是对象的地址，故需要**用取地址符&amp;取得对象地址。操作其绑定的对象时也要使用解引用符***。</p><p>取地址符&amp;与引用声明符虽然使用同一个符号，但意义不同，一个作用于声明符，一个作用于对象。</p><p>解引用符*与指针声明符亦然，另外解引用符和引用没有关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *pa = &amp;a; <span class="comment">//pa是a的指针， &amp;是取地址符</span></span><br><span class="line"><span class="keyword">int</span> &amp;ra = a; <span class="comment">//ra是a的引用， &amp;是引用声明符</span></span><br><span class="line">ra = <span class="number">3</span>;<span class="comment">//通过引用改变a的值</span></span><br><span class="line">*pa = <span class="number">0</span>;<span class="comment">//通过指针改变a的值</span></span><br><span class="line">pa = <span class="number">0</span>;<span class="comment">//改变指针本身的值</span></span><br></pre></td></tr></table></figure><p>指针与引用类似，但有两点不同：</p><ol><li>指针本身是一个对象，允许赋值和拷贝。</li><li>指针无须在定义时赋初始值，且在函数体内定义的指针有一个不确定的初始值。</li></ol><h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><ol><li><p>空指针: 不指向任何对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>; <span class="comment">//C++11</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>; <span class="comment">//#include&lt;cstdlib&gt;, 值等于0</span></span><br></pre></td></tr></table></figure></li><li><p>void*指针：可指向任何对象，且不能操作所指对象。</p></li><li><p>指向指针的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">int</span> **p2 = p1;</span><br></pre></td></tr></table></figure></li><li><p>指向数组的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p1)[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></li><li><p>函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p1)(&lt;参数列表&gt;) = test;</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p2)(&lt;参数列表&gt;) = &amp;test;<span class="comment">//函数指针赋值时可以不用取地址</span></span><br><span class="line"><span class="built_in">p1</span>(&lt;&gt;);<span class="comment">//函数指针使用时可以不用解引用</span></span><br><span class="line">(*p1)(&lt;&gt;);</span><br></pre></td></tr></table></figure></li><li><p>指针的数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1[<span class="number">5</span>]</span><br></pre></td></tr></table></figure></li><li><p>常量指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><ul><li><p>const<strong>作用于基本类型</strong>或与*连写成<strong>*const</strong>（只要在*后就表示指针本身是常量，与*间可有空格）用以声明常量指针，受const影响的变量的值不能被改变。</p></li><li><p>const对象<strong>仅在文件内有效</strong>，若要在其它文件中使用则需要在<strong>所有声明或定义</strong>语句前<strong>加extern</strong></p></li><li><p>引用可绑定到const对象上形成对const的引用，也称<strong>常量引用</strong>。非常量引用无法绑定常量对象。</p></li><li><p>常量引用<strong>不可用作修改对象的值</strong>，另一方面<strong>其初始值可为任一能转换为引用的类型的对象、字面值或表达式结果</strong>，此时该常量引用实际<strong>绑定了一个临时量</strong>。</p></li><li><p>对于指针而言，<strong>指针本身是const称为顶层const，指针指向的对象是const称为底层const</strong>。仅底层const可用于指向常量对象。</p></li><li><p>在<strong>类成员函数参数列表后使用const</strong>将该函数声明为const成员函数，其内在原理为作用于隐式参数<em>this</em>指针，从而使其能指向常量对象。因此<strong>类的const对象仅能调用const成员函数</strong>。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>; <span class="comment">//i的值可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = i; <span class="comment">//不可通过ri改变i的值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pib = &amp;i; <span class="comment">//不可通过pib改变i的值， 可改变pib的值</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> pib = &amp;i; <span class="comment">//可通过pib改变i的值， 不可改变pib的值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> pib = &amp;i;<span class="comment">//不可通过pib改变i的值， 不可改变pib的值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;rj = j; <span class="comment">//X</span></span><br><span class="line"><span class="keyword">int</span> *pj = j; <span class="comment">//X</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* pj = j; <span class="comment">//X，必须是底层const才能绑定const对象。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class A&#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">void HW()&#123;cout &lt;&lt; &quot;HelloWorld&quot; &lt;&lt; endl;&#125;</span></span><br><span class="line"><span class="comment">void HW_c() const &#123;cout &lt;&lt; &quot;HelloWorld&quot; &lt;&lt; endl;&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">A a1;</span><br><span class="line">a1.<span class="built_in">HW</span>(); <span class="comment">//合法</span></span><br><span class="line">a1.<span class="built_in">HW_c</span>();<span class="comment">//合法，普通对象可调用const成员函数</span></span><br><span class="line"><span class="keyword">const</span> A a2;</span><br><span class="line">a2.<span class="built_in">HW</span>();<span class="comment">//非法，即使非常量成员函数内没有改变对象的操作，仍不能被const对象调用</span></span><br><span class="line">a2.<span class="built_in">HW_c</span>();<span class="comment">//合法</span></span><br></pre></td></tr></table></figure><h2 id="constexpr关键字"><a href="#constexpr关键字" class="headerlink" title="constexpr关键字"></a>constexpr关键字</h2><p>常量表达式指在编译时就能得到值且不会改变的表达式。常见的有字面值与用常量表达式初始化的const对象。</p><p>实际使用时往往很难确定一个表达式是否是常量表达式。此时可用constexpr声明该变量， 以由编译器检查其是否为常量表达式。</p><p>constexpr在声明指针时，会将指针设为顶层const。</p><p>constexpr函数需要满足：</p><ul><li>返回类型及所有形参类型都是字面值类型。</li><li>函数体中有且只有一条return语句。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *p = null; <span class="comment">//p是指向整数的常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = null;<span class="comment">//p1是指向整数常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *p2 = null;<span class="comment">//p2是指向整数常量的常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = null;<span class="comment">//p3是指向整数常量的常量指针</span></span><br></pre></td></tr></table></figure><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>static将作用对象声明为静态对象，有四种主要用法：</p><ol><li><p>对于<strong>全局或命名空间</strong>作用域，使用static标记声明符使该对象<strong>仅在此文件可用</strong>。</p></li><li><p>对于在<strong>函数</strong>作用域定义的变量，使用static标记使该变量在函数<strong>调用结束后不被释放</strong>。</p></li><li><p>对于在<strong>类</strong>作用域定义的<strong>数据成员</strong>，使用static标记使该成员为<strong>整个类共用</strong>而不属于任何对象。通常类的静态成员必须<strong>在类外定义及初始化</strong>，且<strong>不能在类外重复使用static</strong>。</p><ul><li><em>字面值常量类型的constexpr静态数据成员（常量表达式并不一定是用constexpr关键字定义的）可在类内用const整数类型的初始值初始化。即便如此，仍应在类外定义该成员，否则任何编译器不能直接用该成员的值替换该成员的场景都会引起错误。且此时在类外的定义不能再提供初始值。</em></li></ul></li><li><p>对于在<strong>类</strong>作用域定义的<strong>函数成员</strong>，使用static标记使该成员为<strong>整个类共用</strong>。静态成员函数不与任何对象绑定，不包含<em>this</em>指针，因此不能声明为const类型 。静态函数成员仅能使用其它静态成员。</p></li></ol><ul><li>union的成员不能声明成static类型 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.cpp</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//b.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;<span class="comment">//X, a.cpp内定义的a只能在本文件使用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 合法， 重新定义了一个a</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b = <span class="number">3</span>; <span class="comment">//非法， 重复定义</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;<span class="comment">//合法</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>; <span class="comment">//非法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>; <span class="comment">//错误， 不可在类内初始化普通静态成员</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> e = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> f = <span class="number">10</span>; <span class="comment">//在确定表达式为常量表达式时也可以使用const</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;HelloWorld!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HW</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误，不可重复static</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">A::HW</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;HW&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::HW</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;HW&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::d = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> A::e;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void AnotherFunc(const int &amp;A);</span></span><br><span class="line"><span class="built_in">AnotherFunc</span>(A::e); </span><br><span class="line"><span class="built_in">AnotherFunc</span>(A::f);<span class="comment">//错误，未在类外定义</span></span><br></pre></td></tr></table></figure><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><h3 id="typedef关键字"><a href="#typedef关键字" class="headerlink" title="typedef关键字"></a>typedef关键字</h3><p>typedef &lt;声明语句&gt; </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*name)</span>[10]</span>; <span class="comment">//将声明语句表示的类型用name指代</span></span><br><span class="line">name p2; <span class="comment">//等价于 int (*p2)[10]</span></span><br></pre></td></tr></table></figure><h3 id="using关键字"><a href="#using关键字" class="headerlink" title="using关键字"></a>using关键字</h3><p>using  &lt;名称1&gt; = &lt;名称2&gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = StringItem; <span class="comment">//令SI等价于StringItem</span></span><br><span class="line">SI s; <span class="comment">//等价于 StringItem s;</span></span><br></pre></td></tr></table></figure><p>注意无论是typedef还是using，它们的别名都是基于语义的，不可以理解成#define式的字符串替换。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *PC1;</span><br><span class="line"><span class="keyword">using</span> PC2 = <span class="keyword">char</span>*;</span><br><span class="line"><span class="comment">// 此时PC1与PC2表示的类型都是char的指针</span></span><br><span class="line">PC1 &amp;p1;</span><br><span class="line"><span class="comment">// 对于这个变量，其类型为PC1的引用即char的指针的引用：char &amp;*p1；而不是char *&amp;p1;</span></span><br><span class="line"><span class="comment">// 对PC2同理，但PC2更容易犯这样的错误，如PC2&amp; = (char*)&amp; = char*&amp;这样的理解是绝对不行的。</span></span><br></pre></td></tr></table></figure><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><h3 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h3><p>通过初始值推导类型，故而必须初始化。</p><ul><li>用引用初始化以auto声明的变量时，变量会以引用的对象类型作为变量类型。如需引用类型需要明确指出。</li><li>以指针初始化auto声明的变量时，会忽略顶层const。如需顶层const需要明确指出。</li><li>要在一条语句中声明多个变量，它们的初始值应该相同。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;a = i;</span><br><span class="line"><span class="keyword">int</span> *p = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p2 = i;</span><br><span class="line"><span class="keyword">auto</span> ii = i; <span class="comment">//ii为int</span></span><br><span class="line"><span class="keyword">auto</span> aa = a; <span class="comment">//aa为int</span></span><br><span class="line"><span class="keyword">auto</span> pp = p; <span class="comment">//pp为int*</span></span><br><span class="line"><span class="keyword">auto</span> pp1 = p1; <span class="comment">//pp1为 const int*</span></span><br><span class="line"><span class="keyword">auto</span> pp2 = p2; <span class="comment">//pp2为 const int*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> &amp;raa = a; <span class="comment">//raa为int&amp;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cpp1 = p1; <span class="comment">//cpp1为 const int const*</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;rii = i; <span class="comment">//rii为 const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> b = rii, c = raa;<span class="comment">//X, rii为const int, raa为int</span></span><br></pre></td></tr></table></figure><h3 id="decltype关键字"><a href="#decltype关键字" class="headerlink" title="decltype关键字"></a>decltype关键字</h3><p>decltype(表达式) &lt;声明符&gt;</p><ul><li><p>decltype检查表达式的值类型，但<strong>不实际计算该表达式</strong>。</p></li><li><p>decltype并不会改变顶层const和引用。</p><ul><li>引用仅在这种用途时不作为其绑定对象的同义词。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(r) rr = i; <span class="comment">//rr为 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(p) pp = null;<span class="comment">//pp为 int *const</span></span><br></pre></td></tr></table></figure><h3 id="复杂声明的理解"><a href="#复杂声明的理解" class="headerlink" title="复杂声明的理解"></a>复杂声明的理解</h3><p><strong>由内而外，由右及左。</strong></p><p>即优先找离声明符最近的复合类型声明。对于距离声明符距离相同的复合类型声明，优先处理声明符右边。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *(*(*<span class="title">Pfunc</span>)[3])(<span class="title">int</span>(*)(<span class="title">int</span>, <span class="title">int</span>), <span class="title">float</span>(*[])(<span class="title">float</span>));</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.首先，要找到主声明符的名字，这里是Pfunc</span></span><br><span class="line"><span class="comment">2.找离Pfunc最近的复合类型声明，越近则影响越大，这里离Pfunc最近的是*，即Pfunc最本质上是一个指针。</span></span><br><span class="line"><span class="comment">3.采用由内而外，由右及左的顺序分析，出于语序最好使用英文</span></span><br><span class="line"><span class="comment">Pfunc is a pointer to an array(size 3) about pointer to function(C1, C2) return a pointer to struct tm.</span></span><br><span class="line"><span class="comment">C1: a pointer to a function(int , int) return int</span></span><br><span class="line"><span class="comment">C2: an array about pointer to a function(float) return float</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *(*&amp;i)[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i is a reference for pointer to an array(size 3) about pointer to const int;</span></span><br><span class="line"><span class="comment">const作用是修饰基本类型，不影响判断</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 0x01 C++之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中浮点数的二进制表示（IEEE754）</title>
      <link href="/zh/blog/2019/08/18/0001-C:Floating_point_numbers_IEEE754/"/>
      <url>/zh/blog/2019/08/18/0001-C:Floating_point_numbers_IEEE754/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：最近在C语言学习中遇到了浮点运算精度的问题， 在查找资料后发现是浮点数的储存方式引起的问题，在此做一个记录。</p></blockquote><span id="more"></span><h3 id="问题代码："><a href="#问题代码：" class="headerlink" title="问题代码："></a>问题代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        a += (<span class="keyword">float</span>)arr[i] / <span class="number">10.0</span>;  <span class="comment">//求arr中所有数的平均数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; a) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]); <span class="comment">//将arr中大于平均数的数打印出来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不难看出，以上程序理论上不应该输出任何数据，可是实际运行结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 3 3 3 3 3 3 3 3 3 3</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>经过一番尝试，最后发现是由于本代码中a的值并非3.0而是2.99999，由此判断应该是浮点数的运算精度问题。</p><p>浮点数在内存中是按照IEEE754标准进行储存的， 即一个float类型的数据占用8Byte内存，其中包括符号位1位，阶码8位和尾数23位。图示如下：</p><table><thead><tr><th align="center">S(符号位)</th><th align="center">E(阶码)</th><th align="center">M(尾数)</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0000 0000</td><td align="center">0000 0000 0000 0000 0000 000</td></tr></tbody></table><p>其中符号位决定该浮点数的正负，正值为0，负值为1。</p><p>阶码用以表示该浮点数的指数，其值为</p><p><code>E = e(指数值) + 127</code> </p><p>这样可以保证E不为负数，方便机器运算。其中127为float类型的偏移值，其它浮点类型的有其它偏移值。</p><p>按照浮点规格化表示，尾数的最高有效位应为1，这意味着M表示的值为1.M。</p><p>以遇到的问题中的值0.3为例， 其转化过程如下。</p><ol><li>将十进制数转换为二进制，小数点前除2取余，小数点后乘2取整<br>$$(0.3)_{10} = (0.0100110011001100110011001)_2 $$</li></ol><p>此时可以发现0.3的二进制是无限循环的，故而只能截取到精度对应的位数。</p><ol start="2"><li><p>规格化表示<br>$$0.100110011001100110011001=+1.00110011001100110011001\times2^{-2}$$</p></li><li><p>计算相应的值<br>S=0, E = 127 - 2 = 125 = 0111 1101, M = 0011 0011 0011 0011 0011 001</p></li></ol><p>所以0.3在内存中应该为</p><table><thead><tr><th>S</th><th>E</th><th>M</th></tr></thead><tbody><tr><td>0</td><td>0111 1101</td><td>0011 0011 0011 0011 0011 001</td></tr></tbody></table><p>转化为16进制数为：3E999999</p><p>可以用以下程序验证</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">0.3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, *(<span class="keyword">int</span> *)&amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>得到结果：3E99999A， 与理论计算值3E999999相差1，应该是计算机处理过程中对末位进行了四舍五入。</p>]]></content>
      
      
      <categories>
          
          <category> 0x01 C++之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
